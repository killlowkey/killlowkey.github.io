<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RPC 框架设计复盘</title>
    <url>/2022/03/15/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1-RPC-%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<blockquote>
<p>RPC 轮子源码地址：<a href="https://github.com/killlowkey/rpc-server">https://github.com/killlowkey/rpc-server</a></p>
</blockquote>
<p>RPC（remote produce call）是一个计算机协议，广泛用于分布式系统。该协议允许当前计算机程序去调用其它计算机的程序，就像调用本地方法一样，用户无需关注底层实现的细节。</p>
<p>最近造了个 RPC 框架轮子，通过造轮子来学习 RPC 。并阅读开源 RPC 框架源码，借鉴其优秀的设计，来发现自己设计不足，从而提升工程能力。</p>
<p>造完轮子后，对其整体设计进行复盘，自己得到了些感悟，通过这篇文章来记录 RPC 框架设计思路。</p>
<a id="more"></a>



<h2 id="服务注册-发现"><a href="#服务注册-发现" class="headerlink" title="服务注册/发现"></a>服务注册/发现</h2><p>由一个大型的单体系统向微服务改造，首先要进行模块的拆分，拆分后模块数量少则几十个，多则上百个。进行微服务部署时，这些模块会被当成单体应用进行部署，每个模块就是一个服务，一个服务中部署多个应用。当服务 A 去调用服务 B，首先我们得知道服务 B 的地址，建立起 TCP 链接，才可以进行 RPC 调用。</p>
<p>此时，会引发一个问题，我们应该如何去管理这些服务呢？当服务数量比较少时，可以通过配置的方式，指定服务 B所有的地址，在服务 A进行调用时，从配置中获取服务 B 地址。这种方式可以解决部分问题，但当服务增多时，配置会很繁琐，而且我们无法从配置中对服务进行动态的摘除和增加。</p>
<p>服务动态摘除和增加是分布式系统中核心的功能，当服务 B 流量太高，此时就需要对服务 B 进行动态的扩容，简而言之就是通过加机器的方式，新增的机器会加入到集群，从而对外部提供服务。服务进行升级时，首先需要从集群中将该服务部分应用进行摘除，也就是说这部分应用停止对外进行服务，升级之后在注册到集群中，以此类推从而完成整个服务的升级。</p>
<p>最优解是采用服务中心来对整个集群服务进行管理，当服务启动时向服务中心注册，服务调用时从服务中心拉取对应的服务地址，常见的服务中心有：</p>
<ol>
<li>Zookeeper</li>
<li>Eurek</li>
<li>Naco</li>
<li>Consul</li>
</ol>
<p><img src="https://gitee.com/killkey/images-upload/raw/master/typora/2022-03/78kqR46iYr.png" alt="78kqR46iYr"></p>
<p>服务中心需要保持高可用，否则服务中心挂掉，会导致整个集群都无法工作，因为进行服务调用时，不知道调用服务地址。所以服务中心需要部署多个，但又会引发数据一致性问题。数据一致性一直是分布式系统热点，目前可以归为 AP、CP 两派，主要是在可用性和一致性进行抉择，当服务中心需要管理的服务很多时，AP 的性能要优于 CP，因为 CP 系统同步开销要高于 AP。</p>
<p>当然，也可以在应用层面来预防服务中心挂掉问题，从服务中心拉取服务后，将所有的服务缓存到本地。后续能从服务中心正常拉取服务的话，则对缓存的服务进行更新，当服务中心挂了，从本地拿取服务的地址。这种设计，可以保证服务中心挂了，还可以让集群正常的工作。</p>
<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>当应用引入注册中心的依赖，会向外部暴露一个健康检查的接口，注册中心向服务定时的发送心跳进行健康检查。所谓的健康检查就是判断该服务是否能正常的提供服务，倘若无法服务，那么从注册中心将该服务进行摘除，然后通知其它的服务。</p>
<p>注册中心进行健康检查时，发生网络波动，没有接收到客户端（服务）的心跳，此时不应该判定该服务挂了，而是标记为不健康的状态，后续还一直无法收到心跳时，则从注册中心进行移除。进行网络分区时，当前的注册中心无法与该客户端进行通讯，所以一直收不到该客户端的心跳，但是其它的注册中心能正常收到该客户端心跳，注册中心需要进行协商，来判断该客户端是否需要下线。如果贸然将客户端下线的话，会影响整个集群的性能。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡是分布式系统高可用的基础组件，用于将工作负载分布到不同的服务器，简言之就是将连接分布到不同的服务器进行处理。</p>
<p>对于 RPC 实现负载均衡，该服务需要连接到注册中心，拉取特定服务的服务器地址。进行服务调用时，采用负载均衡算法从服务列表中选择，当注册中心添加或摘除服务时，会进行一个 push 操作，本地根据特定的事件来对本地服务列表进行更改。</p>
<blockquote>
<p>特定服务：服务A只需要调用服务B与服务C，此时只需要从注册中心拉取服务B与服务C的节点即可</p>
</blockquote>
<p>下面，介绍几个目前常用负载均衡算法</p>
<ol>
<li>轮训：第一个连接对应列表第一个服务器，以此类推，直到到达列表尾部，然后循环</li>
<li>随机：随机从列表中选择一个服务</li>
<li>最少连接：选择连接数量最少的服务</li>
<li>Hash：对请求源IP进行 Hash 运算，然后对列表进行取余操作，这种方式在一定程度上保证特定用户连接到同一台服务器</li>
</ol>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>网络进行通讯时，通过字节来传输数据。在应用层面上，将对象转成字节数据，称为序列化；从字节数据转成对象，称为反序列化。流行的 RPC 框架，一般都会采用多种序列化框架，简言之支持多种序列化方式。因为不同的序列化适用的场景不同，可以根据业务场景来对序列化方式进行调整，比如进行跨平台使用，可以采用 Protobuf 序列化。</p>
<p>当然 RPC 框架不一定要去兼容多种序列化方式，兼容只是让系统更加具有扩展性。如果为了实现简单的话，可以仅采用 JSON 序列化。</p>
<p>下面对几个常用的序列化框架进行介绍。</p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>目前最简单最通用的序列化协议，使用广泛，开发效率高，性能相对较低，维护成本较高。</p>
<p>序列化后体积大，影响高并发。并且数据类型单一，在反序列化时影响数据的精度。</p>
<h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p>Goole 提供的序列化框架，简单快速上手，支持跨平台使用，拥有高效的兼容性。对字段进行编码，新添加的字段不会影响老结构，解决了向后兼容的问题。支持序列化与 RPC  一站式解决。采用 IDL 接口定义语言，自动生成多语言代码。</p>
<p>序列化后二进制格式，可读性比较差，不便于调试分析。对象冗余，字段很多，生成的类较大，占用空间。</p>
<h3 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h3><p>Facebook 提供的序列化框架，跨语言，实现简单。支持序列化与 RPC  一站式解决。采用 IDL 接口定义语言，自动生成多语言代码。</p>
<p>Thrift 与 Protobuf 提供的功能类似，缺点也相同，同样采用二进制格式，不便于阅读。并且 Thrift  开发环境，编译比较麻烦。</p>
<h2 id="网络通讯"><a href="#网络通讯" class="headerlink" title="网络通讯"></a>网络通讯</h2><p>谈及 RPC 框架设计，一定绕不过网络通讯。采用合理的 IO 模型，可以极大的提高框架的性能。在 Java 平台上，比较流行的网络框架是 Netty，Netty 对 Java NIO 进行封装，屏蔽了 NIO 实现的复杂性，提供了简易的接口。</p>
<p>下面对三大 IO 模型进行介绍，从而引入 Reactor 模型，最后采用 Netty 作为 RPC 网络通讯框架。</p>
<h3 id="BIO、NIO、AIO"><a href="#BIO、NIO、AIO" class="headerlink" title="BIO、NIO、AIO"></a>BIO、NIO、AIO</h3><p>BIO 是同步阻塞的模型，当服务器接收到连接后，会创建一个新的线程来处理，如果连接不进行读写时，该线程会进行阻塞，从而浪费线程资源。当连接数量不多时，并且数据传输的很频繁，此时 BIO 是一个很好选择，可以充分的利用线程的性能，相比 NIO ，可以更快的处理连接的数据，因为 NIO 需要对多个连接进行处理。</p>
<p><img src="https://gitee.com/killkey/images-upload/raw/master/typora/2022-03/bio.png" alt="bio"></p>
<p>对连接读写操作是阻塞的，当没有数据可读时，线程就会阻塞。线程的创建和释放需要性能开销，为了解决 BIO 问题，引入了 同步非阻塞 NIO，NIO 采用多用复用的机制，一个线程处理多个连接，当连接可进行读写时，则进行处理。在 Netty 中默认使用的是 NIO，这种模型可以应对更高的并发，在真实场景中，并不是所有的连接都在频繁的传输数据，大部分的连接还是处于空闲状态。</p>
<p><img src="https://gitee.com/killkey/images-upload/raw/master/typora/2022-03/NIO.png" alt="NIO"></p>
<p>AIO 是异步模型，引入异步通道概念，采用了 Proactor 模式，用户通过注册数据处理的 callback，之后对连接数据的读写都是由操作系统来完成。目前这种模型并未被广泛的使用，Linux 默认采用的还是 NIO 模型。</p>
<p>谈到 IO 模型，需要了解同步、异步、阻塞、非阻塞概念，才能更好理解每种 IO 模型的优缺点，从而在正确场景应用。</p>
<ol>
<li>同步：用户线程发起I/O请求后需要等待或者轮询内核I/O操作完成后才能继续执行</li>
<li>异步：用户线程发起I/O请求后仍需要继续执行，当内核I/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数 </li>
<li>阻塞：I/O操作彻底完成后才能返回用户空间</li>
<li>非阻塞：I/O操作被调用后返回一个状态值，无需等I/O操作完成</li>
</ol>
<h3 id="Reactor-模型"><a href="#Reactor-模型" class="headerlink" title="Reactor 模型"></a>Reactor 模型</h3><p>Reactor 是 Douglas C. Schmidt 发表的 <a href="http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf">An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events</a> 论文中提出的模型。这种模型采用了 Boss-Worker 机制，在 Boss 里面只含有一个线程，而 Worker 采用线程池的机制。前者用于接收客户端连接，后者用于处理连接，它们底层都是采用了多路复用的机制。Boss 接收到连接之后，会对 Worker 中的线程进行轮训操作，注册连接到指定的 Worker 线程，该连接的生命就与该线程进行绑定了，直到该连接关闭，后续都是由绑定线程处理。</p>
<p><img src="https://gitee.com/killkey/images-upload/raw/master/typora/2022-03/reactor.png" alt="reactor"></p>
<p>这种设计可以使得系统拥有很高的并发量，同时也对角色进行职责划分。Netty 底层采用了这套模型， 所以不建议在 Netty 的 Worker 线程中进行耗时操作，因为会影响整个服务性能，对于耗时操作，可以开辟额外的线程池进行处理。</p>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><blockquote>
<p>Netty 的线程模型，还查看 Reactor 模型</p>
</blockquote>
<p>Netty 是一个异步事件驱动的网络框架，对 Java NIO 进行封装，并屏蔽了大量实现细节。用于快速开发可维护的高性能协议服务器和客户端。</p>
<p>框架内置了大量的编解码器，可以对常见的协议或内容进行编解码操作。此外 Netty 提供内存池设计，通过引用计数对内存进行管理，当内存没有引用时，对内存进行回收，从而让其它线程进行复用。这种设计可以避免对内存进行反复的创建和释放的性能开销，此外 Netty 还对其它操作进行优化，使得 Netty 性能很优。</p>
<p>该章节，并不会介绍 Netty 基本操作，主要讲述 Netty 最佳实践和一些遇到的坑。</p>
<p>RPC 是基于 TCP 的协议，之所以不采用 UDP，因为 UDP 传输具有不可靠性，对于 RPC 框架是不容忍数据丢失的。随之而来的问题，TCP 是面向字节流传输协议，当进行传输数据时，数据可能会被拆分成多个包。所以需要在应用层面将这些包进行组合拼装，这就是 TCP 沾包/拆包的处理，所谓的处理，就是当数据不是完整数据时，需要等到下一个 TCP 包传输，直到数据变得完整。例如，当进行传输 JSON 数据时，第一个包只收到了 JSON 一半的数据，另一半数据还在下一个包中，这种情况需要等待下一个包传输过来，从而才能进行 JSON 解析。</p>
<p>Netty 自带了几种解决方案，当进行协议设计时，可以选择合适的沾包处理。</p>
<ol>
<li><p>消息定长：FixedLengthFrameDecoder </p>
<blockquote>
<p>读取指定长度的数据，数据长度不满足则进行等待</p>
</blockquote>
</li>
<li><p>包尾增加特殊字符分割</p>
<ol>
<li>行分隔符类：LineBasedFrameDecoder</li>
<li>自定义分隔符类 ：DelimiterBasedFrameDecoder</li>
</ol>
</li>
<li><p>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</p>
</li>
</ol>
<p>采用 JSON 作为传输数据，需要在 Pipeline 头部添加 JsonObjectDecoder 处理器，会等待当前的数据是一个完整的 JSON，才交给下一个 ChannelHandler 进行处理。关于其它的协议的编解码器，请参考 Netty 官方 API 文档。</p>
<p>编写 rpc-server 时，还踩到一个 Netty 坑，就是编解码的顺序要放的正确，否则会导致尾部的 ChannelInboundHandler 无法处理消息。在 rpc-server 中请求和响应的编解码器继承了 ByteToMessageCodec，可以在同一类中同时进行编解码操作。这种方式虽然带来了便捷，但是也埋下了隐患。当时服务端和客户端的编解码器在 Pipeline 中的顺序都是相同的，所以导致客户端无法处理服务响应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline()</span><br><span class="line">    <span class="comment">// 请求与响应编解码器</span></span><br><span class="line">    .addLast(<span class="keyword">new</span> RpcRequestCodec())</span><br><span class="line">    .addLast(<span class="keyword">new</span> RpcResponseCodec());</span><br></pre></td></tr></table></figure>
<p>后来排查了好久，才发现是编解码器位置不正确的问题，当客户端接收服务端响应，首先经过请求解码器，但是请求解码器是无法对响应进行解码的，数据也没有交由下一个解码器进行处理，从而导致响应数据被吞了。面对这种情况，只需要将客户端的编解码位置调整一下，就可以对响应进行解码操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline()</span><br><span class="line">    .addLast(<span class="keyword">new</span> RpcResponseCodec())</span><br><span class="line">    .addLast(<span class="keyword">new</span> RpcRequestCodec());</span><br></pre></td></tr></table></figure>
<p>目前在 Netty 中遇到的问题就是这些，当然 Netty 也比较容易发生内存泄露问题，这是由于申请 ByteBuf，使用之后并没有及时释放，从而导致内存不断积压，从而导致泄露。解决也很简单，ByteBuf 使用后调用 ReferenceCountUtil#release 释放即可，但后续还需使用该 ByteBuf 话，请不要进行释放操作，否则会引发连锁反应。</p>
<h3 id="传输安全"><a href="#传输安全" class="headerlink" title="传输安全"></a>传输安全</h3><p>到现在为止，RPC 数据还是通过明文进行传输，会导致数据被拦截并修改。此时需要引入传输加密的协议 SSL/TLS，该协议在应用层与传输层之间进行工作。当服务端与客户端进行通讯时，服务端进行对原始数据加密，加密数据到达客户端，客户端对加密数据进行解密操作。</p>
<p>SSL/TLS 协议采用公钥加密法，简言之，客户端向服务端索要公钥，然后用公钥进行加密，服务器收到密文之后，用自己的私钥进行解密。这会引出一个问题，如何保证公钥不会被修改？可以采用证书的方式，将公钥放入到证书中，证书是可信的，公钥就是可行的。</p>
<p>上述提到的是单向认证，只有一个对象来校验对端证书的合法性，一般由客户端来进行校验。客户端只需要 ca.crt，服务端需要 server.crt、server.key。要是进行双向认证，那客户端需要持有 ca.crt、client.crt、client.key；服务端需要持有 ca.crt、server.crt、server.key。</p>
<p>Netty 中实现 SSL/TLS 加密，通过 SslHandler 进行实现。看到如下例子， initChannel 方法通过 SslContext 创建 SSLEngine 实例，并设置 SslEngine 是 client 或者是 server 模式。之后将 SslHandler 添加到 Pipeline 头部进行加解密操作。</p>
<blockquote>
<p>SslContext 通过证书来进行创建，SSLHandler 需要在服务端与客户端都添加。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SslChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SslContext context;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> startTls;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SslChannelInitializer</span><span class="params">(SslContext context, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> client, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> startTls)</span> </span>&#123;   <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.startTls = startTls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SSLEngine engine = context.newEngine(ch.alloc());  <span class="comment">//2</span></span><br><span class="line">        engine.setUseClientMode(client); <span class="comment">//3</span></span><br><span class="line">        ch.pipeline().addFirst(<span class="string">&quot;ssl&quot;</span>, <span class="keyword">new</span> SslHandler(engine, startTls));  <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>RPC 服务启动时，会收集所有注册的方法，提供给远程服务进行调用。RPC 请求进行解析后，从请求中提取出调用方法名与参数，在本地服务中找到注册的方法进行调用。在调用之前，请求中方法参数需要适配本地方法参数。比如，对 say 方法进行调用，该方法接收一个 String 作为参数，所以需要将请求方法参数转为 String，然后才进行调用，这就是方法参数类型适配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RPC 方法调用并不向普通方法调用那么简单，方法调用在运行时完成，所以无法在源码级别编写代码来去调用特定方法，Java 平台提供如下几种方法调用方式</p>
<ol>
<li>Reflect</li>
<li>MethodHandle</li>
<li>ASM</li>
</ol>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>反射在框架设计中使用的很广泛，并且反射使用也很简单。比如我们想去调用 String 的 replaceAll 方法，首先得到 String 的 Class 对象，该对象有三种方式获得。</p>
<ol>
<li>String 实例的 getClass() 方法</li>
<li>String.class</li>
<li>Class 的 forName 方法，通过类加载器得到 Class 对象</li>
</ol>
<p>有了 Class 对象后，可以通过其 getXXXMethod 方法传入方法名、参数类型获取方法对象，将方法访问设置为 true，最后调用 invoke 方法传入对象实例和参数调用即可。对于静态方法而言，无需传入对象实例，只需传入 null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Method method = String.class.getDeclaredMethod(<span class="string">&quot;replaceAll&quot;</span>, String.class, String.class);</span><br><span class="line">    method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    String result = (String)method.invoke(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;l&quot;</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="MethodHandle"><a href="#MethodHandle" class="headerlink" title="MethodHandle"></a>MethodHandle</h3><p>MethodHandle 是 JDK1.7 引入的新特性，本质上将某个具体的方法映射到 MethodHandle，通过MethodHandle直接调用该句柄所引用的底层方法，实际就是对可执行方法的引用。</p>
<p>还拿 String 的 replcaeAll 方法举例，首先获得 MethodHandles.Lookup 对象，根据调用方法的返回类型和参数类型得到 MethodType 对象，之后根据方法的类型，来调用 Lookup 对象特定的方法获得 MethodHandle。</p>
<ol>
<li>findVirtual：实例方法</li>
<li>findStatic：静态方法</li>
</ol>
<p>获取到  MethodHanle 对象后，通过其 invoke 传入对象实例和方法参数进行调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    MethodType methodType = MethodType.methodType(String.class, </span><br><span class="line">                                                  <span class="keyword">new</span> Class[]&#123;String.class,</span><br><span class="line">                                                              String.class&#125;);</span><br><span class="line">    MethodHandle handle = lookup.findVirtual(String.class, <span class="string">&quot;replaceAll&quot;</span>, methodType);</span><br><span class="line">    String result = (String) handle.invoke(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;l&quot;</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">    throwable.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h3><p>ASM 是一种比较高阶的方式，通过生成字节码完成方法的调用，从而避免反射的开销。这种设计思路来源于 <a href="https://github.com/EsotericSoftware/reflectasm">reflectasm</a> 开源项目，rpc-server 对其进行一些改良，从而支持多个类的方法调用。</p>
<p>本质上通过生成 switch-case 字节码来实现，RPC 服务启动时，获取所有注册的 RPC 方法，然后为每个方法分配索引。当 doInvoke 方法调用时，根据方法名获取方法索引，用于在 switch-case 中匹配 case。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doInvoke</span><span class="params">(Object obj, String methodName, Object[] args)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以 switch-case 不采用方法名（String）而是采用索引（int）作为条件，因为 switch-case 在底层实现是采用 number。我们编写如下代码，编译后查看生成的字节码文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (name) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到如下生成的字节码，如果采用 String，首先会调用其 hashCode 方法得到 hash 值，为了解决 hash 冲突的问题，还进行了 equals 判断，符合要求则分配索引。之后来到了下一个 switch-case，通过索引来找到对应的 case 分支。</p>
<p>综合考虑，采用 number 作为条件，可以减少 ASM 实现难度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span> var3 = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(name.hashCode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">            var3 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">113318802</span>:</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">            var3 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 ASM 具体实现在此不做讲解，感兴趣的读者请阅读 <a href="https://github.com/killlowkey/rpc-server/blob/main/src/main/java/com/github/rpc/invoke/asm/AsmGenerator.java">rpc-server</a> 的 AsmGenerator  类。</p>
<p>我们对 doInvoke 方法进行字节码生成，方法参数为 Object、String、Object[] 数组类型。通过方法索引匹配指定的 case，在调用其目标方法。在进行 ASM 生成时，遇到一些坑，在此进行列出。</p>
<ol>
<li><p>需要doInvoke 方法第一个参数进行 checkcast 操作，将泛型（Object）转为具体类型（调用方法所属的类）</p>
</li>
<li><p>调用方法方法中含有原生类型，需要对  Object[] 中指定元素进行 unbox 操作</p>
<blockquote>
<p>doInvoke 方法传递是引用类型，而方法需要原生类型，如果不进行 unbox 操作，那么会出现类型不匹配，导致无法进行方法调用。</p>
</blockquote>
</li>
<li><p>调用方法返回的是原生类型，需要进行 box 操作</p>
</li>
<li><p>调用方法中含有引用或者数组引用类型，也需要对 Object[] 中指定元素进行 checkcast 操作</p>
</li>
</ol>
<h2 id="客户端代理"><a href="#客户端代理" class="headerlink" title="客户端代理"></a>客户端代理</h2><p>客户端向RPC服务发送请求，服务处理后返回响应，客户端对响应进行解析。对于客户端，请求和处理的流程相对繁琐了一些，可以使用动态代理方式来屏蔽底层的细节，让我们只关注业务。因为RPC方法就是Java普通方法，客户端与服务端采用相同的方法签名，然后使用动态代理对其处理。简言之，就是将方法名和方法参数封装成请求发送给服务端，服务端返回响应，将响应内容解析成方法返回的类型。</p>
<p>来看到一个代理例子，RPC 服务提供了 say 方法，在客户端也提供了相同的方法签名</p>
<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">say</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Proxy#newInstnace 方法对 RpcService 接口进行代理，我们将方法名称和参数提取出来组成 RPC 请求，然后发送给服务端，得到响应后提取出方法返回值，根据方法的返回值类型进行转换。</p>
<p>下面用伪代码进行表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[]&#123;RpcService.class&#125;, </span><br><span class="line">                       <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, </span></span></span><br><span class="line"><span class="function"><span class="params">                         Method method, </span></span></span><br><span class="line"><span class="function"><span class="params">                         Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 封装请求</span></span><br><span class="line">        RpcRequest request = <span class="keyword">new</span> RpcRequest(method.getName(), args);</span><br><span class="line">        <span class="comment">// 转换为具体类型</span></span><br><span class="line">        <span class="keyword">return</span> sendRequest(request).cast(method.getReturnType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过对接口的代理，屏蔽了请求和处理细节，用户调用本地方法，实则调用的是远程方法。</p>
<h2 id="系统指标收集"><a href="#系统指标收集" class="headerlink" title="系统指标收集"></a>系统指标收集</h2><p>指标可以有效的反馈系统的运行状态，知道其系统是否健康。收集系统 CPU、内存、磁盘等信息，上传到第三方中间件，便于后续的统计和分析。通过指标生成火焰图，来发现系统的性能毛刺，从而定位系统问题。也可以使用系统指标来实现自定义负载均衡算法，比如节点A机器的性能要比节点B好，那么可以将多一些请求交由节点A进行处理。</p>
<p>实现指标收集有两种方案，其一在 RPC 中编写指标收集的代码，这种方式对代码有侵入性，还会增加维护的难度。其二通过 javaagent 机制，在应用启动时，提前启动指标收集服务，该方式对代码无侵入性，还能有效减少代码复杂度。</p>
<h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><p>分布式系统中，服务之间会进行频繁调用，如果某个服务出现问题，导致整体的调用时间过长影响到业务。为了解决该问题，链路追踪就应景而出了，它会追踪每次调用情况，当出现问题时，可以快速的定位服务的故障点。</p>
<p>Google 的 Dapper 论文是现代分布式链路追踪鼻祖，业界知名的 skywalking、zipkin 链路追踪框架都是基于该论文进行设计。分布式链路追踪系统核心是收集调用信息，通过收集 HTTP、RPC、数据库、中间件调用信息，标记每次调用的时间与tag，来组合成一条完整的链路。</p>
<p>一条链路由多个 span 构成，用户发起调用时，首先会分配 TraceId，作为该链路唯一标识。后续服务A调用服务B或调用数据库等其它中间件，使用 span 表示调用信息，并将其添加到 Trace 中。响应返回前端，意味着请求全部处理完成，所有的调用信息则形成一条完整的链路。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://blog.51cto.com/u_13952501/2173038">JSON、Protobuf、Thrift、MessagePack 对比和开发指南</a></li>
<li><a href="https://segmentfault.com/a/1190000037714804">理解什么是BIO/NIO/AIO</a></li>
<li><a href="https://www.cnblogs.com/loveer/p/11479249.html">彻底理解同步 异步 阻塞 非阻塞 </a></li>
<li><a href="https://en.wikipedia.org/wiki/Reactor_pattern">Reactor Pattern</a></li>
<li><a href="https://kezhenxu94.medium.com/in-the-previous-post-we-already-have-an-echoserver-that-is-implemented-with-java-nio-lets-check-ccf5b5b32da9">Build Your Own Netty — Reactor Pattern</a></li>
<li><a href="https://netty.io/">netty</a></li>
<li><a href="https://www.nowcoder.com/discuss/588903">(近)万字总结，RPC 项目相关问题及解答</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a></li>
<li><a href="https://waylau.com/essential-netty-in-action/CORE%20FUNCTIONS/Securing%20Netty%20applications%20with%20SSLTLS.html">使用 SSL/TLS 加密 Netty 程序</a></li>
<li><a href="https://github.com/EsotericSoftware/reflectasm">reflectasm</a></li>
<li><a href="https://github.com/uber-common/jvm-profiler">jvm profile</a></li>
<li><a href="https://github.com/apache/skywalking">skywalking</a></li>
<li><a href="https://github.com/openzipkin/zipkin">zpikin</a></li>
</ol>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>Java Agent</tag>
        <tag>Design</tag>
        <tag>Trace</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas 启动流程分析</title>
    <url>/2022/02/21/Arthas-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><code>Arthas</code> 是 Alibaba 开源的 Java 诊断工具，开发者无需修改代码或重启 JVM 就可以排查生产环境问题，本质上使用 agent 机制，动态的修改字节码，从而实现插桩。</p>
<p>本文会对 Arthas 启动流程分析，从启动流程来理解 <code>Arthas</code> 工作原理。</p>
<a id="more"></a>



<h2 id="Arthas-启动方式"><a href="#Arthas-启动方式" class="headerlink" title="Arthas 启动方式"></a>Arthas 启动方式</h2><p>根据 Arthas github README 所示，Arthas 提供了两种启动方式：</p>
<ol>
<li><p>Use <code>arthas-boot</code>(Recommended)</p>
</li>
<li><p>Use as.sh</p>
</li>
</ol>
<p>官方更推荐第一种启动方式，这种方式需要在本地下载 <code>arthas-boot</code> jar 包，通过 java -jar 命令启动<code>arthas-boot</code> jar。第二种方式通过脚本方式，会从云端下载相应的 jar 包，之后通过命令行进行启动。这两种方式实现方式相同，目的为了运行 arthas-core.jar。</p>
<h2 id="Bootstrap-源码分析"><a href="#Bootstrap-源码分析" class="headerlink" title="Bootstrap 源码分析"></a>Bootstrap 源码分析</h2><blockquote>
<p>com.taobao.arthas.boot.Bootstrap</p>
</blockquote>
<p>arthas 的 boot模块会在打包时打包成 arthas-boot.jar，首先需要找到该模块的启动类，如 pom.xml 声明的 <code>main-class</code> 属性所示，该 jar 在启动时会运行 Bootstrap 类。</p>
<p>Bootstrap 类使用了 @Description 注解，该注解标注了 arthas-boot 的启动 usage，若读者不熟悉启动参数的话，可以阅读该类的 @Description 注解。</p>
<p>main 方法作为该类的入口点，该方法目的是收集启动 arthas-boot.jar 时传入参数，然后将这些参数作为启动 arthas-core.jar 参数。换句话说，该方法是为了启动 arthas-core jar。因篇幅问题，代码就不完全贴出来了，读者可以在该方法中找到如下的代码，ProcessUtils#startArthasCore 方法中会将参数拼接成一个命令行，执行该命令行，从而启动 arthas-core。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProcessUtils.startArthasCore(pid, attachArgs);</span><br></pre></td></tr></table></figure>


<h2 id="Arthas-源码分析"><a href="#Arthas-源码分析" class="headerlink" title="Arthas 源码分析"></a>Arthas 源码分析</h2><blockquote>
<p>com.taobao.arthas.core.Arthas</p>
</blockquote>
<p>在 main 方法中，将 args 用于创建 Arthas 实例。之后来看到 Arthas 的构造方法，首先调用 parse 将 args 解析成 Configure 实例，然后调用了 attachAgent 方法。因为解析参数流程是无关重要的，所以我们重点关注 attachAgent 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> Arthas(args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        AnsiLog.error(<span class="string">&quot;Start arthas failed, exception stack trace: &quot;</span>);</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">        System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Arthas</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    attachAgent(parse(args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>attachAgent 中 3-9 行代码，目的是为了从 VirtualMachine 列表中查找到与之 pid 对应的 VirtualMachineDescriptor，如若未找到则通过  VirtualMachine#attach(String) 方法直接获取 VirtualMachine，反之则通过 VirtualMachine#attach(VirtualMachineDescriptor) 获取 VirtualMachine。</p>
<blockquote>
<p>注意 attach 是重载方法</p>
</blockquote>
<p>获取到 VirtualMachine 后，调用其 loadAgent 方法加载 arthas-agent jar 包，从而实现后续操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attachAgent</span><span class="params">(Configure configure)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    VirtualMachineDescriptor virtualMachineDescriptor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (VirtualMachineDescriptor descriptor : VirtualMachine.list()) &#123;</span><br><span class="line">        String pid = descriptor.id();</span><br><span class="line">        <span class="keyword">if</span> (pid.equals(Long.toString(configure.getJavaPid()))) &#123;</span><br><span class="line">            virtualMachineDescriptor = descriptor;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    VirtualMachine virtualMachine = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == virtualMachineDescriptor) &#123; <span class="comment">// 使用 attach(String pid) 这种方式</span></span><br><span class="line">            virtualMachine = VirtualMachine.attach(<span class="string">&quot;&quot;</span> + configure.getJavaPid());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            virtualMachine = VirtualMachine.attach(virtualMachineDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Properties targetSystemProperties = virtualMachine.getSystemProperties();</span><br><span class="line">        String targetJavaVersion = JavaVersionUtils.javaVersionStr(targetSystemProperties);</span><br><span class="line">        String currentJavaVersion = JavaVersionUtils.javaVersionStr();</span><br><span class="line">        <span class="keyword">if</span> (targetJavaVersion != <span class="keyword">null</span> &amp;&amp; currentJavaVersion != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!targetJavaVersion.equals(currentJavaVersion)) &#123;</span><br><span class="line">                AnsiLog.warn(<span class="string">&quot;Current VM java version: &#123;&#125; do not match target VM java version: &#123;&#125;, attach may fail.&quot;</span>,</span><br><span class="line">                             currentJavaVersion, targetJavaVersion);</span><br><span class="line">                AnsiLog.warn(<span class="string">&quot;Target VM JAVA_HOME is &#123;&#125;, arthas-boot JAVA_HOME is &#123;&#125;, try to set the same JAVA_HOME.&quot;</span>,</span><br><span class="line">                             targetSystemProperties.getProperty(<span class="string">&quot;java.home&quot;</span>), System.getProperty(<span class="string">&quot;java.home&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String arthasAgentPath = configure.getArthasAgent();</span><br><span class="line">        <span class="comment">//convert jar path to unicode string</span></span><br><span class="line">        configure.setArthasAgent(encodeArg(arthasAgentPath));</span><br><span class="line">        configure.setArthasCore(encodeArg(configure.getArthasCore()));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            virtualMachine.loadAgent(arthasAgentPath,</span><br><span class="line">                                     configure.getArthasCore() + <span class="string">&quot;;&quot;</span> + configure.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getMessage() != <span class="keyword">null</span> &amp;&amp; e.getMessage().contains(<span class="string">&quot;Non-numeric value found&quot;</span>)) &#123;</span><br><span class="line">                AnsiLog.warn(e);</span><br><span class="line">                AnsiLog.warn(<span class="string">&quot;It seems to use the lower version of JDK to attach the higher version of JDK.&quot;</span>);</span><br><span class="line">                AnsiLog.warn(</span><br><span class="line">                    <span class="string">&quot;This error message can be ignored, the attach may have been successful, and it will still try to connect.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != virtualMachine) &#123;</span><br><span class="line">            virtualMachine.detach();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="AgentBootstrap-源码分析"><a href="#AgentBootstrap-源码分析" class="headerlink" title="AgentBootstrap 源码分析"></a>AgentBootstrap 源码分析</h2><blockquote>
<p>com.taobao.arthas.agent334.AgentBootstrap</p>
</blockquote>
<p>调用 VirtualMachine#loadAgent 加载 agent 后，AgentBootstrap 作为 agent 启动点，然后启动该类的 agentMain 方法，该方法直接调用了 main(String args, final Instrumentation inst) 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">    main(args, inst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法首先加载 java.arthas.SpyAPI 类，SpyAPI 起到了方法拦截通知作用。之后通过 getClassLoader 方法来创建 ArthasClassloader 实例，然后创建一个新的线程，该线程调用了 bind 方法对 Arthas 进行绑定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ClassLoader agentLoader = getClassLoader(inst, arthasCoreJarFile);</span><br><span class="line"></span><br><span class="line">Thread bindingThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bind(inst, agentLoader, agentArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace(ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>bind 方法实现很简单，首先加载 ArthasBootstrap 类，通过反射获取该类 getInstance 方法，之后进行调用。ArthasBootstrap#getInstance 方法会创建 ArthasBootstrap 实例，然后将其返回。</p>
<blockquote>
<p>ArthasBootstrap  与当前的 ArthasBootstrap 是不同的，这里加载的 ArthasBootstrap 是 com.taobao.arthas.core.server 包下的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.taobao.arthas.agent334.AgentBootstrap#bind</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Instrumentation inst, ClassLoader agentLoader, String args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">         * ArthasBootstrap bootstrap = ArthasBootstrap.getInstance(inst);</span></span><br><span class="line"><span class="comment">         * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    Class&lt;?&gt; bootstrapClass = agentLoader.loadClass(ARTHAS_BOOTSTRAP);</span><br><span class="line">    Object bootstrap = bootstrapClass.getMethod(GET_INSTANCE, Instrumentation.class, String.class).invoke(<span class="keyword">null</span>, inst, args);</span><br><span class="line">    <span class="keyword">boolean</span> isBind = (Boolean) bootstrapClass.getMethod(IS_BIND).invoke(bootstrap);</span><br><span class="line">    <span class="keyword">if</span> (!isBind) &#123;</span><br><span class="line">        String errorMsg = <span class="string">&quot;Arthas server port binding failed! Please check $HOME/logs/arthas/arthas.log for more details.&quot;</span>;</span><br><span class="line">        ps.println(errorMsg);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line">    ps.println(<span class="string">&quot;Arthas server already bind.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后看到 com.taobao.arthas.core.server.ArthasBootstrap 的构造方法，该方法主要做了如下的操作：</p>
<ol>
<li>初始化 spy</li>
<li>初始化 arthas 环境变量</li>
<li>初始化 Logger</li>
<li>增强 ClassLoader</li>
<li>初始化 bean</li>
<li>启动 arthas agent Server：启动 Server，接收客户端命令，来调用指定的方法将其结果返回给客户端</li>
</ol>
<p>最后创建了 TransformerManager 实例，用于管理 watchTransformers、traceTransformers、reTransformers 类型的 ClassFileTransformer，这些 ClassFileTransformer 会对 class 进行不同方面的增强，从而实现 Arthas  不同的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.taobao.arthas.core.server.ArthasBootstrap#ArthasBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ArthasBootstrap</span><span class="params">(Instrumentation instrumentation, Map&lt;String, String&gt; args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.instrumentation = instrumentation;</span><br><span class="line"></span><br><span class="line">    initFastjson();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. initSpy()</span></span><br><span class="line">    initSpy();</span><br><span class="line">    <span class="comment">// 2. ArthasEnvironment</span></span><br><span class="line">    initArthasEnvironment(args);</span><br><span class="line"></span><br><span class="line">    String outputPathStr = configure.getOutputPath();</span><br><span class="line">    <span class="keyword">if</span> (outputPathStr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        outputPathStr = ArthasConstants.ARTHAS_OUTPUT;</span><br><span class="line">    &#125;</span><br><span class="line">    outputPath = <span class="keyword">new</span> File(outputPathStr);</span><br><span class="line">    outputPath.mkdirs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. init logger</span></span><br><span class="line">    loggerContext = LogUtil.initLogger(arthasEnvironment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 增强ClassLoader</span></span><br><span class="line">    enhanceClassLoader();</span><br><span class="line">    <span class="comment">// 5. init beans</span></span><br><span class="line">    initBeans();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. start agent server</span></span><br><span class="line">    bind(configure);</span><br><span class="line"></span><br><span class="line">    executorService = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread(r, <span class="string">&quot;arthas-command-execute&quot;</span>);</span><br><span class="line">            t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    shutdown = <span class="keyword">new</span> Thread(<span class="string">&quot;as-shutdown-hooker&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ArthasBootstrap.<span class="keyword">this</span>.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    transformerManager = <span class="keyword">new</span> TransformerManager(instrumentation);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(shutdown);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Arthas 启动流程分析就到此为止了，本文并未进行深入的讲解，后续读者可以围绕着 agent Server 启动流程、TransformerManager、XXXCommand 类进行分析，从而深入理解 Arthas  实现原理。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://github.com/alibaba/arthas">Arthas  Github</a></li>
</ol>
]]></content>
      <categories>
        <category>Arthas </category>
      </categories>
      <tags>
        <tag>Arthas </tag>
        <tag>Java Agent</tag>
      </tags>
  </entry>
  <entry>
    <title>jclasslib 「Attach To Running JVM」 实现</title>
    <url>/2022/02/17/jclasslib-%E3%80%8CAttach-To-Running-JVM%E3%80%8D-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>jclasslib 是一款字节码编辑工具，可以对 class 字节码进行可视化操作。</p>
<p>jclasslib 提供 Attach To Running JVM 操作，用于查看与修改系统运行的 JVM 加载的类。该功能借助了 Agent 和 JMX，Agent 负责将对应的 MBean 注册到 JMX 中，通过 JMX 通讯协议调用其 MBean 操作。</p>
<a id="more"></a>

<p>本文不会讲述 jclasslib 基本操作，对于这部分知识，大家可以参考 <a href="https://github.com/ingokegel/jclasslib">jclasslib github</a></p>
<h2 id="JMX-是什么"><a href="#JMX-是什么" class="headerlink" title="JMX 是什么"></a>JMX 是什么</h2><blockquote>
<p><a href="https://en.wikipedia.org/wiki/Java_Management_Extensions">https://en.wikipedia.org/wiki/Java_Management_Extensions</a></p>
</blockquote>
<p>JMX 是 Java 平台提供管理与监控系统信息的工具，内部使用 MBean 进行消息传递，开发者可以向 MBeanServer 中注册自定义的 MBean。可以通过 jconsole 可视化工具或 JMX 通讯客户端，从指定的 JVM 中获取注册 MBean 信息或调用其暴露的方法。</p>
<h2 id="jclasslib-agent"><a href="#jclasslib-agent" class="headerlink" title="jclasslib agent"></a>jclasslib agent</h2><p>jclasslib 源代码的 modules 目录中，包含一个 agent 模块，只有该模块使用 Java 进行编写的，其它都是使用 Kotlin，目的是为了解决兼容性问题。jclasslib 进行打包时，agent 模块会打包成 jclasslib-agent.jar，后续操作都要依赖它。</p>
<p>点击 jclasslib “Attach To Running JVM” 按钮，会触发如下的操作，首先调用 attachToVm 将 agent 加载到对应的 JVM 中，applyVmConnection 设置 connection flag，browseClasspathAction 触发选择 class 界面。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.gjt.jclasslib.browser.BrowserFrame#getAttachVmAction</span></span><br><span class="line"><span class="keyword">val</span> attachVmAction = DefaultAction(getString(<span class="string">&quot;action.attach.to.jvm&quot;</span>), getString(<span class="string">&quot;action.attach.to.jvm.description&quot;</span>), <span class="string">&quot;attach.svg&quot;</span>) &#123;</span><br><span class="line">    attachToVm(<span class="keyword">this</span>)?.let &#123;</span><br><span class="line">        applyVmConnection(it)</span><br><span class="line">        browseClasspathAction()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看到 attachToVm 方法，在进行 Attach To Running JVM 操作时，会列出当前系统运行的 JVM，然后让你选择想要 attach 的 JVM，目的是为了获取该 JVM id，从而拿到 VirtualMachine 来进行 load agent 操作。</p>
<p>总结一下，该方法可以划分为两个操作，1) 加载 agent，2）与 JVM 的 JMX 建立链接。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules/browser/src/main/kotlin/browser/attach/Attach.kt:47</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">attachToVm</span><span class="params">(parentWindow: <span class="type">Window</span>?)</span></span>: VmConnection? =</span><br><span class="line">    selectVm(parentWindow)?.let &#123; attachableVm -&gt;</span><br><span class="line">        <span class="keyword">val</span> vm = <span class="keyword">try</span> &#123;</span><br><span class="line">            VirtualMachine.attach(attachableVm.descriptor.id()).also &#123; vm -&gt;</span><br><span class="line">                vm.loadAgent(getAgentPath())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            alertFacade.showMessage(parentWindow, getString(<span class="string">&quot;message.attach.failed.0&quot;</span>, e.message ?: <span class="string">&quot;&quot;</span>), <span class="literal">null</span>, AlertType.ERROR)</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@let</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> connectorAddress = <span class="keyword">try</span> &#123;</span><br><span class="line">            vm.getConnectorAddress() ?: vm.run &#123;</span><br><span class="line">                startLocalManagementAgent()</span><br><span class="line">                getConnectorAddress()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            alertFacade.showMessage(parentWindow, getString(<span class="string">&quot;message.management.agent.error.0&quot;</span>, e.message ?: <span class="string">&quot;&quot;</span>), <span class="literal">null</span>, AlertType.ERROR)</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@let</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> connection = <span class="keyword">try</span> &#123;</span><br><span class="line">            JMXConnectorFactory.connect(JMXServiceURL(connectorAddress))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            alertFacade.showMessage(parentWindow, getString(<span class="string">&quot;message.connection.failed.0&quot;</span>, e.message ?: <span class="string">&quot;&quot;</span>), <span class="literal">null</span>, AlertType.ERROR)</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@let</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> communicator = MBeanServerInvocationHandler.newProxyInstance(</span><br><span class="line">                connection.mBeanServerConnection,</span><br><span class="line">                ObjectName(AgentMain.MBEAN_NAME),</span><br><span class="line">                CommunicatorMBean::<span class="keyword">class</span>.java,</span><br><span class="line">                <span class="literal">false</span></span><br><span class="line">        )</span><br><span class="line">        VmConnection(communicator, connection, vm)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因要进行加载 agent 操作，我们将关注点放在 agent 模块中，看到 agent gradle 文件，从该 jar 配置信息可以得知，进行加载 agent 操作时，会调用 org.jclasslib.agent.AgentMain 的 agentMain 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    archiveFileName.set(&quot;jclasslib-agent.jar&quot;)</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes(</span><br><span class="line">                &quot;Agent-Class&quot; to &quot;org.jclasslib.agent.AgentMain&quot;,</span><br><span class="line">                &quot;Premain-Class&quot; to &quot;org.jclasslib.agent.AgentMain&quot;,</span><br><span class="line">                &quot;Can-Redefine-Classes&quot; to &quot;true&quot;,</span><br><span class="line">                &quot;Can-Retransform-Classes&quot; to &quot;true&quot;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    from(sourceSets[&quot;java9&quot;].output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>egentMain 方法会直接调用其内部的 init 方法，该方法目的向 MBeanServer 注册一个名为 org.jclasslib:name=agent 的 MBean，该 MBean 是整个操作的核心。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.jclasslib.agent.AgentMain#agentMain</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, Instrumentation instrumentation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    init(instrumentation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Instrumentation instrumentation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MBeanServer server = ManagementFactory.getPlatformMBeanServer();</span><br><span class="line">    ObjectName objectName = <span class="keyword">new</span> ObjectName(MBEAN_NAME);</span><br><span class="line">    <span class="keyword">if</span> (!server.isRegistered(objectName)) &#123;</span><br><span class="line">        server.registerMBean(<span class="keyword">new</span> Communicator(instrumentation), objectName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Communicator-实现"><a href="#Communicator-实现" class="headerlink" title="Communicator 实现"></a>Communicator 实现</h2><blockquote>
<p>MBean 是 Java 一个普通的类，但该类需要实现名为 XXXMBean 接口</p>
</blockquote>
<p>Communicator 是一个 MBean，它实现了 CommunicatorMBean 接口，其接口向外部暴露了三个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommunicatorMBean</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;ClassDescriptor&gt; <span class="title">getClasses</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">byte</span>[] getClassFile(String fileName);</span><br><span class="line">    <span class="function">ReplacementResult <span class="title">replaceClassFile</span><span class="params">(String fileName, <span class="keyword">byte</span>[] bytes)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Communicator 接收 Instrumentation 作为构造参数，上述接口暴露的方法实现都要依靠于该 Instrumentation  实例。</p>
<p>下面对比较常用的 getClassFile 方法进行讲解，首先将 fileName 中的 / 替换成 .，然后从 instrumentation 加载的类中进行查找，如果未发现，说明该 JVM 并未加载该类，则不需要后续操作。进行 map 操作时调用其 getClassFile(Class&lt;?&gt; c) 方法，在该方法中会创建 ReadClassFileTransformer 实例，将该实例添加到 instrumentation 中，并调用其 retransformClasses 方法，目的是为了重新加载该 class，从而在 ReadClassFileTransformer#transform 拿到该类的字节码。重新加载 class 后，需要将 ReadClassFileTransformer 从 instrumentation 移除，最后将字节码 byte array 返回即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.jclasslib.agent.Communicator#getClassFile(String)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getClassFile(String fileName) &#123;</span><br><span class="line">    String className = fileName.replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> findClass(className)</span><br><span class="line">        .map(<span class="keyword">this</span>::getClassFile)</span><br><span class="line">        .orElse(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Optional&lt;Class&gt; <span class="title">findClass</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(instrumentation.getAllLoadedClasses())</span><br><span class="line">        .filter(c -&gt; c.getName().equals(className))</span><br><span class="line">        .findFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] getClassFile(Class&lt;?&gt; c) &#123;</span><br><span class="line">    ReadClassFileTransformer transformer = <span class="keyword">new</span> ReadClassFileTransformer();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        instrumentation.addTransformer(transformer, <span class="keyword">true</span>);</span><br><span class="line">        instrumentation.retransformClasses(c);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        instrumentation.removeTransformer(transformer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transformer.bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadClassFileTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (classBeingRedefined != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.bytes = classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尾语"><a href="#尾语" class="headerlink" title="尾语"></a>尾语</h2><p>注册 Communicator MBean 后，整个实现也就完结了，后续只需通过 JMX 与该 MBean 进行通讯就可以实现后续的操作。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://en.wikipedia.org/wiki/Java_Management_Extensions">JMX wiki</a></li>
<li><a href="https://github.com/ingokegel/jclasslib">jclasslib</a></li>
</ol>
]]></content>
      <categories>
        <category>jclasslib</category>
      </categories>
      <tags>
        <tag>Java Agent</tag>
        <tag>design</tag>
        <tag>jclasslib</tag>
        <tag>JMX</tag>
      </tags>
  </entry>
  <entry>
    <title>ja-netfilter 设计与实现</title>
    <url>/2022/01/29/ja-netfilter-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>ja-netfilter 是一款 JavaAgent 框架，而 JavaAgent 是由 Java 提供一种动态代理机制，可以在 runtime 时修改 Class 字节码，从而实现代码注入操作。</p>
<p>ja-netfilter 对底层操作进行封装，提供插件系统（Plugin System）机制来向外部暴露简易的接口，使得注入操作更加的简单。</p>
<a id="more"></a>

<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>从 <a href="https://github.com/ja-netfilter/ja-netfilter/releases">releases page</a> 下载 ja-netfilter 最新的发布版本，解压该压缩包，其目录结构如下：</p>
<ol>
<li>plugins：插件 jar 目录</li>
<li>config：插件配置目录</li>
</ol>
<blockquote>
<p>配置名称需要与插件 jar 名称相同</p>
</blockquote>
<p><img src="https://gitee.com/killkey/images-upload/raw/master/typora/2022-01/Snipaste_2022-01-29_10-50-29.png" alt="Snipaste_2022-01-29_10-50-29"></p>
<p>插件需要引入 ja-netfilter 作为依赖，然后实现其 PluginEntry 与 MyTransformer 接口，前者用于描述插件信息，后者则对字节码进行转换操作，换句话说，在这过程中可以对字节码进行注入。</p>
<p> .java 文件编译成 class 字节码后，通过 java 命令来运行，而该命令提供了一个 -javaagent 参数，用于在 Runtime 时对字节码进行操作。启动 ja-netfilter 需要添加 -javaagent:/absolute/path/to/ja-netfilter.jar 在命令参数后，完整的命令应是这样 java -javaagent:/absolute/path/to/ja-netfilter.jar -jar executable_jar_file.jar。</p>
<p>命令执行后，ja-netfilter 会随着虚拟机启动后进行调用，从 plugins 目录加载插件，根据插件的行为进行注入操作。</p>
<h2 id="implement"><a href="#implement" class="headerlink" title="implement"></a>implement</h2><p>在 pom.xml 的 maven-assembly-plugin 配置中，会添加如下的配置来限定 javaagent 入口类，根据如下配置，当 javaagent 启动时，会调用其 Launcher 类的 agentmain 方法。</p>
<blockquote>
<p>JDK 文档指出，需在 manifest 文件指定 javaagent entry class，javaagent 会调用 entry class 的 agentmain 方法</p>
<p>see more details：<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/package-summary.html">https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/package-summary.html</a></p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Built-By</span>&gt;</span>neo<span class="tag">&lt;/<span class="name">Built-By</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>com.janetfilter.core.Launcher<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>com.janetfilter.core.Launcher<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Main-Class</span>&gt;</span>com.janetfilter.core.Launcher<span class="tag">&lt;/<span class="name">Main-Class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Set-Native-Method-Prefix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>看到 agentmain  方法，倘若开启了 debug mode，设置 debug 参数之后，随后就调用内部的 premain 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == System.getProperty(<span class="string">&quot;janf.debug&quot;</span>)) &#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;janf.debug&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    premain(args, inst, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>premain 方法中，主要逻辑如下所示：</p>
<ol>
<li>判断是否多次加载 </li>
<li>打印 usage</li>
<li>获取到该 jar，用于 BootStrap Class Loader 进行搜索</li>
<li>创建 Environment 实例，初始化配置环境</li>
<li>调用 Initializer 的 init 方法进行后续初始化</li>
</ol>
<p>1-5 都是一些前置操作，我们关注点应放在 init 方法上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation inst, <span class="keyword">boolean</span> attachMode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否加载多次</span></span><br><span class="line">    <span class="keyword">if</span> (loaded) &#123;</span><br><span class="line">        DebugInfo.warn(<span class="string">&quot;You have multiple `ja-netfilter` as javaagent.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 usage</span></span><br><span class="line">    printUsage();</span><br><span class="line"></span><br><span class="line">    URI jarURI;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        loaded = <span class="keyword">true</span>;</span><br><span class="line">        jarURI = WhereIsUtils.getJarURI();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        DebugInfo.error(<span class="string">&quot;Can not locate `ja-netfilter` jar file.&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取该 jar 所在的文件</span></span><br><span class="line">    File agentFile = <span class="keyword">new</span> File(jarURI.getPath());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inst.appendToBootstrapClassLoaderSearch(<span class="keyword">new</span> JarFile(agentFile));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        DebugInfo.error(<span class="string">&quot;Can not access `ja-netfilter` jar file.&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析程序参数并初始化</span></span><br><span class="line">    Initializer.init(inst, <span class="keyword">new</span> Environment(agentFile, args, attachMode)); <span class="comment">// for some custom UrlLoaders</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来到 init 方法，根据 environment 来创建 Dispatcher 实例，该 Dispatcher 设计运用了委托者模式，用于衔接 javaagent 与 ja-netfilter。随后创建 PluginManager 实例来加载 plugin 插件，并将 dispatcher 添加到 Instrumentation 中，因 dispatcher  实现了 ClassFileTransformer 接口，当进行 transformer 操作时候，会调用其 transform 方法。</p>
<p>之后根据 Dispatcher 的 getHookClassNames 来获取插件需要 HOOK 的类名，并遍历 Instrumentation 所有加载的类，如果类符合 HOOK 要求，那么调用其的 retransformClasses 方法进行 transformer 操作，最后来到 Dispatcher 的 transform 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.janetfilter.core.Initializer#init</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Instrumentation inst, Environment environment)</span> </span>&#123;</span><br><span class="line">    DebugInfo.useFile(environment.getLogsDir());</span><br><span class="line">    DebugInfo.info(environment.toString());</span><br><span class="line"></span><br><span class="line">    Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher(environment);</span><br><span class="line">    <span class="comment">// 加载 plugins 目录下的插件</span></span><br><span class="line">    <span class="keyword">new</span> PluginManager(inst, dispatcher, environment).loadPlugins();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 dispatcher 作为整个拦截的入口点</span></span><br><span class="line">    inst.addTransformer(dispatcher, <span class="keyword">true</span>);</span><br><span class="line">    inst.setNativeMethodPrefix(dispatcher, environment.getNativePrefix());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取需要被 hook 的 class name</span></span><br><span class="line">    Set&lt;String&gt; classSet = dispatcher.getHookClassNames();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; c : inst.getAllLoadedClasses()) &#123;</span><br><span class="line">        String name = c.getName();</span><br><span class="line">        <span class="comment">// 当前 class 不需要被 hook</span></span><br><span class="line">        <span class="keyword">if</span> (!classSet.contains(name)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 交由 Dispatcher 进行 hook 操作</span></span><br><span class="line">            <span class="comment">// 内部会调用其 transform 方法</span></span><br><span class="line">            inst.retransformClasses(c);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            DebugInfo.error(<span class="string">&quot;Retransform class failed: &quot;</span> + name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加载插件"><a href="#加载插件" class="headerlink" title="加载插件"></a>加载插件</h3><p>PluginManager 的 loadPlugins 方法目的是为了从 plugins 目录下加载插件，首先获取到插件目录，之后加载目录下所有文件进行一个过滤操作，为了扫描出其中所有的 jar 包文件。</p>
<p>因加载插件是一个耗时操作，所以采用了线程池设计，每个 plugin file 会被包装成 PluginLoadTask 提交给线程 池，执行时会调用其 run 方法。当所有 task 都提交到线程池，会进行 shutdown 操作，随后等待线程池 30s 终止，倘若执行超时，则判定加载插件超时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.janetfilter.core.plugin.PluginManager#loadPlugins</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadPlugins</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    File pluginsDirectory = environment.getPluginsDir();</span><br><span class="line">    <span class="comment">// plugins 目录不存在或 plugins 不是目录</span></span><br><span class="line">    <span class="keyword">if</span> (!pluginsDirectory.exists() || !pluginsDirectory.isDirectory()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描 plugins 所有 jar 包</span></span><br><span class="line">    File[] pluginFiles = pluginsDirectory.listFiles((d, n) -&gt; n.endsWith(<span class="string">&quot;.jar&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == pluginFiles) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 向线程池提交 task 来加载插件</span></span><br><span class="line">        <span class="keyword">for</span> (File pluginFile : pluginFiles) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> PluginLoadTask(pluginFile));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="keyword">if</span> (!executorService.awaitTermination(<span class="number">30L</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Load plugin timeout&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DebugInfo.debug(String.format(<span class="string">&quot;============ All plugins loaded, %.2fs elapsed ============&quot;</span>, (System.currentTimeMillis() - startTime) / <span class="number">1000D</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        DebugInfo.error(<span class="string">&quot;Load plugin failed&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所述，加载插件逻辑会放在 PluginLoadTask  的 run 方法中。首先获取该 plugin jar 的 manifest 信息，从而获取 jar 的 entry class name，后续由 PluginClassLoader 来将 class name 加载成 class，如果该 entry class 未实现 PluginEntry 接口，说明该 jar 不是 plugin，则不需要后续操作。</p>
<p>获取插件的配置文件后，解析并用 PluginConfig 进行表示，然后调用 PluginEntry#init 对插件进行初始化，最后将 Plugin 的 MyTransformer 实现添加到 Dispatcher 中，从而完成插件加载化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pluginFile.getName().endsWith(environment.getDisabledPluginSuffix())) &#123;</span><br><span class="line">            DebugInfo.debug(<span class="string">&quot;Disabled plugin: &quot;</span> + pluginFile + <span class="string">&quot;, ignored.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JarFile jarFile = <span class="keyword">new</span> JarFile(pluginFile);</span><br><span class="line">        Manifest manifest = jarFile.getManifest();</span><br><span class="line">        <span class="comment">// 从 jar 的 manifest 配置文件中获取 entry 类</span></span><br><span class="line">        String entryClass = manifest.getMainAttributes().getValue(ENTRY_NAME);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(entryClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PluginClassLoader classLoader = <span class="keyword">new</span> PluginClassLoader(jarFile);</span><br><span class="line">        Class&lt;?&gt; klass = Class.forName(entryClass, <span class="keyword">false</span>, classLoader);</span><br><span class="line">        <span class="comment">// entry class 未实现 PluginEntry 接口，说明这不是个 Plugin，那么直接 return</span></span><br><span class="line">        <span class="keyword">if</span> (!Arrays.asList(klass.getInterfaces()).contains(PluginEntry.class)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (inst) &#123;</span><br><span class="line">            inst.appendToBootstrapClassLoaderSearch(jarFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PluginEntry pluginEntry = (PluginEntry) Class.forName(entryClass).newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取对应插件的配置文件</span></span><br><span class="line">        File configFile = <span class="keyword">new</span> File(environment.getConfigDir(), pluginEntry.getName().toLowerCase() + <span class="string">&quot;.conf&quot;</span>);</span><br><span class="line">        <span class="comment">// 加载与解析配置</span></span><br><span class="line">        PluginConfig pluginConfig = <span class="keyword">new</span> PluginConfig(configFile, ConfigParser.parse(configFile));</span><br><span class="line">        <span class="comment">// 对插件初始化</span></span><br><span class="line">        pluginEntry.init(environment, pluginConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将插件添加到 Dispatcher 中</span></span><br><span class="line">        dispatcher.addTransformers(pluginEntry.getTransformers());</span><br><span class="line"></span><br><span class="line">        DebugInfo.debug(<span class="string">&quot;Plugin loaded: &#123;name=&quot;</span> + pluginEntry.getName() + <span class="string">&quot;, version=&quot;</span> + pluginEntry.getVersion() + <span class="string">&quot;, author=&quot;</span> + pluginEntry.getAuthor() + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        DebugInfo.error(<span class="string">&quot;Parse plugin info failed&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="执行插件"><a href="#执行插件" class="headerlink" title="执行插件"></a>执行插件</h3><p>调用 Instrumentation#retransformClasses  后，会来到 Dispatcher#transform 方法，该方法会通过 classname 获取到该 class 所有的 MyTransformer，并循环遍历调用每个生命周期方法，最终得到 class 字节流进行返回即可。</p>
<blockquote>
<p>要对 class 进行修改，需要借助 ASM，该库可以修改 class，并动态生成新的 class。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.janetfilter.core.Dispatcher#transform</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classFileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == className) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取该 class 所有的 MyTransformer</span></span><br><span class="line">        List&lt;MyTransformer&gt; transformers = transformerMap.get(className);</span><br><span class="line">        <span class="comment">// 未获取到，说明该 class 并不需要被 transformer</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == transformers) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> order = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行生命周期调用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (MyTransformer transformer : globalTransformers) &#123;</span><br><span class="line">                transformer.before(className, classFileBuffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (MyTransformer transformer : globalTransformers) &#123;</span><br><span class="line">                classFileBuffer = transformer.preTransform(className, classFileBuffer, order++);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (MyTransformer transformer : transformers) &#123;</span><br><span class="line">                classFileBuffer = transformer.transform(className, classFileBuffer, order++);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (MyTransformer transformer : globalTransformers) &#123;</span><br><span class="line">                classFileBuffer = transformer.postTransform(className, classFileBuffer, order++);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (MyTransformer transformer : globalTransformers) &#123;</span><br><span class="line">                transformer.after(className, classFileBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            DebugInfo.error(<span class="string">&quot;Transform class failed: &quot;</span> + className, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> classFileBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://github.com/ja-netfilter/ja-netfilter">ja-netfilter</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/package-summary.html">jdk doc</a></li>
<li><a href="https://asm.ow2.io/">asm</a></li>
</ul>
]]></content>
      <categories>
        <category>ja-netfilter</category>
      </categories>
      <tags>
        <tag>ja-netfilter</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang WAL 设计与实现</title>
    <url>/2022/01/26/Golang-WAL-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>Write Ahead Log（预写日志） 简称 WAL，用于记录程序内部操作，在程序奔溃恢复后，可以根据 WAL 来恢复程序原先的状态。</p>
<p>WAL 与日志框架设计有异曲同工之处，两者目标都是为了持久化数据，只不过两者用处不同罢了。本文会对 Golang 的 <a href="https://github.com/tidwall/wal">WAL</a> 库进行分析，从而来学习 WAL 如何设计与优化。</p>
<a id="more"></a>



<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>对于 WAL 库，最基本的功能就是向外部提供读写的接口，用户读取时根据 log offset 读取，写入时则追加到WAL 文件的尾部。WAL 与日志框架一样，最终都将数据持久到文件系统中，所以需要对文件分段（segment）设计，分段之后可以有利于并发读写。对于文件的写入操作，批处理机制可以将多个操作合并成一个操作，从而将多次系统调用减少成一次，这样可以极大的提高性能。谈及数据持久化时，则需要对 entry 进行序列化与反序列化操作。</p>
<p>不断的向 WAL 写入日志，会使得 WAL 大小不断的增大，分段设计虽然能解决单个的文件很大的问题，但无法释放原先存储空间。此时需要对 WAL 进行 GC（垃圾收集） 操作，回收不在使用的 WAL，从而减少存储空间。</p>
<p>综合以上场景，一个 WAL 库应该具备如下的功能：</p>
<ol>
<li>基本的读写接口</li>
<li>日志文件分段</li>
<li>批处理</li>
<li>序列化与反序列化</li>
<li>垃圾回收</li>
</ol>
<h2 id="Struct-设计"><a href="#Struct-设计" class="headerlink" title="Struct 设计"></a>Struct 设计</h2><p>对于库来说，拥有一个优秀的 struct 设计，使得后续的实现更加的事半功倍，同时可以让模块之间职责清晰，分工明确。</p>
<p>在 Golang WAL 中，我们重点关注 Log、segment、batch、Options 这些 struct。Options 可以影响 Log 内部行为，比如 Segment 大小、序列化方式、写同步。Log 由多个 segment 组成，同时会持有整个 WAL 第一条与最后一条日志的 index，写入数据时，直接追加到 sfile（WAL 中尾部 segment）文件尾部，Log 中的 LRU 的 cache，用于日志的读取。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Log <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu         sync.RWMutex</span><br><span class="line">	path       <span class="keyword">string</span>      <span class="comment">// absolute path to log directory</span></span><br><span class="line">	opts       Options     <span class="comment">// log options</span></span><br><span class="line">	closed     <span class="keyword">bool</span>        <span class="comment">// log is closed</span></span><br><span class="line">	corrupt    <span class="keyword">bool</span>        <span class="comment">// log may be corrupt</span></span><br><span class="line">	segments   []*segment  <span class="comment">// all known log segments</span></span><br><span class="line">	firstIndex <span class="keyword">uint64</span>      <span class="comment">// index of the first entry in log</span></span><br><span class="line">	lastIndex  <span class="keyword">uint64</span>      <span class="comment">// index of the last entry in log</span></span><br><span class="line">	sfile      *os.File    <span class="comment">// tail segment file handle</span></span><br><span class="line">	wbatch     Batch       <span class="comment">// reusable write batch</span></span><br><span class="line">	scache     tinylru.LRU <span class="comment">// segment entries cache</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> segment <span class="keyword">struct</span> &#123;</span><br><span class="line">	path  <span class="keyword">string</span> <span class="comment">// path of segment file</span></span><br><span class="line">	index <span class="keyword">uint64</span> <span class="comment">// first index of segment</span></span><br><span class="line">	ebuf  []<span class="keyword">byte</span> <span class="comment">// cached entries buffer</span></span><br><span class="line">	epos  []bpos <span class="comment">// cached entries positions in buffer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// NoSync disables fsync after writes. This is less durable and puts the</span></span><br><span class="line">	<span class="comment">// log at risk of data loss when there&#x27;s a server crash.</span></span><br><span class="line">	NoSync <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// SegmentSize of each segment. This is just a target value, actual size</span></span><br><span class="line">	<span class="comment">// may differ. Default is 20 MB.</span></span><br><span class="line">	SegmentSize <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// LogFormat is the format of the log files. Default is Binary.</span></span><br><span class="line">	LogFormat LogFormat</span><br><span class="line">	<span class="comment">// SegmentCacheSize is the maximum number of segments that will be held in</span></span><br><span class="line">	<span class="comment">// memory for caching. Increasing this value may enhance performance for</span></span><br><span class="line">	<span class="comment">// concurrent read operations. Default is 1</span></span><br><span class="line">	SegmentCacheSize <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// NoCopy allows for the Read() operation to return the raw underlying data</span></span><br><span class="line">	<span class="comment">// slice. This is an optimization to help minimize allocations. When this</span></span><br><span class="line">	<span class="comment">// option is set, do not modify the returned data because it may affect</span></span><br><span class="line">	<span class="comment">// other Read calls. Default false</span></span><br><span class="line">	NoCopy <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Perms represents the datafiles modes and permission bits</span></span><br><span class="line">	DirPerms  os.FileMode</span><br><span class="line">	FilePerms os.FileMode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><h3 id="Open"><a href="#Open" class="headerlink" title="Open"></a>Open</h3><p>Open 方法接收 string 与 Options 参数，返回 Log struct，首先对传入的 Options 进行校验，如果不符合要求，那么设置默认的参数。</p>
<p>倘若传入的 path 目录不存在，说明当前 WAL 并无数据，那么则需要创建对应的 path 目录。最后调用 load 方法来加载 path 目录下所有的 segment，并更新 Log 属性。</p>
<p>load 方法会获取 path 所有的文件，文件名由 20、24、26 个字符组成，该文件名前 20 个字符对应的 segment 开始的 index。首先将文件名前 20 个字符并解析为 uint64，然后根据 segment index 与 filename（path+name）创建 segment 追加到 Log 的 segments 中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wal.go load</span></span><br><span class="line"><span class="keyword">for</span> _, fi := <span class="keyword">range</span> fis &#123;</span><br><span class="line">    name := fi.Name()</span><br><span class="line">    <span class="keyword">if</span> fi.IsDir() || <span class="built_in">len</span>(name) &lt; <span class="number">20</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    index, err := strconv.ParseUint(name[:<span class="number">20</span>], <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || index == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    isStart := <span class="built_in">len</span>(name) == <span class="number">26</span> &amp;&amp; strings.HasSuffix(name, <span class="string">&quot;.START&quot;</span>)</span><br><span class="line">    isEnd := <span class="built_in">len</span>(name) == <span class="number">24</span> &amp;&amp; strings.HasSuffix(name, <span class="string">&quot;.END&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">20</span> || isStart || isEnd &#123;</span><br><span class="line">        <span class="keyword">if</span> isStart &#123;</span><br><span class="line">            startIdx = <span class="built_in">len</span>(l.segments)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> isEnd &amp;&amp; endIdx == <span class="number">-1</span> &#123;</span><br><span class="line">            endIdx = <span class="built_in">len</span>(l.segments)</span><br><span class="line">        &#125;</span><br><span class="line">        l.segments = <span class="built_in">append</span>(l.segments, &amp;segment&#123;</span><br><span class="line">            index: index,</span><br><span class="line">            path:  filepath.Join(l.path, name),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 path 目录下包含了 .START 与 .END 结尾的文件，那么进行清除的工作，这操作实现原理在此不进行讲解。之后会打开 WAL 最后一个 segment，并且将该文件的 position 偏移到 2。然后对 Log 中的 firstIndex 与 lastIndex 进行更新操作，前者为 segments 第一个元素的 index，后者为 segments 最后一个元素的 index 加上 epos 值减去 1，从而推导出最后一个 entry 的 index。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">l.firstIndex = l.segments[<span class="number">0</span>].index</span><br><span class="line"><span class="comment">// Open the last segment for appending</span></span><br><span class="line">lseg := l.segments[<span class="built_in">len</span>(l.segments)<span class="number">-1</span>]</span><br><span class="line">l.sfile, err = os.OpenFile(lseg.path, os.O_WRONLY, l.opts.FilePerms)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err := l.sfile.Seek(<span class="number">0</span>, <span class="number">2</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Load the last segment entries</span></span><br><span class="line"><span class="keyword">if</span> err := l.loadSegmentEntries(lseg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">l.lastIndex = lseg.index + <span class="keyword">uint64</span>(<span class="built_in">len</span>(lseg.epos)) - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>到此为止，整个 open 操作都已经完成了，后续对读写操作进行讲解。</p>
<h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><p>Write 方法接收 uint64 与 []byte 参数，前者为entry 的index，后者为 entry 的数据。首先需要对 WAL 进行加锁操作，然后判断当前 WAL 状态，决定是否继续之后的操作。状态校验通过之后，则清除 wbatch 中的数据，调用其 write 写入数据到 batch 中，最后调用 Log 的 writeBatch 方法将 batch 中数据写入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Log)</span> <span class="title">Write</span><span class="params">(index <span class="keyword">uint64</span>, data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	l.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> l.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> l.corrupt &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrCorrupt</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> l.closed &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrClosed</span><br><span class="line">	&#125;</span><br><span class="line">	l.wbatch.Clear()</span><br><span class="line">	l.wbatch.Write(index, data)</span><br><span class="line">	<span class="keyword">return</span> l.writeBatch(&amp;l.wbatch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> writeBatch 实现并不复杂，先对 tail segment 中的 ebuf 进行校验，如果 ebuf 大小超过了 segmentSize，那么需要创建一个新的 segment。</p>
<p>然后遍历 batch 中的 entries，并调用 appendEntry 方法追加数据到 tail segment 中的 ebuf 中，appendEntry 会涉及一个序列化操作，采用了 Json 内部调用appendJSONEntry，binary 则调用 appendBinaryEntry。在遍历过程中，每向 ebuf 追加一次数据，那么就会对 ebuf 大小进行校验，判断是否超过了 segmentSize。如果超过将 ebuf 数据写入到 Log sfile ，并更新  lastIndex 与 tail segment。</p>
<p>遍历完 entries 后，则将 ebuf 中 mark 后面的数据写入到 sfile ，并更新 lastIndex。如果开启了 sync，写入之后需要调用 File 的 sync 方法将缓冲区数据刷新到 disk，最后将 batch 数据清空。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Log)</span> <span class="title">writeBatch</span><span class="params">(b *Batch)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// check that all indexes in batch are sane</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b.entries); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> b.entries[i].index != l.lastIndex+<span class="keyword">uint64</span>(i+<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> ErrOutOfOrder</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// load the tail segment</span></span><br><span class="line">	s := l.segments[<span class="built_in">len</span>(l.segments)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.ebuf) &gt; l.opts.SegmentSize &#123;</span><br><span class="line">		<span class="comment">// tail segment has reached capacity. Close it and create a new one.</span></span><br><span class="line">		<span class="keyword">if</span> err := l.cycle(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		s = l.segments[<span class="built_in">len</span>(l.segments)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mark := <span class="built_in">len</span>(s.ebuf)</span><br><span class="line">	datas := b.datas</span><br><span class="line">    <span class="comment">// 遍历 entries，并将数据 append 到 ebuf 中</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b.entries); i++ &#123;</span><br><span class="line">		data := datas[:b.entries[i].size]</span><br><span class="line">		<span class="keyword">var</span> epos bpos</span><br><span class="line">		s.ebuf, epos = l.appendEntry(s.ebuf, b.entries[i].index, data)</span><br><span class="line">		s.epos = <span class="built_in">append</span>(s.epos, epos)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(s.ebuf) &gt;= l.opts.SegmentSize &#123;</span><br><span class="line">			<span class="comment">// segment has reached capacity, cycle now</span></span><br><span class="line">			<span class="keyword">if</span> _, err := l.sfile.Write(s.ebuf[mark:]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			l.lastIndex = b.entries[i].index</span><br><span class="line">			<span class="keyword">if</span> err := l.cycle(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			s = l.segments[<span class="built_in">len</span>(l.segments)<span class="number">-1</span>]</span><br><span class="line">			mark = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		datas = datas[b.entries[i].size:]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.ebuf)-mark &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">		<span class="keyword">if</span> _, err := l.sfile.Write(s.ebuf[mark:]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		l.lastIndex = b.entries[<span class="built_in">len</span>(b.entries)<span class="number">-1</span>].index</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 判断是否开启 sync</span></span><br><span class="line">	<span class="keyword">if</span> !l.opts.NoSync &#123;</span><br><span class="line">		<span class="keyword">if</span> err := l.sfile.Sync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	b.Clear()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><p>Read 方法根据 log index 从 WAL 读取对应的数据，该方法内部实现会先获取一把写锁，之后与 Write 方法类似，都会检查 WAL 状态。</p>
<p>如果 index 等于 0、index 小于 firstIndex、index 大于 lastIndex，这三个条件满足一者，那么该方法会直接 return，并返回 ErrNotFound 错误。</p>
<p>调用 loadSegment 方法，首先从 Log LRU 中找到对应的 segment。倘若未找到，那么调用 findSegment 方法根据 index 从 segments 中进行二分查找，找到后则从 disk 读取 segment 数据，数据会被读取到 segment 中的 ebuf 中，并维护 segment 中的 epos 索引，最后将 segment 添加到 Log LRU 中。</p>
<p>获取到 index 对应的 segment 后，根据 index 从 segment 的 epos 索引获取到该 entry 在 ebuf 中的 start position 与 end position，从 ebuf 拿到 log entry 数据后，如果采用 Json 序列化方式，那么使用 readJson 进行读取，binary 则不进行额外操作。</p>
<p>要是 WAL 开启了 NoCopy，return 的 data 则是 ebuf 的分片，这种设计虽然减少内存开辟和释放，但用户对该 ebuf 分片的数据进行修改，则会影响后续读取到的数据准确性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Log)</span> <span class="title">Read</span><span class="params">(index <span class="keyword">uint64</span>)</span> <span class="params">(data []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">   l.mu.RLock()</span><br><span class="line">   <span class="keyword">defer</span> l.mu.RUnlock()</span><br><span class="line">   <span class="keyword">if</span> l.corrupt &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ErrCorrupt</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> l.closed &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ErrClosed</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> index == <span class="number">0</span> || index &lt; l.firstIndex || index &gt; l.lastIndex &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ErrNotFound</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 根据 index 加载 segment</span></span><br><span class="line">   s, err := l.loadSegment(index)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 根据 index 从 epos 获取该 entry 的 start 与 end</span></span><br><span class="line">   epos := s.epos[index-s.index]</span><br><span class="line">   edata := s.ebuf[epos.pos:epos.end]</span><br><span class="line">   <span class="comment">// json 序列化</span></span><br><span class="line">   <span class="keyword">if</span> l.opts.LogFormat == JSON &#123;</span><br><span class="line">      <span class="keyword">return</span> readJSON(edata)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// binary read</span></span><br><span class="line">   size, n := binary.Uvarint(edata)</span><br><span class="line">   <span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ErrCorrupt</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">uint64</span>(<span class="built_in">len</span>(edata)-n) &lt; size &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ErrCorrupt</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> l.opts.NoCopy &#123;</span><br><span class="line">      data = edata[n : <span class="keyword">uint64</span>(n)+size]</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      data = <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">      <span class="built_in">copy</span>(data, edata[n:])</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="GC-操作"><a href="#GC-操作" class="headerlink" title="GC 操作"></a>GC 操作</h3><p>对 WAL 进行 GC 操作，只需要删除指定 index 之前的 log，并生成新的 segment，在 Golang WAL 中提供了两个截断操作。</p>
<ol>
<li>TruncateFront：删除 index 之前的 log，使得 index 处的 log 成为第一个 log</li>
<li>TruncateBack：删除 index 之后的 log，使得 index 处的 log 成为最后一个 log</li>
</ol>
<p>下面对 TruncateFront 实现逻辑进行分析，因为 TruncateBack 不太常用，在 WAL 中一般都是删除指定 index 之前的 log，从而来达到释放存储空间目的。</p>
<p>在 TruncateFront  中，首先获取获取锁，对 WAL 状态校验后，则调用内部的 truncateFront 方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Log)</span> <span class="title">TruncateFront</span><span class="params">(index <span class="keyword">uint64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	l.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> l.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> l.corrupt &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrCorrupt</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> l.closed &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrClosed</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l.truncateFront(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>截断 index 之前的 log，首先需要获取到 index 对应的 segment后，创建一个 temp 文件来存储该 segment index 之后的 log，将该 temp 文件重命名为 .START 结尾文件，然后删除从 disk 删除所有被截断的 segment，如果删除期间发生错误，后续 open 操作时，可以根据 .START 标志找到 WAL 开始点，从而来舍弃之前的 segment。反之，删除成功后，则将 .START 重名为 20 个字符的 index 名。</p>
<p>之前是对 disk 进行更新，现在则对内存记录进行更新，该操作从 segments 删除 index 之前所有的 segment。最后在进行一些收尾工作，首先清除 Log 的 LRU Cache，然后更新 Log 中的 firstIndex 为传入的 index。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Log)</span> <span class="title">truncateFront</span><span class="params">(index <span class="keyword">uint64</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> index == <span class="number">0</span> || l.lastIndex == <span class="number">0</span> ||</span><br><span class="line">		index &lt; l.firstIndex || index &gt; l.lastIndex &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrOutOfRange</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> index == l.firstIndex &#123;</span><br><span class="line">		<span class="comment">// nothing to truncate</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	segIdx := l.findSegment(index)</span><br><span class="line">	<span class="keyword">var</span> s *segment</span><br><span class="line">	s, err = l.loadSegment(index)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	epos := s.epos[index-s.index:]</span><br><span class="line">	ebuf := s.ebuf[epos[<span class="number">0</span>].pos:]</span><br><span class="line">	<span class="comment">// Create a temp file contains the truncated segment.</span></span><br><span class="line">	tempName := filepath.Join(l.path, <span class="string">&quot;TEMP&quot;</span>)</span><br><span class="line">	err = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		f, err := os.OpenFile(tempName, os.O_CREATE|os.O_RDWR|os.O_TRUNC, l.opts.FilePerms)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> f.Close()</span><br><span class="line">		<span class="keyword">if</span> _, err := f.Write(ebuf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := f.Sync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// Rename the TEMP file to it&#x27;s START file name.</span></span><br><span class="line">	startName := filepath.Join(l.path, segmentName(index)+<span class="string">&quot;.START&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err = os.Rename(tempName, startName); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// The log was truncated but still needs some file cleanup. Any errors</span></span><br><span class="line">	<span class="comment">// following this message will not cause an on-disk data ocorruption, but</span></span><br><span class="line">	<span class="comment">// may cause an inconsistency with the current program, so we&#x27;ll return</span></span><br><span class="line">	<span class="comment">// ErrCorrupt so the the user can attempt a recover by calling Close()</span></span><br><span class="line">	<span class="comment">// followed by Open().</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> v := <span class="built_in">recover</span>(); v != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = ErrCorrupt</span><br><span class="line">			l.corrupt = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">if</span> segIdx == <span class="built_in">len</span>(l.segments)<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">// Close the tail segment file</span></span><br><span class="line">		<span class="keyword">if</span> err = l.sfile.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Delete truncated segment files</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= segIdx; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> err = os.Remove(l.segments[i].path); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Rename the START file to the final truncated segment name.</span></span><br><span class="line">	newName := filepath.Join(l.path, segmentName(index))</span><br><span class="line">	<span class="keyword">if</span> err = os.Rename(startName, newName); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	s.path = newName</span><br><span class="line">	s.index = index</span><br><span class="line">	<span class="keyword">if</span> segIdx == <span class="built_in">len</span>(l.segments)<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">// Reopen the tail segment file</span></span><br><span class="line">		<span class="keyword">if</span> l.sfile, err = os.OpenFile(newName, os.O_WRONLY, l.opts.FilePerms); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> n <span class="keyword">int64</span></span><br><span class="line">		<span class="keyword">if</span> n, err = l.sfile.Seek(<span class="number">0</span>, <span class="number">2</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n != <span class="keyword">int64</span>(<span class="built_in">len</span>(ebuf)) &#123;</span><br><span class="line">			err = errors.New(<span class="string">&quot;invalid seek&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Load the last segment entries</span></span><br><span class="line">		<span class="keyword">if</span> err = l.loadSegmentEntries(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	l.segments = <span class="built_in">append</span>([]*segment&#123;&#125;, l.segments[segIdx:]...)</span><br><span class="line">	l.firstIndex = index</span><br><span class="line">	l.clearCache()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于垃圾回收实现可谓是百家争鸣，但作为通用的 WAL 库，golang-wal 垃圾回收是一个很好的设计。在 leveldb 中，该项目内部实现了自己的 WAL，每个 MemTable 对应了一个 WAL 文件，后续将 memtable 转成 immuttable，最后落盘成 SSTable，才将原先的 WAL 删除，从而实现垃圾回收。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://github.com/tidwall/wal">Golang WAL</a></li>
<li><a href="https://github.com/syndtr/goleveldb">goleveldb</a></li>
</ol>
]]></content>
      <categories>
        <category>WAL</category>
      </categories>
      <tags>
        <tag>WAL</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现日志框架</title>
    <url>/2022/01/25/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>日志框架作为大型系统最基础的组件之一，用于快速定位和分析程序的问题。当项目采用多线程编程时，调试变的异常困难，在合适的地方打上日志，可以提高解决问题的效率。在分布式系统中，进行分布式追踪也要依靠日志框架。</p>
<a id="more"></a>

<p>先来谈一下日志框架设计几要素，既然日志是用于定位与分析问题的，所以记录信息需要很详细，一条日志应由 当前时间、日志等级、线程名称、类、方法名、行号和 Message 部分构成。日志框架采用同步还是异步写，存储方式、过滤器等等要素都需要考虑，接下来来介绍几个重要点。</p>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>倘若将日志写入到数据库中，采用同步写的方式，发生阻塞的操作时会将线程给阻塞住，从而影响业务。对于日志框架，一般是采用异步的模式，异步提供了四种模式。</p>
<ol>
<li>SPSC：单生产单消费</li>
<li>SPMC：单生产多消费</li>
<li>MPSC：多生产单消费</li>
<li>MPMC：多生产多消费</li>
</ol>
<p>日志框架该采用那种异步模式呢？多个线程同时记录日志这是多生产的方式，如果采用多消费的话，那么需要维护多个线程开销和同步问题，而且系统日志记录的并不是很频繁，无需增加额外的复杂度，综合以上场景使用 MPSC 模式最优。</p>
<p>使用单消费者模式，需要使用一个容器来存储日志，当进行日志记录时，其它线程只需要先将日志存储到消费者容器即可，后续由消费者慢慢消费。从容器存储与获取日志都需要进行加锁操作，而容器最好不使用阻塞队列，如果某条日志写入的时候过长，在此期间导致阻塞队列满了，那么就会阻塞其他线程，从而影响业务正常运行。</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器用于对日志进行过滤操作，从而筛选出不满足条件的记录。比如不需要记录 main 线程的日志，那么需要对线程名进行一个过滤操作，来筛选出不是 main 的线程日志。</p>
<p>针对过滤器的设计，下面列举几个常见的过滤器</p>
<ol>
<li>日志等级过滤器</li>
<li>线程名过滤器</li>
<li>Message 过滤器</li>
<li>时间过滤器</li>
</ol>
<h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p>日志框架不仅仅只将日志打印在控制台，日志可以很好反应程序的运行状态，所以需要将日志进行持久化，用于后续的分析与优化，对于存储方式就有多种多样了，如下所示。</p>
<ol>
<li>FileSystem</li>
<li>Database</li>
<li>Http</li>
<li>Kafka</li>
<li>Console</li>
<li>SMTP</li>
<li>Json</li>
</ol>
<p>下面对 FileSystem 存储方式进行分析，这种方式是将日志写入到文件中，这必然会涉及序列化与反序列化。我们知道当一个文件很大的时候，对操作系统也不友好，并且也不利于日志文件读取。所以需要对日志文件进行分段的设计，可以按照时间点、文件大小、日志 level 来进行分段，从而减少日志文件的大小。</p>
<p>涉及文件操作，那么必然逃不过缓冲区的设计，将 data 写入到文件中，会产生系统调用，如果每次记录日志都进行系统调用，这会极大的降低日志框架的性能。那么在应用层采用缓冲区是一个明智的选择，首先日志序列化之后放入到缓冲区中，当缓冲区满了或定时将缓冲区内容写入到文件中。倘若当前机器宕机了，那么存储在缓冲区的日志数据就会丢失，所以缓冲区的大小需要采用适当的大小，倘若采用 Java 进行实现，可以使用 Buffer 的输出流。</p>
<p>日志框架将 data 写入到文件，操作系统首先将 data 写入到文件系统的缓冲区，之后由文件系统定时或缓冲区满了将缓冲区 flush 到 disk 。如果发生宕机，那么也会发生数据丢失，日志框架丢失数据是不可容忍的，倘若丢的数据就是分析问题所需关键日志，那么日志框架的意义何在。针对这种问题，可以定时手动调用 flush 系统调用来将缓冲区强制刷新到 disk。</p>
<p>日志框架接收外部化信号或者因为异常而退出，那么需要将缓冲区数据进行刷新，并且将一些分配的资源进行关闭，面对这种情况，需要借助 Shutdown Hook 来实现。</p>
<p>以上设计只能尽量的避免数据丢失，并不能完全避免数据丢失情况，对于系统的设计需要在性能和可靠性进行折中的设计，寻求一个最优解。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/tinylog-org/tinylog">tinylog</a></li>
<li><a href="https://github.com/apache/logging-log4j2">logging-log4j2</a></li>
</ol>
]]></content>
      <categories>
        <category>Logger</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>Logger</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 golang 实现解析 cURL</title>
    <url>/2021/11/06/%E4%BD%BF%E7%94%A8-golang-%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90-cURL/</url>
    <content><![CDATA[<blockquote>
<p>本文对应源码：<a href="https://github.com/killlowkey/parse-curl">https://github.com/killlowkey/parse-curl</a></p>
</blockquote>
<h1 id="cURL-是什么"><a href="#cURL-是什么" class="headerlink" title="cURL 是什么"></a>cURL 是什么</h1><p>维基百科：“cURL是一个命令行工具，用于使用URL语法获取或发送数据”，简而言之，可以使用 cURL 发送 http/https 请求。</p>
<a id="more"></a>


<h1 id="使用-cURL"><a href="#使用-cURL" class="headerlink" title="使用 cURL"></a>使用 cURL</h1><p>在进行实现之前，我们需要对 cURL 语法有一个大致的了解，当然有使用 cURL 的读者可以跳过该部分。下面来看一个简单的 cURL 例子，该命令向 <a href="https://www.baidu.com/">https://www.baidu.com</a> 发送一个 GET 请求，获取该响应数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://www.baidu.com</span><br></pre></td></tr></table></figure>
<p>cURL 还提供一系列的参数，比如通过 -X、–request 参数来指定请求方法，-H 参数指定请求头，-d 参数指定请求参数，–data-row 指定 body 等等。之后我们得到一个复杂的 cURL 例子，如下所示，该命令携带一个json数据向 <a href="http://localhost:6000/log">http://localhost:6000/log</a>  发送一个 POST 请求。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --location --request POST &#x27;http://localhost:6000/log&#x27; \</span><br><span class="line">--header &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">--data-raw &#x27;&#123;</span><br><span class="line">    &quot;serviceName&quot;: &quot;Gateway-Service&quot;,</span><br><span class="line">    &quot;content&quot;: &quot;test&quot;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h1><p>现在进入正题，有了前面的知识铺垫，相信会事半功倍。编写代码之前，先来讲述一下实现思路，cURL 是一个类似与 key/value 格式数据，也就是说通过 -H 指定请求头参数，后面跟着请求头数据，所以这里采用状态机方式实现会更好。</p>
<p>一个完整的请求由请求行、请求头和body进行组成，下面我们定义了一个 Request struct 来表示请求，解析之后通过该 struct 进行表示。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	Method <span class="keyword">string</span> <span class="string">`json:&quot;method&quot;`</span></span><br><span class="line">	Url    <span class="keyword">string</span> <span class="string">`json:&quot;url&quot;`</span></span><br><span class="line">	Header Header <span class="string">`json:&quot;header&quot;`</span></span><br><span class="line">	Body   <span class="keyword">string</span> <span class="string">`json:&quot;body&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析之前需要对传入的 curl 参数进行一个判断，如果该参数不是一个 curl 命令，那么无需继续解析了。判断方法也很简单，如果该参数是 <code>curl </code> 开头（注意 curl 后还有个空格），那么基本可以认定该参数是一个 curl 命令。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> strings.Index(curl, <span class="string">&quot;curl &quot;</span>) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 curl 是一个 shell 命令，接下来使用 go-shellwords 库对 curl 参数进行解析，得到一个 string 数组。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">args, err := shellwords.Parse(curl)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后调用 rewrite 方法对 args 数组进行二次清洗，该步骤的目的是为了去除数组中的<code>\n</code> 元素。因为 curl 还有一个特殊的参数，使用-X 参数来指定请求方法，比如说 -XPUT，该参数指定了一个 PUT 请求，所以这里需要将 -XPUT 这种参数进行拆分，得到 -X 与 PUT 两个参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(curl <span class="keyword">string</span>)</span> <span class="params">(*Request, <span class="keyword">bool</span>)</span></span> &#123; </span><br><span class="line">    ....</span><br><span class="line">    args = rewrite(args)</span><br><span class="line">	request := &amp;Request&#123;Method: <span class="string">&quot;GET&quot;</span>, Header: Header&#123;&#125;&#125;</span><br><span class="line">	state := <span class="string">&quot;&quot;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rewrite</span><span class="params">(args []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">		arg = strings.TrimSpace(arg)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> arg == <span class="string">&quot;\n&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> strings.Contains(arg, <span class="string">&quot;\n&quot;</span>) &#123;</span><br><span class="line">			arg = strings.ReplaceAll(arg, <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// split request method</span></span><br><span class="line">		<span class="keyword">if</span> strings.Index(arg, <span class="string">&quot;-X&quot;</span>) == <span class="number">0</span> &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, arg[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">			res = <span class="built_in">append</span>(res, arg[<span class="number">2</span>:])</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, arg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="实现状态机"><a href="#实现状态机" class="headerlink" title="实现状态机"></a>实现状态机</h1><p>状态机是实现解析 cURL 核心部分，前面我们对 cURL 参数进行分割与清洗。</p>
<p>实现状态机之前我们需要对 cURL 一些参数进行了解，比如说通过 -A 与 –user–agent 参数可以指定 user-agent。此时就可以给状态机赋值为 user-agent 然后就跳出该  switch，等到遍历到下一个参数的时候，就进入 switch 中的最后一个 case，在该case 里面，会对状态机的状态进行检测，提取出相应的值，最后清除状态的状态。</p>
<p>解析 -H 与 –header 参数时，需要进行拆分操作。比如说 <code>-H &#39;Accept-Encoding: gzip, deflate, sdch&#39;</code>，此时就需要获取请求头与值得到 <code>Accept-Encoding</code> 与  <code>gzip, deflate, sdch</code>，最后添加到 request struct 的 header 中。请求的类型为 application/x-www-form-urlencoded 时，需要使用 &amp; 对请求参数进行拼接，倘若是 application/json，那么直接赋值即可。解析 -u 与 –user 参数时，需要对 arg 参数进行一个 base64 编码操作，然后向请求添加一个 Authorization 头。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(curl <span class="keyword">string</span>)</span> <span class="params">(*Request, <span class="keyword">bool</span>)</span></span> &#123;  </span><br><span class="line">	....</span><br><span class="line">    	<span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">		<span class="keyword">switch</span> <span class="literal">true</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> isUrl(arg):</span><br><span class="line">			request.Url = arg</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> arg == <span class="string">&quot;-A&quot;</span> || arg == <span class="string">&quot;--user-agent&quot;</span>:</span><br><span class="line">			state = <span class="string">&quot;user-agent&quot;</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> arg == <span class="string">&quot;-H&quot;</span> || arg == <span class="string">&quot;--header&quot;</span>:</span><br><span class="line">			state = <span class="string">&quot;header&quot;</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> arg == <span class="string">&quot;-d&quot;</span> || arg == <span class="string">&quot;--data&quot;</span> || arg == <span class="string">&quot;--data-ascii&quot;</span> || arg == <span class="string">&quot;--data-raw&quot;</span>:</span><br><span class="line">			state = <span class="string">&quot;data&quot;</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> arg == <span class="string">&quot;-u&quot;</span> || arg == <span class="string">&quot;--user&quot;</span>:</span><br><span class="line">			state = <span class="string">&quot;user&quot;</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> arg == <span class="string">&quot;-I&quot;</span> || arg == <span class="string">&quot;--head&quot;</span>:</span><br><span class="line">			request.Method = <span class="string">&quot;HEAD&quot;</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> arg == <span class="string">&quot;-X&quot;</span> || arg == <span class="string">&quot;--request&quot;</span>:</span><br><span class="line">			state = <span class="string">&quot;method&quot;</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> arg == <span class="string">&quot;-b&quot;</span> || arg == <span class="string">&quot;--cookie&quot;</span>:</span><br><span class="line">			state = <span class="string">&quot;cookie&quot;</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="built_in">len</span>(arg) &gt; <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">switch</span> state &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;header&quot;</span>:</span><br><span class="line">				fields := parseField(arg)</span><br><span class="line">				request.Header[fields[<span class="number">0</span>]] = strings.TrimSpace(fields[<span class="number">1</span>])</span><br><span class="line">				state = <span class="string">&quot;&quot;</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;user-agent&quot;</span>:</span><br><span class="line">				request.Header[<span class="string">&quot;User-Agent&quot;</span>] = arg</span><br><span class="line">				state = <span class="string">&quot;&quot;</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;data&quot;</span>:</span><br><span class="line">				<span class="keyword">if</span> request.Method == <span class="string">&quot;GET&quot;</span> || request.Method == <span class="string">&quot;HEAD&quot;</span> &#123;</span><br><span class="line">					request.Method = <span class="string">&quot;POST&quot;</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> !hasContentType(*request) &#123;</span><br><span class="line">					request.Header[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(request.Body) == <span class="number">0</span> &#123;</span><br><span class="line">					request.Body = arg</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					request.Body = request.Body + <span class="string">&quot;&amp;&quot;</span> + arg</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				state = <span class="string">&quot;&quot;</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;user&quot;</span>:</span><br><span class="line">				request.Header[<span class="string">&quot;Authorization&quot;</span>] = <span class="string">&quot;Basic &quot;</span> +</span><br><span class="line">					base64.StdEncoding.EncodeToString([]<span class="keyword">byte</span>(arg))</span><br><span class="line">				state = <span class="string">&quot;&quot;</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;method&quot;</span>:</span><br><span class="line">				request.Method = arg</span><br><span class="line">				state = <span class="string">&quot;&quot;</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;cookie&quot;</span>:</span><br><span class="line">				request.Header[<span class="string">&quot;Cookie&quot;</span>] = arg</span><br><span class="line">				state = <span class="string">&quot;&quot;</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="略有小成"><a href="#略有小成" class="headerlink" title="略有小成"></a>略有小成</h1><p>创建一个 example，使用 Parse 方法传入一个 curl 命令，得到一个 json 对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	parseCurl <span class="string">&quot;parse-curl&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	request, _ := parseCurl.Parse(<span class="string">&quot;curl &#x27;http://google.com/&#x27; \\\n  -H &#x27;Accept-Encoding: gzip, deflate, sdch&#x27; \\\n  -H &#x27;Accept-Language: en-US,en;q=0.8,da;q=0.6&#x27; \\\n  -H &#x27;Upgrade-Insecure-Requests: 1&#x27; \\\n  -H &#x27;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36&#x27; \\\n  -H &#x27;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27; \\\n  -H &#x27;Connection: keep-alive&#x27; \\\n  --compressed\n&quot;</span>)</span><br><span class="line">	fmt.Println(request.ToJson(<span class="literal">true</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://google.com/&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;header&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate, sdch&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Accept-Language&quot;</span>: <span class="string">&quot;en-US,en;q=0.8,da;q=0.6&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;body&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://en.wikipedia.org/wiki/CURL">https://en.wikipedia.org/wiki/CURL</a></li>
<li><a href="https://github.com/tj/parse-curl.js">https://github.com/tj/parse-curl.js</a></li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Java  NIO 实现 WebSocket 协议</title>
    <url>/2021/08/03/%E5%9F%BA%E4%BA%8E-Java-NIO-%E5%AE%9E%E7%8E%B0-WebSocket-%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<blockquote>
<p>本文对应的 easy-ws 源码地址：<a href="https://github.com/killlowkey/easy-ws">https://github.com/killlowkey/easy-ws</a></p>
</blockquote>
<p> WebSocket（简写：WS）是基于 TCP 连接的<a href="https://baike.baidu.com/item/%E5%85%A8%E5%8F%8C%E5%B7%A5">全双工</a>通信的协议，WS 协议在现实场景中用的很多，比如服务端和客户端之间互相推送数据。TCP 位于传输层，来保证我们的字节流数据可以稳定传输，而 WS 是位于应用层的协议，所谓的协议就是针对不同场景而诞生的东西，说白了协议就是服务端与客户端交互的方式。<a id="more"></a></p>
<p>本文会基于 Java NIO 实现简易的 WS 协议，在正式开始本文之前，希望读者有 Java NIO 基础和对 WS 协议有个大致的认识，倘若你有这些基础，那么阅读本文就会事半功倍。</p>
<h2 id="搭建-TCP-服务"><a href="#搭建-TCP-服务" class="headerlink" title="搭建 TCP 服务"></a>搭建 TCP 服务</h2><p>既然我们是使用 NIO 来实现 WS 协议，那么需要使用 NIO 作为传输层，在开始之前我们先来介绍 NIO 中几个核心的概念。NIO 中有Channel、Selector、ByteBuffer 三大核心组件。Channel 可以理解为客户端与服务端建立的连接，它们之间可以相互发送消息，消息则通过 ByteBuffer 来表示，说白了 ByteBuffer 就是个消息的存储体，我们将消息用 ByteBuffer 来包裹，然后将 ByteBuffer 扔给 Channel，那么消息就发送给对方了。Selector 是不同平台多路复用的抽象，什么是多路复用呢？没有多路复用之前，一个线程对应了一个链接，这就是传统的 BIO 模式，因为我们从客户端读写数据都是会阻塞的，倘若发生了阻塞，那么这个线程也就会被休眠，就会白白浪费操作系统资源，说个大白话，就是给钱不干活。有了多路复用之后，此时一个线程可以处理多个链接，该线程只会对有状态的链接进行处理，比如从客户端接收到连接、客户端有数据过来了，这种情况线程就要干活了；倘若管理的连接没有状态，那么这个线程也就被休眠了。</p>
<p>如下代码所示，我们分别对 ServerSocketChannel 与 Selector 进行初始化，ServerSocketChannel 负责从客户端接收连接。第3行代码配置 ServerSocketChannel  为非阻塞的模式，倘若服务端的 Channel 是阻塞的，它是无法被 Selector 管理的。最后将服务端的 Channel 绑定监听端口，然后调用 <code>ServerSocketChannel#register</code>方法来为  ServerSocketChannel 注册 selector，这里的 <code> SelectionKey.OP_ACCEPT</code> 参数含义是只对 ServerSocketChannel 的接收连接操作进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.easy.ws.WsServer#initServer</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p>ServerSocketChannel 初始化之后，我们通过一个死循环不停的接收客户端的连接。下列第2行代码，调用了 <code>Selector#select()</code> 方法，该方法会产生阻塞，如果当前 Selector 管理的 channel 没有新状态，那么线程会一直的阻塞在这。倘若有客户端连接过来，我们就来到了第3行代码此时会获取 SelectionKey 迭代器，然后通过一个 while 循环来遍历它，得到一个 SelectionKey  对象，这样要注意，需要调用迭代器的 remove() 方法来移除该对象，否则下次会重复处理。</p>
<p>然后通过 <code>SelectionKey#isAcceptable()</code> 来判断是否有连接过来了，从 SelectionKey 中获取 ServerSocketChannel  对象，并调用它的 accept() 方法来接收连接即可。这里还有一个关键点，因为客户端连接（SocketChannel）也是交由 Selector 来进行管理的，所以 SocketChannel 也需要配置为非阻塞模式。最后我们设置了一个 KEEPALIVE 参数，因为 ws 协议可以互相推送数据的特性，那么服务端与客户端之间需要保持一个长连接的状态，所以我们设置  KEEPALIVE 为 true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.easy.ws.WsServer#start</span></span><br><span class="line"><span class="keyword">while</span> (running) &#123;</span><br><span class="line">    selector.select();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey selectionKey = iterator.next();</span><br><span class="line">        iterator.remove();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// accept connection from client</span></span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">            SocketChannel socketChannel = ssc.accept();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, Boolean.TRUE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解析-WS-协议"><a href="#解析-WS-协议" class="headerlink" title="解析 WS 协议"></a>解析 WS 协议</h2><p>上一节我们搭建了一个 TCP 服务，接收到客户端连接后，那么需要从客户端读取消息，之后对该消息进行解析，来判断该数据包是否符合 WS 协议要求。</p>
<h3 id="处理握手包"><a href="#处理握手包" class="headerlink" title="处理握手包"></a>处理握手包</h3><p>TCP 进行三次握手之后，此时客户端才与服务端建立了链接，倘若三次握手失败，那么则建立连接失败。同理，WS 连接的建立同样需要握手包，首先客户端向服务端发送握手包，服务端解析并处理之后返回响应包给客户端，此时一个 WS 连接才算真正建立了。</p>
<p>下图是 WS 连接握手包信息，类似于 HTTP 协议的请求头，首先来看到请求头 <strong>Sec-WebSocket-Key</strong> 值，这是我们握手包中最重要的东西，该值用 base64 进行编码。握手包发送给服务端之后，然后从请求头中读取该值，处理之后返回一个 <strong>Sec-WebSocket-Accept</strong> 响应头</p>
<p><img src="images/Snipaste_2021-08-02_22-01-05.png" alt="Snipaste_2021-08-02_22-01-05"></p>
<p>从 SocketChannel 读取请求之后，我们会得到一个请求头，如第8行代码所示，我们会从请求头中寻找 Sec-WebSocket-Key 值，如果该请求头未找到，那么则关闭连接，说明这个请求不是 WS 连接。找到之后我们调用了 getSecWebSocketAccept(String) 方法，来生成 Sec-WebSocket-Accept 响应头。</p>
<p>进入该方法后，在请求头 Sec-WebSocket-Key 值后加上一个固定的 GUID（258EAFA5-E914-47DA-95CA-C5AB0DC85B11），GUID 的值是 WS 协议所规范的，得到新生成的字符串后，将该字符串进行 SHA1 加密，然后将加密的 byte 数组进行 Base64 编码，最后得到 Sec-WebSocket-Accept 值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.easy.ws.WsServer#handlerHandshake</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">handlerHandshake</span><span class="params">(SocketChannel socketChannel)</span> </span>&#123;</span><br><span class="line">    ByteBuffer data = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    Pattern pattern = Pattern.compile(<span class="string">&quot;Sec-WebSocket-Key: (.*)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        socketChannel.read(data);</span><br><span class="line">        <span class="comment">// obtain Sec-WebSocket-Key value from request header</span></span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="keyword">new</span> String(data.array(), StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            String key = matcher.group(<span class="number">1</span>).trim();</span><br><span class="line">            String response = <span class="string">&quot;HTTP/1.1 101 Switching Protocols\r\nUpgrade: &quot;</span></span><br><span class="line">                + <span class="string">&quot;websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: &quot;</span></span><br><span class="line">                + getSecWebSocketAccept(key) + <span class="string">&quot;\r\n\r\n&quot;</span>;</span><br><span class="line">            <span class="comment">// write handshake packet</span></span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(response.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(socketChannel.getRemoteAddress() + <span class="string">&quot; not found ws handshake&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioException) &#123;</span><br><span class="line">            ioException.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        data.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端先获取 Sec-WebSocket-Key 请求头的值，之后在该值后加上 GUID</span></span><br><span class="line"><span class="comment">// 然后对该字符串进行 SHA1 加密，得到一个 byte 数组，最终将 byte 数组进行base64加密即可</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getSecWebSocketAccept</span><span class="params">(String key)</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    String guid = <span class="string">&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;</span>;</span><br><span class="line">    key += guid;</span><br><span class="line">    MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">    md.update(key.getBytes(StandardCharsets.UTF_8), <span class="number">0</span>, key.length());</span><br><span class="line">    <span class="keyword">byte</span>[] shaHash = md.digest();</span><br><span class="line">    <span class="keyword">return</span> Base64.getEncoder().encodeToString(shaHash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将响应头返回给客户端后，客户端就与服务端建立起了 WS 连接。因为 easy-ws 借鉴了 Netty 的 Boss-Worker 设计，Boss 线程负责从客户端接收连接，而 Worker 线程负责对客户端连接进行处理。所以成功建立起 WS 连接后，我们需要将 SocketChannel 注册到 Worker 的线程中（每个 Worker 线程都有一个 Selector），Worker 线程就可以对注册的连接进行处理了，具体的实现细节还请看 <a href="https://github.com/killlowkey/easy-ws">easy-ws</a> 源码，这里就不过多赘述了。</p>
<blockquote>
<p>Boss 线程只有一个，而 Worker 是有多个</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.easy.ws.WsServer#registerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerSocketChannel</span><span class="params">(SocketChannel socketChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.worker[count.getAndIncrement() % WORKER_NUM].register(socketChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理-WS-请求"><a href="#处理-WS-请求" class="headerlink" title="处理 WS 请求"></a>处理 WS 请求</h3><p>SocketChannel 注册到 Worker 线程之后，那么 Worker 就可以对该连接进行处理，处理方式跟服务端逻辑相似。这样有一个坑，调用 <code>Selector#select()</code> 方法需要加上一个 timeout，因为 Boss 与 Worker 线程启动时间相差不大，Boss 将接收到客户端连接注册到 Worker 线程后，倘若没有加上 timeout ， 这个 Worker 线程就阻塞在这了，因为 Selector 实现问题，也就无法处理新注册的 SocketChannel，之后客户端发送了消息，Worker 线程是读取不到的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.easy.ws.WorkerThread#run</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 不加上 timout，channel 注册之后无法读取消息</span></span><br><span class="line">            <span class="keyword">this</span>.selector.select(<span class="number">1000L</span>);</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = <span class="keyword">this</span>.selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    WsContext wsContext = (WsContext) selectionKey.attachment();</span><br><span class="line">                    <span class="comment">// 处理 ws body</span></span><br><span class="line">                    wsContext.handlerPayload();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 SelectionKey 处于可读状态时，那么就调用 <code>WsContext#handlerPayload()</code> 方法处理即可。首先从客户端中读取数据包，之后对该数据包进行解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.easy.ws.WsContextImpl#handlerPayload</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerPayload</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// -1 or 0 =&gt; EOF</span></span><br><span class="line">    <span class="keyword">while</span> ((len = socketChannel.read(byteBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bos.write(byteBuffer.array(), <span class="number">0</span>, len);</span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteBuffer data = ByteBuffer.wrap(bos.toByteArray());</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;message body：&#123;&#125;&quot;</span>, Arrays.toString(data.array()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...............</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 WS 协议，重点在于 WS 数据包解析这块，WS 协议规范数据包第一个字节的后4位代表消息类型，第二个字节是消息的长度，这个字节减去 128 处于 0-125 之间，那么该消息长度是该减去后128值（举个例子，第二个字节值为132，减去128得到4，此时4在0-125 之间，那么该消息长度是4个字节）。如果该值是 126，那么第3、4字节（short）是消息长度；该值是127，第3-10 字节（long）是消息的长度。随后四个字节是消息加密的密匙，用于解密消息，每次 WS 请求的密匙都是不同的。</p>
<blockquote>
<p>这里说的字节都是无符号的，Java 的字节是有符号的，所以需要进行与运算得到无符号字节</p>
<p>以下内容摘取 rfc6455  规范：<a href="https://datatracker.ietf.org/doc/html/rfc6455#section-5.2">https://datatracker.ietf.org/doc/html/rfc6455#section-5.2</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16&#x2F;64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len&#x3D;&#x3D;126&#x2F;127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len &#x3D;&#x3D; 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>OpCode 值代表消息类型</p>
<ol>
<li>%x0：denotes a continuation frame</li>
<li>%x1：文本数据</li>
<li>%x2：二进制数据</li>
<li>%x3-7：are reserved for further non-control frames</li>
<li>%x8：连接关闭</li>
<li>%x9：PING</li>
<li>%xA：PONG</li>
<li>%xB-F：are reserved for further control frames</li>
</ol>
<p>了解 WS 协议规范后，我们就开始对数据包进行解析，首先对消息类型进行解析，我们向 <code>parseFrame(byte)</code> 方法传入一个 byte，之后这个 byte 与（&amp;） 0xFF 得到无符号 byte，然后在与（&amp;） 0xF，得到该无符号字节的后四位（OpCode），知道 OpCode 也就知道消息的类型了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">parseFrame(data.get())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> FrameType <span class="title">parseFrame</span><span class="params">(<span class="keyword">byte</span> code)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// abcd message body：[-127, -124, 79, 43, -40, -15, 46, 73, -69, -107]</span></span><br><span class="line">    <span class="comment">// data[0] &amp; 0xFF =&gt; 129（Unsigned Byte）</span></span><br><span class="line">    <span class="comment">// 129 &amp; 0xF =&gt; 1（OpCode：最低四位）</span></span><br><span class="line">    <span class="keyword">return</span> FrameType.parseFrame((code &amp; <span class="number">0xFF</span>) &amp; <span class="number">0xF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后解析消息的长度，我们先拿到数据包的第二个字节，该字节与上 0xFF 之后，得到一个无符号的 byte。再跟 128 进行异或运算（达到减去128效果），之后根据该 flag 进行进一步的解析，如果该值小于 125 那么直接返回即可，等于 126，那就获取之两个字节转为无符号 short 返回，等于127 获取后8个字节直接返回即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.easy.ws.WsContextImpl#getPayloadLen</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getPayloadLen</span><span class="params">(ByteBuffer data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// abcd message body：[-127, -124, 79, 43, -40, -15, 46, 73, -69, -107]</span></span><br><span class="line">    <span class="comment">// data[1] &amp; 0xFF =&gt; 132（Unsigned Byte）</span></span><br><span class="line">    <span class="comment">// 132 ^ 128 =&gt; 4</span></span><br><span class="line">    <span class="keyword">int</span> flag = (data.get() &amp; <span class="number">0xFF</span>) ^ <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag &lt;= <span class="number">125</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">126</span>) &#123;</span><br><span class="line">        <span class="comment">// convert to unsigned short</span></span><br><span class="line">        <span class="keyword">return</span> data.getShort() &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">127</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data.getLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>知道消息的类型和长度后，那么我们要进行最重要的一步，对消息进行解密操作。首先从数据包获取四个字节的消息密匙，再从数据包中获取指定消息长度的数据，然后进行解密操作，看到下列代码 21 行，数据的每个字节（无符号）都与密匙指定位置字节（无符号，根据要解密数据索引来计算指定位置的密匙字节）进行异或运算，得到解密的数据。</p>
<p>此时我们对 WS 请求数据包解密就大功告成，对解密后的数据处理完成，就可以响应给客户端。</p>
<blockquote>
<p>有读者会产生疑问，从 ByteBuffer  获取数据时，没有看到读取数据包指定位置的数据呢？这是 ByteBuffer 特性，每使用 get 或 getXX 方法获取数据，其 ByteBuffer 偏移量都会根据对应读取的字节数更新。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.easy.ws.WsContextImpl#decode</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] decode(ByteBuffer data) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息长度</span></span><br><span class="line">    <span class="keyword">long</span> payloadLen = getPayloadLen(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取密匙</span></span><br><span class="line">    <span class="comment">// key：[79, 43, -40, -15]</span></span><br><span class="line">    <span class="keyword">byte</span>[] key = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">    data.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息体</span></span><br><span class="line">    <span class="comment">// payload：[46, 73, -69, -107]</span></span><br><span class="line">    <span class="keyword">byte</span>[] payload = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) payloadLen];</span><br><span class="line">    data.get(payload);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key：[79, 43, -40, -15]   (&amp; 0xFF)=&gt; [79, 43, 216, 241]</span></span><br><span class="line">    <span class="comment">// payload：[46, 73, -69, -107] (&amp; 0xFF)=&gt; [46, 73, 187, 149]</span></span><br><span class="line">    <span class="comment">// decode payload: =&gt; (byte) (payload[i] ^ key[i &amp; 0x3])</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; payload.length; i++) &#123;</span><br><span class="line">        payload[i] = (<span class="keyword">byte</span>) ((payload[i] &amp; <span class="number">0xFF</span>) ^ (key[i &amp; <span class="number">0x3</span>] &amp; <span class="number">0xFF</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理-WS-响应"><a href="#处理-WS-响应" class="headerlink" title="处理 WS 响应"></a>处理 WS 响应</h3><p>rfc6455 规范的 section-5.7 部分给出了几个响应数据包例子，下面例子大致可以将响应分为 明文、加密、分段 三类，我们响应数据时，数据包第一个字节是一个标志位，与我们解析请求数据包相同，该字节的后四位代表 OpCode，也就是消息类型，第二个字节是消息的长度，倘若我们传输的是加密数据，那么长度后面四个字节是加密的密匙。在例子3中给出响应数据分段，如果我们要响应 Hello 文本数据，将 Hello 分为 “Hel” 与 “lo” 两段数据，第一段数据包第一个字节响应 OpCode ，后面跟着 Hel 长度，最后是 Hel 内容；第二段数据包第一个字节是明文数据包第一个字节的前四位（一般是0x80），后面是分段数据的长度和内容。</p>
<p>例子1、2、3 仅仅用于传输小于 125 个字节的数据，如果我们传输的字节大于125呢？例子 5、6给出了示例，不知读者还记得上文中我们是如何解析请求数据包长度的，如果第二个字节减去128 等于126那么消息长度是 一个无符号 short，等于127 消息长度是一个 long 类型。</p>
<blockquote>
<p>以下内容摘取 rfc6455  规范：<a href="https://datatracker.ietf.org/doc/html/rfc6455#section-5.7">https://datatracker.ietf.org/doc/html/rfc6455#section-5.7</a></p>
</blockquote>
<ol>
<li>A single-frame unmasked text message<ol>
<li>0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains “Hello”)</li>
</ol>
</li>
<li>A single-frame masked text message<ol>
<li>0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58 (contains “Hello”)</li>
</ol>
</li>
<li>A fragmented unmasked text message<ol>
<li>0x01 0x03 0x48 0x65 0x6c (contains “Hel”)</li>
<li>0x80 0x02 0x6c 0x6f (contains “lo”)</li>
</ol>
</li>
<li>Unmasked Ping request and masked Ping response<ol start="5">
<li>0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains a body of “Hello”, but the contents of the body are arbitrary)</li>
<li>0x8a 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58 (contains a body of “Hello”, matching the body of the ping)</li>
</ol>
</li>
<li>256 bytes binary message in a single unmasked frame<ol>
<li>0x82 0x7E 0x0100 [256 bytes of binary data]</li>
</ol>
</li>
<li>64KiB binary message in a single unmasked frame<ol>
<li>0x82 0x7F 0x0000000000010000 [65536 bytes of binary data]</li>
</ol>
</li>
</ol>
<p>为了降低实现难度，esay-ws 采用明文传输方式，下面的 write 方法中接收一个 WsPayload 对象，该对象包含了响应的消息类型、消息长度。我们将数据包分为两段进行传输，第一个段写入数据包的元信息（metadata），第二段写入消息的内容。如第6行代码所示，首先我们为元数据分配10个字节的空间，倘若我们传输的消息长度是一个 long ，那么消息长度占用8个字节，响应数据包第一个字节是一个标志位，第二个字节是关于消息长度的，所以整体加起来不会超过10个字节。</p>
<p>第14行代码，我们写入数据包第一个字节，这里用 <code>0x80</code> 来跟 OpCode 进行或运算，因为第一个字节前4位几乎是固定的，我们只需要与 OpCode 进行组合即可。接下来判断消息长度，如果小于 125 那么直接将消息长度转为无符号 byte写入即可；倘若在 126 - 无符号 short 之间，那么先写入 <code>0x7E</code> 标志位在写入消息长度（无符号 short）；如果在无符号short - long 之间，那么写入 <code>0x7F</code> 标志位，最后写入该消息长度。</p>
<p>因为响应数据包使用 ByteBuffer 来存储，这里需要调用 ByteBuffer#flip 方法将 ByteBuffer 设置为可写模式，最后调用 <code>SocketChannel#write(ByteBuffer)</code> 方法将元信息和消息内容写出即可。调用 <code>SocketChannel#write</code> 方法后，数据不会立即到达客户端，而是先将数据复制到了内核缓冲区，具体发送时机是由操作系统决定的，可能我们元数据和消息内容会组合成一个数据包一起发送给客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.easy.ws.WsContextImpl#write</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(WsPayload wsPayload)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://datatracker.ietf.org/doc/html/rfc6455#section-5.7</span></span><br><span class="line">    ByteBuffer metadata = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入flag</span></span><br><span class="line">    <span class="keyword">int</span> opCode = wsPayload.getFrameType().getOpCode();</span><br><span class="line">    <span class="comment">// 0x80 =&gt; 1000 0000</span></span><br><span class="line">    <span class="comment">// text frame type =&gt; 0000 0001</span></span><br><span class="line">    <span class="comment">// 0x80 | text frame type  =&gt; 1000 0001</span></span><br><span class="line">    <span class="comment">// (byte)(1000 0001) =&gt; -127</span></span><br><span class="line">    metadata.put((<span class="keyword">byte</span>) (<span class="number">0x80</span> | opCode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write payload length</span></span><br><span class="line">    <span class="keyword">long</span> length = wsPayload.getDataLength();</span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">125</span>) &#123;</span><br><span class="line">        metadata.put((<span class="keyword">byte</span>) length);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length &lt;= <span class="number">0xFFFF</span>) &#123;</span><br><span class="line">        <span class="comment">// data range 126 - 0xFFFF</span></span><br><span class="line">        metadata.put((<span class="keyword">byte</span>)  <span class="number">0x7E</span>);</span><br><span class="line">        <span class="comment">// write unsigned short</span></span><br><span class="line">        metadata.putShort((<span class="keyword">short</span>) length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// data range &gt; 0xFFFF</span></span><br><span class="line">        metadata.put((<span class="keyword">byte</span>)  <span class="number">0x7F</span>);</span><br><span class="line">        <span class="comment">// write unsigned long</span></span><br><span class="line">        metadata.putLong(length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flip 一下才能写出数据</span></span><br><span class="line">    metadata.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.socketChannel.write(metadata);</span><br><span class="line">    <span class="keyword">this</span>.socketChannel.write(ByteBuffer.wrap(wsPayload.getData()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// com.easy.ws.WsPayload</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WsPayload</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">FrameType <span class="title">getFrameType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] getData();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">long</span> <span class="title">getDataLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getData().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行-WS-服务"><a href="#运行-WS-服务" class="headerlink" title="运行 WS 服务"></a>运行 WS 服务</h2><p>在上文中，我们实现了解析握手包、请求数据包、响应数据包功能，这几个核心功能构成了一个简易的 WS 服务器。然后运行 WS 服务进行测试一下，首先传入 8080 监听端口给 WsServer，之后调用其 setWsCallback 方法设置一个 WsCallback 回调来处理信息，倘若客户端与服务端建立起链接，那么会调用 WsCallback#onOpen 方法；当接收消息到消息会调用 WsCallback#onMessage；连接关闭时，则调用 WsCallback#onClose ；最后调用 <code>WsServer#start()</code> 方法启动 WS 服务即可。</p>
<blockquote>
<p>下面代码是联系不到上下文的，具体的代码，还请看到 easy-ws github：<a href="https://github.com/killlowkey/easy-ws">https://github.com/killlowkey/easy-ws</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WsServerExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        WsServer wsServer = <span class="keyword">new</span> WsServer(<span class="number">8080</span>);</span><br><span class="line">        wsServer.setWsCallback(<span class="keyword">new</span> WsCallback() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(WsContext context)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;成功与 &quot;</span> + context.getRemoteAddress() + <span class="string">&quot;建立起 ws 链接&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> WsPayload <span class="title">onMessage</span><span class="params">(WsContext context, WsPayload wsPayload)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到 &quot;</span> + context.getRemoteAddress() + <span class="string">&quot; 消息：&quot;</span> + <span class="keyword">new</span> String(wsPayload.getData(), StandardCharsets.UTF_8));</span><br><span class="line">                <span class="comment">// send text data</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DefaultWsPayload(FrameType.TEXT, <span class="string">&quot;hello,ws&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(WsContext context)</span> </span>&#123;</span><br><span class="line">                System.out.println(context.getRemoteAddress() + <span class="string">&quot; 断开了 ws 链接&quot;</span>);</span><br><span class="line">                context.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        wsServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动 WS 服务后，我们访问 <a href="http://www.easyswoole.com/wstool.html">http://www.easyswoole.com/wstool.html</a> 进入WebSocket 在线测试工具，在服务器地址输入栏中输入 ws://127.0.0.1:8080 ，然后点击开始连接，客户端就与服务端建立起 WS 连接。</p>
<p><img src="images/Snipaste_2021-08-03_11-48-03.png" alt="Snipaste_2021-08-03_11-48-03"></p>
<p>成功建立起 WS 连接后，会在服务端控制台输出 “成功与 /127.0.0.1:61437建立起 ws 链接” 信息，在在线测试工具中，“开始连接” 按钮变成了 “关闭连接”。此时就发送内容到服务器，输入内容，点击发送到服务端按钮，会收到服务端响应的 “hello, ws”信息。</p>
<p><img src="images/Snipaste_2021-08-03_11-48-24.png" alt="Snipaste_2021-08-03_11-48-24"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</a></li>
<li><a href="https://www.rfc-editor.org/info/rfc7692">RFC 7692</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">Writing_WebSocket_servers</a></li>
</ol>
<h2 id="尾语"><a href="#尾语" class="headerlink" title="尾语"></a>尾语</h2><p>本文并未涉及 <a href="https://github.com/killlowkey/easy-ws">easy-ws</a> 设计细节，从而出现读着读着就联系不到上下文情况。由于篇幅的原因和简化实现 WS 协议难度，不可能对所有的细节面面俱到，只能覆盖解析 WS 协议一些重要的步骤。同时本文并未实现一个完整的 WS 协议，具体的实现细节还请读者自行探究，本文只是起到一个抛砖引玉的作用。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>WebSocket</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 学习笔记：第10章  泛型、trait、生命周期</title>
    <url>/2021/07/06/Rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC10%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E3%80%81trait%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="消除重复代码"><a href="#消除重复代码" class="headerlink" title="消除重复代码"></a>消除重复代码</h2><h3 id="重复代码"><a href="#重复代码" class="headerlink" title="重复代码"></a>重复代码</h3><ul>
<li>重复代码危害<ul>
<li>容易出错</li>
<li>需求变更时需要在多处进行修改</li>
</ul>
</li>
<li>消除重复：提取函数<a id="more"></a></li>
</ul>
<h3 id="消除重复的步骤"><a href="#消除重复的步骤" class="headerlink" title="消除重复的步骤"></a>消除重复的步骤</h3><ul>
<li>识别重复代码</li>
<li>提取重复代码到函数体中，并在函数签名中指定函数的输入和返回值</li>
<li>将重复的代码使用函数调用进行替代</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = number_list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> number_list &#123;</span><br><span class="line">        <span class="keyword">if</span> number &gt; largest &#123;</span><br><span class="line">            largest = number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, largest);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>, <span class="number">60</span>, <span class="number">70</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = number_list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> number_list &#123;</span><br><span class="line">        <span class="keyword">if</span> number &gt; largest &#123;</span><br><span class="line">            largest = number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述的重复代码，可以将一些操作抽到函数中，具体代码如下所示</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>(list: &amp;[<span class="built_in">i32</span>]) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> number &gt; largest &#123;</span><br><span class="line">            largest = number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> result = largest(&amp;number_list)</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>, <span class="number">60</span>, <span class="number">70</span>];</span><br><span class="line">    <span class="keyword">let</span> result = largest(&amp;number_list)</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul>
<li>泛型：提高代码复用能力<ul>
<li>处理重复代码的问题</li>
</ul>
</li>
<li>泛型是具体类型或其它属性的抽象代替<ul>
<li>你编写的代码不是最终的代码，而是一种模版，里面有一些“占位符”</li>
<li>编译器在编译时将“占位符”<strong>替换为具体的类型</strong></li>
</ul>
</li>
<li>例如：<code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;...&#125;</code></li>
<li>泛型类型参数<ul>
<li>很短，通常一个字母；通常使用 T 作为泛型参数名称</li>
<li>CamelCase（驼峰命名）</li>
<li>T：Type 的缩写</li>
</ul>
</li>
</ul>
<h3 id="函数定义中的泛型"><a href="#函数定义中的泛型" class="headerlink" title="函数定义中的泛型"></a>函数定义中的泛型</h3><ul>
<li>泛型参数<ul>
<li>参数类型</li>
<li>返回类型</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T: std::cmp::<span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item.le(&amp;largest) &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Struct-定义中的泛型"><a href="#Struct-定义中的泛型" class="headerlink" title="Struct 定义中的泛型"></a>Struct 定义中的泛型</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> interger = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> float  = Point &#123; x : <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以使用多个泛型的类型参数</p>
<ul>
<li>太多类型参数：你的代码需要重组为多个更小的单元</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> interger = Point &#123; x: <span class="number">5</span>, y: <span class="number">1.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> float  = Point &#123; x : <span class="number">1.0</span>, y: <span class="number">40</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Enum-定义中的泛型"><a href="#Enum-定义中的泛型" class="headerlink" title="Enum 定义中的泛型"></a><code>Enum</code> 定义中的泛型</h3></li>
<li><p>可以让枚举的变体持有泛型数据类型</p>
<ul>
<li>例如：<code>Option&lt;T&gt;</code>、<code>Result&lt;T, E&gt;</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法定义中的泛型"><a href="#方法定义中的泛型" class="headerlink" title="方法定义中的泛型"></a>方法定义中的泛型</h3></li>
<li><p>为 struct 或 <code>enum</code> 实现方法的时候，可在定义中使用泛型</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123;x: <span class="number">5</span>, y: <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意：</p>
<ul>
<li>把 T 放在 <code>impl</code> 关键字后，表示在类型 T 上实现方法<ul>
<li>例如：<code>impl&lt;T&gt; Point&lt;T&gt;</code></li>
</ul>
</li>
<li>只针对具体类型实现方法（其余类型没实现方法）<ul>
<li>例如：<code>impl Point&lt;i32&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>struct 里的泛型参数可以和方法的泛型参数不同</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">mixup</span></span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = Point &#123; x: <span class="number">5</span>, y: <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> p2 = Point &#123; x: <span class="string">&quot;hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> p3 = p1.mixup(p2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="泛型代码的性能"><a href="#泛型代码的性能" class="headerlink" title="泛型代码的性能"></a>泛型代码的性能</h3><ul>
<li>使用泛型的代码和使用具体类型的代码运行速度是一样的</li>
<li>单态化（<code>monomorphization</code>）<ul>
<li>在编译时将泛型替换为具体类型的过程</li>
</ul>
</li>
</ul>
<h2 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h2><ul>
<li>Trait 告诉 Rust 编译器：<ul>
<li>某种类型具有那些并且可以与其他类型共享的功能</li>
</ul>
</li>
<li>Trait：抽象的定义共享行为</li>
<li>Trait bounds（约束）：泛型类型参数指定为实现了特定行为的类型</li>
<li>Trait 与其它语言的接口（interface）类似，但有些区别</li>
</ul>
<h3 id="定义一个-Trait"><a href="#定义一个-Trait" class="headerlink" title="定义一个 Trait"></a>定义一个 Trait</h3><ul>
<li>Trait 定义：把方法签名放在一起，来定义实现某种目的所必需的一组行为<ul>
<li>关键字：trait</li>
<li>只有方法签名，没有具体实现</li>
<li>trait 可以有多个方法：每个方法签名占一行，以 <code>;</code> 结尾</li>
<li>实现该 trait 的类型必须提供具体的方法实现</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在类型上实现-Trait"><a href="#在类型上实现-Trait" class="headerlink" title="在类型上实现 Trait"></a>在类型上实现 Trait</h3><ul>
<li>与为类型实现方法类似</li>
<li>不同之处<ul>
<li><code>impl Xxxx for Tweet &#123;...&#125;</code></li>
<li>在 <code>impl</code> 的块里，需要对 Trait 里方法签名进行具体实现</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewArticle</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>，</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125;（&#123;&#125;）&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> demo::Summary;</span><br><span class="line"><span class="keyword">use</span> demo::Tweet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tweet = Tweet&#123;</span><br><span class="line">        usernmae: <span class="built_in">String</span>::from(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 new tweet: &#123;&#125;&quot;</span>, yweet.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现-Trait-的约束"><a href="#实现-Trait-的约束" class="headerlink" title="实现 Trait 的约束"></a>实现 Trait 的约束</h3><ul>
<li>可以在某个类型上实现某个 trait 的前提条件是<ul>
<li>这个类型或这个 trait 是在本地 crate 里定义的</li>
</ul>
</li>
<li>无法为外部类型来实现外部的 trait<ul>
<li>这个限制是程序属性的一部分（也就是<strong>一致性</strong>）</li>
<li>更具体地说是<strong>孤儿规则</strong>：之所以这样命名是因为父类型不存在</li>
<li>此归杂确保其他人的代码不能破坏你的代码，反之亦然</li>
<li>如果没有这个规则，两个 crate 可以为同一个类型实现同一个 trait，Rust 就不知道应该使用那个实现了</li>
</ul>
</li>
</ul>
<h3 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h3><ul>
<li>默认实现的方法可以调用 trait 中其他的方法，即使这些方法没有默认实现</li>
<li>注意：无法从方法的重写实现里面调用默认的实现</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="comment">// 默认实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewArticle</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>，</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接继承 Summary 默认实现</span></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewArticle &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="comment">// 重写该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Trait-作为参数"><a href="#Trait-作为参数" class="headerlink" title="Trait 作为参数"></a>Trait 作为参数</h3><ul>
<li><p>impl Trait 语法：适用于简单情况</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 impl Summary 来声明 trait 作为参数</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Trait bound 语法：可用于复杂情况</p>
<ul>
<li>impl Trait 语法是 Trait bound 的语法糖</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用泛型来声明 trait 作为参数</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 + 指定多个 Trait bound：代码不太美观</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要求 item 实现了 Summary 与 Display Trait</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary + Display) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Trait bound 使用 where 子句</p>
<ul>
<li>在方法签名后指定 where 子句</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(a: T, b: U) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, a.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 notify 函数签名中有一串很长的 trait 签名约束，这就会导致看起来很复杂并且也不美观，这时候我们可以使用 where 子句来简化 trait 约束</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T, U&gt;(a: T, b: U) -&gt; <span class="built_in">String</span> </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">	T: Summary + Display,</span><br><span class="line">	U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, a.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Trait-作为返回类型"><a href="#Trait-作为返回类型" class="headerlink" title="Trait 作为返回类型"></a>Trait 作为返回类型</h3></li>
<li><p>impl Trait 语法</p>
<ul>
<li>注意：impl Trait 只能返回确定的同一种类型，返回可能不同类型的代码会报错</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">    NewsArticle &#123;</span><br><span class="line">        headline: <span class="built_in">String</span>::from(<span class="string">&quot;Penguins win the Stanley Cup Championship!&quot;</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">&quot;The Pittsburgh once again are the best hockey team in the NHL.&quot;</span>),</span><br><span class="line">        author: <span class="built_in">String</span>::from(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">        location: <span class="built_in">String</span>::from(<span class="string">&quot;Pittsburgh, PA, USA&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-Trait-Bound-有条件的实现方法"><a href="#使用-Trait-Bound-有条件的实现方法" class="headerlink" title="使用 Trait Bound 有条件的实现方法"></a>使用 Trait Bound 有条件的实现方法</h3><ul>
<li><p>在使用泛型参数的 impl 块上使用 Trait bound，我们可以有条件的为实现特定 Trait 的类型来实现方法</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T, y: T) -&gt; <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>( x, y )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pair 泛型中是 Display 与 PartialOrd  Trait，才可以使用 cmp_display 方法</span></span><br><span class="line"><span class="keyword">impl</span> &lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cmp_display</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>也可以为实现了其它 Trait 的任意类型有条件的实现某个 Trait</p>
</li>
<li><p>为满足 Trait Bound 的所有类型上实现 Trait 叫做覆盖实现（blanket implementations）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">&quot;rust1&quot;</span>, since = <span class="meta-string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: fmt::Display + ?<span class="built_in">Sized</span>&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> T &#123;</span><br><span class="line">    <span class="comment">// A common guideline is to not inline generic functions. However,</span></span><br><span class="line">    <span class="comment">// removing `#[inline]` from this method causes non-negligible regressions.</span></span><br><span class="line">    <span class="comment">// See &lt;https://github.com/rust-lang/rust/pull/74852&gt;, the last attempt</span></span><br><span class="line">    <span class="comment">// to try to remove it.</span></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    default <span class="function"><span class="keyword">fn</span> <span class="title">to_string</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">use</span> fmt::Write;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> buf = <span class="built_in">String</span>::new();</span><br><span class="line">        buf.write_fmt(<span class="built_in">format_args!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>))</span><br><span class="line">            .expect(<span class="string">&quot;a Display implementation returned an error unexpectedly&quot;</span>);</span><br><span class="line">        buf</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>Rust 的每个引用都有自己的生命周期</li>
<li>生命周期：引用保持有效的作用域</li>
<li>大多数情况：生命周期是隐式的、可被推断的</li>
<li>当引用的生命周期可能以不同的方式互相关联时：<strong>需要手动标注生命周期</strong></li>
</ul>
<h3 id="避免悬垂引用（dangling-reference）"><a href="#避免悬垂引用（dangling-reference）" class="headerlink" title="避免悬垂引用（dangling reference）"></a>避免悬垂引用（dangling reference）</h3><ul>
<li>生命周期的主要目标：避免悬垂引用（dangling reference）</li>
</ul>
<p>在 main 函数中有两个作用域，在第三行我们声明了一个r并未赋值（rust必须给变量赋值，不然运行不了），之后我们在进入了一个作用域，这里面声明了 x，然后将 x 引用赋值给了 r，出了作用域之后这次 x 就被回收了，这里还会出现一个错误就是我们借用了被销毁的变量，编译器会提示我们不能这样做。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> r;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">            r = &amp;x; <span class="comment">//出了变量域之后，x就被销毁了，同时x的引用也不可用了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="借用检查器"><a href="#借用检查器" class="headerlink" title="借用检查器"></a>借用检查器</h3><ul>
<li>Rust 编译器的借用检查器：比较作用域来判断所有借用是否合法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> r = &amp;x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数中的泛型生命周期"><a href="#函数中的泛型生命周期" class="headerlink" title="函数中的泛型生命周期"></a>函数中的泛型生命周期</h3><p>以下代码会报错，这个函数的返回类型包含一个借用的值，但是函数的签名没有说明这个借用的值是来自x还是来自y，可以考虑引入一个命名的生命周期参数</p>
<blockquote>
<p>  –&gt; src/main.rs:31:33<br>   |<br>31 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {<br>   |               —-     —-     ^ expected named lifetime parameter<br>   |<br>   = help: this function’s return type contains a borrowed value, but the signature does not say whether it is borrowed from <code>x</code> or <code>y</code><br>help: consider introducing a named lifetime parameter<br>   |<br>31 | fn longest&lt;’a&gt;(x: &amp;’a str, y: &amp;’a str) -&gt; &amp;’a str {<br>   |           ^^^^    ^^^^^^^     ^^^^^^^     ^^^</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> result = longest(string1.as_str(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(x: &amp;<span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们根据提示，来修改一个函数的签名，此时会出现一个问题就是编译器无法确定 longest 函数返回的是x还是y，如果我们将 ‘a 修饰某个函数参数，那么代码依旧会报原先的错误（无论这里返回的是x还是y），此时需要使用 ‘a 来修饰两个变量参数</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> result = longest(string1.as_str(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生命周期标注-语法"><a href="#生命周期标注-语法" class="headerlink" title="生命周期标注-语法"></a>生命周期标注-语法</h3><ul>
<li>生命周期的标注不会改变引用的生命周期长度</li>
<li>当指定了泛型生命周期参数，函数可以接收带有任何生命周期的引用</li>
<li><strong>生命周期的标注：描述了多个引用的生命周期间的关系，但不影响生命周期</strong></li>
<li>生命周期参数名<ul>
<li>以 ‘ 开头</li>
<li>通常全小写且非常短</li>
<li>很多人使用 ‘a</li>
</ul>
</li>
<li>生命周期标注的位置<ul>
<li>在引用的 &amp; 符号后</li>
<li>使用空格将标注和引用类型分开</li>
</ul>
</li>
</ul>
<h3 id="生命周期标注-例子"><a href="#生命周期标注-例子" class="headerlink" title="生命周期标注-例子"></a>生命周期标注-例子</h3><ul>
<li><code>&amp;i32</code>：一个引用</li>
<li><code>&amp;&#39;a i32</code>：带有显式生命周期的引用</li>
<li><code>&amp;&#39;a mut i32</code>：带有显式生命周期的可变引用</li>
<li>单个生命周期标注本身没有意义</li>
</ul>
<h3 id="函数签名中的生命周期标注"><a href="#函数签名中的生命周期标注" class="headerlink" title="函数签名中的生命周期标注"></a>函数签名中的生命周期标注</h3><ul>
<li>泛型生命周期参数声明在：函数名和参数列表之间的 &lt;&gt; 里</li>
<li>生命周期 ‘a 的实际生命周期是：x和y两个生命周期中较小的那个</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深入理解生命周期"><a href="#深入理解生命周期" class="headerlink" title="深入理解生命周期"></a>深入理解生命周期</h3><ul>
<li><p>指定生命周期参数的方式依赖于函数所做的事情</p>
<blockquote>
<p>下面例子，通过 longest 函数我们只返回 x，所以就不需要 y 的生命周期了</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> result = longest(string1.as_str(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期匹配</p>
</li>
<li><p>如果返回的引用没有指向任何参数，那么它只能引用函数内创建的值</p>
<ul>
<li>这就是悬垂引用：该值在函数结束就走出了作用域</li>
</ul>
<blockquote>
<p>下面例子返回了一个悬垂引用，编译时会报错，不能返回一个悬垂引用</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> result = longest(string1.as_str(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">String</span>::from(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    result.as_str()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要在函数内部创建值，那么只需要返回对象的本身就行了，也就是说我们不需要返回引用，只需要返回对象的所有权，返回之后这对象内存也就由函数的调用者来进行清理了</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">String</span>::from(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Struct-定义中的生命周期标注"><a href="#Struct-定义中的生命周期标注" class="headerlink" title="Struct 定义中的生命周期标注"></a>Struct 定义中的生命周期标注</h3></li>
<li><p>Struct 里可包括</p>
<ul>
<li>自持有的类型</li>
<li>引用：需要在每个引用上添加生命周期标注</li>
</ul>
</li>
</ul>
<p><code>ImportExcerpt</code> 需要比 part 字段生命周期长，这样 part 才可以持有更长时间</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportExcerpt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> novel = <span class="built_in">String</span>::from(<span class="string">&quot;Call mew Ishmael, Some years ago...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 得到 &amp;str 引用</span></span><br><span class="line">    <span class="keyword">let</span> first_sentence = novel.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    	.next()</span><br><span class="line">    	.expect(<span class="string">&quot;Could not found a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> i = ImportExcerpt &#123;</span><br><span class="line">        part: first_sentence</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生命周期的省略"><a href="#生命周期的省略" class="headerlink" title="生命周期的省略"></a>生命周期的省略</h3><ul>
<li>每个引用都有生命周期</li>
<li>需要为使用生命周期的函数或 struct 指定生命周期参数</li>
</ul>
<p>这段代码在早期的 rust 的编译器中是无法编译通过的，因为我们返回的是一个引用，我们需要显式的在函数签名上标注生命周期，但是 rust 开发团队发现很多开发者在开发中，大量重复去标注生命周期，这使得 rust 开发团队就将一些标注的规则直接写入到编译器中，面对有的场景，开发者就不需要标注生命周期，在编译期间编译器就帮你做了</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生命周期省略规则"><a href="#生命周期省略规则" class="headerlink" title="生命周期省略规则"></a>生命周期省略规则</h3><ul>
<li>在 Rust 引用分析中所编入的模式称为生命周期省略规则<ul>
<li>这些规则无需开发者来遵守</li>
<li>它们是一些特殊情况，由编译器来考虑</li>
<li>如果你的代码符合这些情况，那么就无需显式标注生命周期</li>
</ul>
</li>
<li>生命周期省略规则不会提供完整的推断<ul>
<li>如果应用规则后，引用的生命周期仍然模糊不清<strong>则会编译错误</strong></li>
<li>解决办法：添加生命周期标注，表明引用间的相互关系</li>
</ul>
</li>
</ul>
<h3 id="输入、输出生命周期"><a href="#输入、输出生命周期" class="headerlink" title="输入、输出生命周期"></a>输入、输出生命周期</h3><ul>
<li>函数/方法的参数：输入生命周期</li>
<li>函数/方法的返回值：输出生命周期</li>
</ul>
<h3 id="生命周期省略的三个规则"><a href="#生命周期省略的三个规则" class="headerlink" title="生命周期省略的三个规则"></a>生命周期省略的三个规则</h3><ul>
<li>编译器使用 3 个规则在没有显式标注生命周期的情况下，来确定的引用的生命周期<ul>
<li>规则1应用于输入生命周期</li>
<li>规则2、3应用于输出生命周期</li>
<li>如果编译器应用完3个规则之后，仍然有无法确定生命周期的引用<strong>则会报错</strong></li>
<li>这些规则适用于 fn 定义和 impl 块</li>
</ul>
</li>
<li>规则1：每个引用类型的参数都有自己的生命周期</li>
<li>规则2：如果只有1个输入生命周期参数，那么该生命周期被赋给所有输出生命周期参数</li>
<li>规则3：如果有多个输入生命周期参数，但其中一个是 &amp;self 或 &amp;mut self（是方法），那么 self 的生命周期会被赋给所有的输出生命参数</li>
</ul>
<h3 id="生命周期省略的三个规则-例子"><a href="#生命周期省略的三个规则-例子" class="headerlink" title="生命周期省略的三个规则-例子"></a>生命周期省略的三个规则-例子</h3><blockquote>
<p>假设我们是编译器，编译器在编译期间会对生命周期做什么</p>
</blockquote>
<ul>
<li><p><code>fn first_word(s: &amp;str) -&gt; &amp;str &#123;</code></p>
<ul>
<li><code>fn first_word&lt;&#39;a&gt;(s: &amp;&#39;a str) -&gt; &amp;str &#123;</code>：规则1</li>
<li><code>fn first_word&lt;&#39;a&gt;(s: &amp;‘a str) -&gt; &amp;’a str &#123;</code>：规则2</li>
</ul>
</li>
<li><p><code>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;</code></p>
<ul>
<li><code>fn longest&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;str &#123;</code>：规则1（每个函数参数都有自己的生命周期）</li>
</ul>
<p>在应用规则1之后，编译器为x与y添加了生命周期，因为函数参数有两个生命周期所有第2条与第3条生命周期也不适用了，那么此时编译器就会报错，面对这种情况我们就需要显示的去生命周期了。 <code>fn longest&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;&#39;a str &#123;</code>，需要在函数返回值签名上声明返回的生命周期</p>
</li>
</ul>
<h3 id="方法定义中的生命周期标注"><a href="#方法定义中的生命周期标注" class="headerlink" title="方法定义中的生命周期标注"></a>方法定义中的生命周期标注</h3><ul>
<li>在 struct 上使用生命周期实现方法，语法和泛型参数的语法一样</li>
<li>在那声明和使用生命周期参数，依赖于：<ul>
<li>生命周期参数是否和字段、方法的参数或返回值有关</li>
</ul>
</li>
<li>struct 字段的生命周期名<ul>
<li>在 impl 后声明</li>
<li>在 struct 名后使用</li>
<li>这些生命周期是 struct 类型的一部分</li>
</ul>
</li>
<li>impl 块内的方法签名中：<ul>
<li><strong>引用</strong>必须绑定于 struct 字段引用的生命周期，或者<strong>引用</strong>是独立的也可以</li>
<li>生命周期省略规则经常使得方法中的生命周期标注不是必须的</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportExcerpt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">level</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 会应用第3条规则</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">announce_and_return_part</span></span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h3><ul>
<li>‘static 是一个特殊的生命周期：整个程序的持续时间<ul>
<li>例如：所有的字符串字面值都拥有 ‘static 生命周期<ul>
<li><code>let s: &amp;&#39;static str = &quot;I have a static lifetime&quot;;</code></li>
</ul>
</li>
</ul>
</li>
<li>为引用指定 ‘static 生命周期前要三思<ul>
<li>是否需要引用在程序整个生命周期内都存活</li>
</ul>
</li>
</ul>
<h3 id="泛型参数类型、Trait-Bound、生命周期"><a href="#泛型参数类型、Trait-Bound、生命周期" class="headerlink" title="泛型参数类型、Trait Bound、生命周期"></a>泛型参数类型、Trait Bound、生命周期</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest_with_an_announcement</span></span>&lt;<span class="symbol">&#x27;a</span>, T&gt; </span><br><span class="line">	(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, ann: T) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann)</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 学习笔记：第9章 错误的处理</title>
    <url>/2021/06/12/Rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC9%E7%AB%A0-%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="panic"><a href="#panic" class="headerlink" title="panic!"></a>panic!</h2><blockquote>
<p>不可恢复的错误</p>
</blockquote>
<h3 id="Rust-错误处理概述"><a href="#Rust-错误处理概述" class="headerlink" title="Rust 错误处理概述"></a>Rust 错误处理概述</h3><blockquote>
<p>Java 通过try-catch 来处理错误，而在 Rust 并没有类似的异常机制</p>
</blockquote>
<ul>
<li>Rust  的可靠性：错误处理<ul>
<li>大部分情况下：在编译时提示错误，并处理 <a id="more"></a></li>
</ul>
</li>
<li>错误的分类<ul>
<li>可恢复<ul>
<li>例如文件未找到，可再次尝试</li>
</ul>
</li>
<li>不可恢复<ul>
<li>bug，例如访问的索引超出了范围</li>
</ul>
</li>
</ul>
</li>
<li>Rust 没有类似异常的机制<ul>
<li>可恢复错误：<code>Result&lt;T, E&gt;</code></li>
<li>不可恢复：<code>panic!</code> 宏</li>
</ul>
</li>
</ul>
<h3 id="不可恢复错误与-panic"><a href="#不可恢复错误与-panic" class="headerlink" title="不可恢复错误与 panic!"></a>不可恢复错误与 panic!</h3><ul>
<li>当 panic! 宏执行<ul>
<li>你的程序会打印一个错误信息</li>
<li>展开（unwind）、清理调用栈（stack）</li>
<li>退出程序</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 执行之后程序会发生 panic</span></span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash and nurn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="展开或中止（abort）调用栈"><a href="#展开或中止（abort）调用栈" class="headerlink" title="展开或中止（abort）调用栈"></a>展开或中止（abort）调用栈</h3><ul>
<li><p>默认情况下，当 panic 发生</p>
<ul>
<li>程序展开调用栈（工作量大）<ul>
<li>Rust 沿着调用栈往回走</li>
<li>清理每个遇到的函数中的数据</li>
</ul>
</li>
<li>或立即中止调用栈<ul>
<li>不进行清理，直接停止程序</li>
<li>程序内存需要 OS 进行清理</li>
</ul>
</li>
</ul>
</li>
<li><p>想让二进制文件更小，把设置从 “展开” 改为 “中止”</p>
<ul>
<li>在 Cargo.toml 中适当的 profile 部分设置<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span>=<span class="string">&#x27;abort&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="使用-panic-产生的回溯信息"><a href="#使用-panic-产生的回溯信息" class="headerlink" title="使用 panic! 产生的回溯信息"></a>使用 panic! 产生的回溯信息</h3><ul>
<li>panic! 可能会出现在<ul>
<li>我们写的代码中</li>
<li>我们所依赖的代码中</li>
</ul>
</li>
<li>可通过调用 panic! 的函数的回溯信息来定位引起问题的代码</li>
<li>通过设置环境变量 RUST_BACKTRACE 可得到回溯信息</li>
<li>为了获取带有调式信息的回溯，必须启动调试符号（不带 <code>--release</code>）</li>
</ul>
<h2 id="Result-与可恢复的错误"><a href="#Result-与可恢复的错误" class="headerlink" title="Result 与可恢复的错误"></a>Result 与可恢复的错误</h2><h3 id="Result-枚举"><a href="#Result-枚举" class="headerlink" title="Result 枚举"></a>Result 枚举</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>T：操作成功情况下，OK 变体里返回的数据的类型</li>
<li>E：操作成功情况下，Err 变体里返回的错误的类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 返回的是 Result 类型</span></span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理-Result-的一种方式：match-表达式"><a href="#处理-Result-的一种方式：match-表达式" class="headerlink" title="处理 Result 的一种方式：match 表达式"></a>处理 Result 的一种方式：match 表达式</h3><ul>
<li>和 Option 枚举一样，Result 及其变体也是有 prelude 带入作用域</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> file = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Error opening file &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配不同的错误"><a href="#匹配不同的错误" class="headerlink" title="匹配不同的错误"></a>匹配不同的错误</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> file = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(error) =&gt; <span class="keyword">match</span> error.kind() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::create(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="literal">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="literal">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Error createing file &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Error opening file &#123;:?&#125;&quot;</span>, other_error);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面例子使用了很多 match</li>
<li>match 很有用，但是很原始</li>
<li>闭包（closure），Result&lt;T, E&gt; 有很多方法<ul>
<li>它们接收闭包作为参数</li>
<li>使用 match 实现</li>
<li>使用这些方法会让代码更简洁</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>).unwrap_or_else(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.kind() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::create(<span class="string">&quot;hello.txt&quot;</span>).unwrap_or_else(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Error createing file &#123;:?&#125;&quot;</span>, error)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Error opening file &#123;:?&#125;&quot;</span>, error)</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unwrap"><a href="#unwrap" class="headerlink" title="unwrap"></a>unwrap</h3><ul>
<li>unwrap：match 表达式的一个快捷方法<ul>
<li>如果 Result 结果是 OK，返回 OK 里面的值</li>
<li>如果 Result 结果是 Err，调用 panic! 宏</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>).unwrap();</span><br><span class="line">    <span class="comment">// let f = File::open(&quot;hello.txt&quot;).unwrap();.expect(&quot;无法打开文件&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传播错误"><a href="#传播错误" class="headerlink" title="传播错误"></a>传播错误</h3><ul>
<li> 以前都是在函数中处理错误</li>
<li>现在将错误返回给调用者</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    <span class="keyword">match</span> f.read_to_string(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(_) =&gt; <span class="literal">Ok</span>(s),</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    read_username_from_file();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="? 运算符"></a>? 运算符</h3><blockquote>
<p><strong><code>?</code> 运算符只能用于返回 Result 的函数</strong></p>
</blockquote>
<ul>
<li>? 运算符：传播错误的一种快捷方式</li>
<li>如果 Result 是 Ok：Ok 中的值就是表达式的结果，然后继续执行程序</li>
<li>如果 result 是 Err：Err 就是整个函数的返回值，就像使用了 return</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    f.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = read_username_from_file();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果觉得上述的方式太繁琐，那么可以将代码改成链式调用的方式</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    File::open(<span class="string">&quot;hello.txt&quot;</span>)?.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = read_username_from_file();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="与-from-函数"><a href="#与-from-函数" class="headerlink" title="? 与 from 函数"></a>? 与 from 函数</h3><ul>
<li>Trait <code>std::convert::From</code> 上的 from 函数<ul>
<li>用于错误之间的转换</li>
</ul>
</li>
<li>被 ? 所应用的错误，会隐式的被 from 函数处理</li>
<li>当 ?  调用from函数时<ul>
<li>它所接收的错误类型会被转化为当前函数返回类型所定义的错误类型</li>
</ul>
</li>
<li>用于：针对不同错误原因，返回同一种错误类型<ul>
<li>只要每个错误类型实现了转换为所返回的错误类型的 from 函数</li>
</ul>
</li>
</ul>
<h3 id="运算符与-main-函数"><a href="#运算符与-main-函数" class="headerlink" title="? 运算符与 main 函数"></a>? 运算符与 main 函数</h3><ul>
<li><p>main 函数返回类型是：<code>()</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 编译不通过；?运算符只能用于 Result 返回值函数</span></span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>main 函数的返回类型也可以是：<code>Result&lt;T, E&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Box&lt;dyn Error&gt;</code> 是 trait 对象</p>
<ul>
<li>简单理解：任何可能的错误类型</li>
</ul>
</li>
</ul>
<h2 id="何时使用-panic"><a href="#何时使用-panic" class="headerlink" title="何时使用 panic!"></a>何时使用 panic!</h2><h3 id="总体原则"><a href="#总体原则" class="headerlink" title="总体原则"></a>总体原则</h3><ul>
<li>在定义一个可能失败的函数时，优先考虑返回 Result</li>
<li>否则就 panic!</li>
</ul>
<h3 id="编写示例、原型代码、测试"><a href="#编写示例、原型代码、测试" class="headerlink" title="编写示例、原型代码、测试"></a>编写示例、原型代码、测试</h3><ul>
<li>可以使用 panic!<ul>
<li>演示某些概念：unwrap</li>
<li>原型代码：unwrap、expect</li>
<li>测试：unwrap、expect</li>
</ul>
</li>
</ul>
<h3 id="肯定-Result-结果是-Ok"><a href="#肯定-Result-结果是-Ok" class="headerlink" title="肯定 Result 结果是 Ok"></a>肯定 Result 结果是 Ok</h3><ul>
<li>你可以确定 Result 就是 Ok：unwrap</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::IpAddr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> home: IpAddr = <span class="string">&quot;127.0.0.1&quot;</span>.parse().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误处理的指导性建议"><a href="#错误处理的指导性建议" class="headerlink" title="错误处理的指导性建议"></a>错误处理的指导性建议</h3><ul>
<li>当代码最终可能处于损坏状态时，最后使用 panic!</li>
<li>损坏状态（bad state）：某些假设、保证、约定或不可变性被打破<ul>
<li>例如非法的值、矛盾的值或空缺的值被传入代码</li>
<li>以及下列中的一条<ul>
<li>这种损坏状态并不是预期能够偶然发生的事情</li>
<li>在此之后，你的代码如果处于这种损坏状态就无法运行</li>
<li>在你使用的类型中没有一个好的方法来将这些信息（处于损坏状态）进行编码</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="场景建议"><a href="#场景建议" class="headerlink" title="场景建议"></a>场景建议</h3><ul>
<li>调用你的代码，传入无意义的参数值：panic!</li>
<li>调用外部不可控代码，返回非法错误，你无法修复：panic!</li>
<li>如果失败是可预期的：Result</li>
<li>当你的代码对值进行操作，首先应该验证这些值：panic!</li>
</ul>
<h3 id="为验证创建自定义类型"><a href="#为验证创建自定义类型" class="headerlink" title="为验证创建自定义类型"></a>为验证创建自定义类型</h3><ul>
<li>创建新的类型，把验证逻辑放在构造实例的函数里</li>
<li>getter：返回字段数据</li>
</ul>
<p>这种方式校验很简单，如果函数变多了，那么我们校验代码要重复很多，所以将验证逻辑放在构造实例函数中，会节省代码量。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> guess = <span class="string">&quot;32&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> guess: <span class="built_in">i32</span> = <span class="keyword">match</span> guess.trim().parse() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="literal">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> guess &lt; <span class="number">1</span> || guess &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The secret number will be between 1 and 100&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Guess</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置 private 不向外部直接暴露该字段，而是通过 getter 函数来暴露</span></span><br><span class="line">    value: <span class="built_in">i32</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Guess &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(value: <span class="built_in">i32</span>) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> guess &lt; <span class="number">1</span> || guess &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;The secret number will be between 1 and 100, got &#123;&#125;&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">value</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> guess = <span class="string">&quot;32&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> guess: <span class="built_in">i32</span> = <span class="keyword">match</span> guess.trim().parse() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="literal">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> guess = Guess::new(guess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 学习笔记：第8章 常用的集合</title>
    <url>/2021/06/12/Rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC8%E7%AB%A0-%E5%B8%B8%E7%94%A8%E7%9A%84%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul>
<li><code>Vec&lt;T&gt;</code>，叫做 vector<ul>
<li>由标准库提供</li>
<li>可存储多个值</li>
<li>只能存储相同类型的数据</li>
<li>值在内存中连续存放<a id="more"></a></li>
</ul>
</li>
</ul>
<h3 id="创建-Vector"><a href="#创建-Vector" class="headerlink" title="创建 Vector"></a>创建 Vector</h3><ul>
<li><p><code>Vec::new</code> 函数</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用初始值创建 <code>Vec&lt;T&gt;</code>，使用 <code>vec!</code> 宏</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新-Vector"><a href="#更新-Vector" class="headerlink" title="更新 Vector"></a>更新 Vector</h3></li>
<li><p>向 Vector 添加元素，使用 push 方法</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    v.push(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除-Vector"><a href="#删除-Vector" class="headerlink" title="删除 Vector"></a>删除 Vector</h3><ul>
<li>与任何其它 struct 一样，当 Vector 离开作用域后<ul>
<li>它就被清理掉了</li>
<li>它所有元素也被清理掉了</li>
</ul>
</li>
</ul>
<h3 id="读取-Vector-的元素"><a href="#读取-Vector-的元素" class="headerlink" title="读取 Vector 的元素"></a>读取 Vector 的元素</h3><ul>
<li>两种方式可以引用 Vector 里的值<ul>
<li>索引</li>
<li>get 方法</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="comment">// 索引</span></span><br><span class="line">    <span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get 方法，返回 Option&lt;T&gt;</span></span><br><span class="line">    <span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is not thord element&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历-Vector-中的值"><a href="#遍历-Vector-中的值" class="headerlink" title="遍历 Vector 中的值"></a>遍历 Vector 中的值</h3><ul>
<li>for 循环</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="comment">// 如果不使用引用的话，执行完for循环之后，Vector 所有权就会被移动</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">        <span class="comment">// * 解引用</span></span><br><span class="line">        *i += <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Vector-Enum-例子"><a href="#Vector-Enum-例子" class="headerlink" title="Vector + Enum 例子"></a>Vector + Enum 例子</h2><blockquote>
<p>使用 enum 来存储多种数据类型</p>
</blockquote>
<ul>
<li>Enum 的变体可以附加不同类型的数据</li>
<li>Enum 的变体定义在同一个 enum 类型下</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">    Int(<span class="built_in">i32</span>),</span><br><span class="line">    Flodat(<span class="built_in">f64</span>),</span><br><span class="line">    Text(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">        SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">        SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">        SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="Rust-开发者经常会被字符串困扰的原因"><a href="#Rust-开发者经常会被字符串困扰的原因" class="headerlink" title="Rust 开发者经常会被字符串困扰的原因"></a>Rust 开发者经常会被字符串困扰的原因</h3><ul>
<li>Rust 倾向于暴露可能的错误</li>
<li>字符串数据结构复杂</li>
<li>UTF-8</li>
</ul>
<h3 id="字符串是什么"><a href="#字符串是什么" class="headerlink" title="字符串是什么"></a>字符串是什么</h3><ul>
<li>Byte 的集合</li>
<li>提供了一些方法<ul>
<li>将 byte 解析成文本</li>
</ul>
</li>
<li>Rust 的核心语言层面，只有一个字符串类型，字符串切片 str（或&amp;str）</li>
<li>字符串切片：对存储在其他地方、UTF-8 编码的字符串的引用<ul>
<li>字符串字面值：存储在二进制文件中，也是字符串切片</li>
</ul>
</li>
<li>String 类型<ul>
<li>来自标准库，而不是核心语言</li>
<li>可增长、可修改、可拥有所有权</li>
<li>采用 UTF-8 编码</li>
</ul>
</li>
</ul>
<h3 id="通常说的字符串是指"><a href="#通常说的字符串是指" class="headerlink" title="通常说的字符串是指"></a>通常说的字符串是指</h3><ul>
<li>String 和 &amp;str<ul>
<li>标准库里用的多</li>
<li>UTF-8 编码</li>
</ul>
</li>
</ul>
<h3 id="其它类型的字符串"><a href="#其它类型的字符串" class="headerlink" title="其它类型的字符串"></a>其它类型的字符串</h3><ul>
<li>Rust 的标准库还包含了其它的字符串类型，例如：OsString、OsStr、CString、CStr<ul>
<li>String vs Str 后缀：拥有或借用的变体</li>
<li>可存储不同编码的文本或在内存中以不同的形式展现</li>
</ul>
</li>
<li>Libary crate （第三方库）针对存储字符串可提供更多的选项</li>
</ul>
<h3 id="创建一个新的字符串（String）"><a href="#创建一个新的字符串（String）" class="headerlink" title="创建一个新的字符串（String）"></a>创建一个新的字符串（String）</h3><ul>
<li><p>很多 <code>Vec&lt;T&gt;</code> 的操作都可用于 String</p>
</li>
<li><p><code>String::new</code> 函数</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用初始值来创建 String</p>
<ul>
<li><p><code>to_string()</code> 方法，可用于实现 Display trait 的类型，包括字符串字面值</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="string">&quot;initial contents&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> s = data.to_string();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="string">&quot;initial contents&quot;</span>.to_string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>String::from</code> 函数，从字面值创建 String</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;initial contents&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="更新-String"><a href="#更新-String" class="headerlink" title="更新 String"></a>更新 String</h3><ul>
<li><p><code>push_str()</code> 方法：把一个字符串切片附加到 String</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    s.push_str(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>push()</code> 方法：把单个字符附加到 String</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">    s.push(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>+</code>：连接字符串</p>
<ul>
<li><p>使用了类似这个签名的方法 <code>fn add(self, s: &amp;str) -&gt; String&#123;...&#125;</code></p>
<ul>
<li>标准库中的 add 方法使用了泛型</li>
<li>只能把 &amp;str 添加到 String</li>
<li>解引用强制转换（deref  coeracion）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// +前面是String，后面是引用，不能将两个String添加</span></span><br><span class="line">    <span class="keyword">let</span> s3 = s1 + &amp;s2;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s3);</span><br><span class="line">    <span class="comment">// 因为拼接字符串时采用String，所以s1不可用</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;&#125;&quot;, s1);</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>format!</code>：链接多个字符串</p>
<ul>
<li><p>和 <code>println!()</code> 方法一样，但返回的是字符串</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// let s3 = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;3;</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;&#125;&quot;, s3);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="String-按索引访问"><a href="#String-按索引访问" class="headerlink" title="String 按索引访问"></a>String 按索引访问</h3></li>
</ul>
</li>
<li><p>按索引语法访问 String 的某部分，会报错</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">let</span> s1 = s[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Rust 的字符串不支持索引语法访问</p>
</li>
</ul>
<h3 id="String-内部表示"><a href="#String-内部表示" class="headerlink" title="String 内部表示"></a>String 内部表示</h3><ul>
<li>String 是对 <code>Vec&lt;u8&gt;</code> 的包装<ul>
<li><code>len()</code> 方法返回 String 的字符数</li>
</ul>
</li>
</ul>
<blockquote>
<p>String 的字符索引并不一定能对上有效的字符</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> len = <span class="built_in">String</span>::from(<span class="string">&quot;hola&quot;</span>).len();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字节、标量值、字形簇"><a href="#字节、标量值、字形簇" class="headerlink" title="字节、标量值、字形簇"></a>字节、标量值、字形簇</h3><blockquote>
<p>Bytes，Scalar Values，Grapheme Clusters</p>
</blockquote>
<ul>
<li>Rust 有三种看待字符串的方式<ul>
<li>字节</li>
<li>标量值</li>
<li>字形簇（最接近所谓的 “字母”）</li>
</ul>
</li>
<li>Rust 不允许对 String 进行索引的最后一个原因<ul>
<li>索引操作应消耗一个常量时间<code>O(1)</code></li>
<li>而 String 无法保证：需要遍历所有内容，来确定有多少个合法的字符</li>
</ul>
</li>
</ul>
<h3 id="切割-String"><a href="#切割-String" class="headerlink" title="切割 String"></a>切割 String</h3><ul>
<li>可以使用 <code>[]</code> 和一个范围来创建字符串的切片<ul>
<li>必须谨慎使用</li>
<li>如果切割时跨越了字符边界，程序就会 panic</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> hello = <span class="string">&quot;你好世界&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">6</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个汉字3个字节，如果切割0到5程序就会panic</span></span><br><span class="line">    <span class="comment">// 这就是切割跨越了字符边界</span></span><br><span class="line">    <span class="comment">// let s = &amp;hello[0..5];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 你好</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历-String-的方法"><a href="#遍历-String-的方法" class="headerlink" title="遍历 String 的方法"></a>遍历 String 的方法</h3><ul>
<li>对于标量值：<code>chars()</code> 方法遍历</li>
<li>对于字节：<code>bytes()</code> 方法</li>
<li>对于字形簇：很复杂，标准库未提供</li>
</ul>
<h3 id="String-不简单"><a href="#String-不简单" class="headerlink" title="String 不简单"></a>String 不简单</h3><ul>
<li>Rust 选择将正确处理 String 数据作为所有 Rust 程序的默认行为<ul>
<li>程序员必须在处理 UTF-8 数据之前投入更多的精力</li>
</ul>
</li>
<li>可防止在开发后期处理涉及非 ASCII 字符的错误</li>
</ul>
<h2 id="HashMap-lt-K-V-gt"><a href="#HashMap-lt-K-V-gt" class="headerlink" title="HashMap&lt;K, V&gt;"></a>HashMap&lt;K, V&gt;</h2><ul>
<li>键值对的形式存储数据，一个键（key）对应一个值（Value）</li>
<li>Hash 函数：决定如何在内存中存储 K 和 V</li>
<li>适用场景：通过 K（任何类型）来寻找数据，而不是通过索引</li>
<li>HashMap 用的较少，不在 Prelude 中</li>
<li>标准库对其支持较少，没有内置的宏来创建 HashMap</li>
<li>数据存储在 heap 上</li>
<li>同构的，一个 HashMap 中<ul>
<li>所有的 K 必须时同一种类型</li>
<li>所有的 V 必须时同一种类型</li>
</ul>
</li>
</ul>
<h3 id="创建-HashMap"><a href="#创建-HashMap" class="headerlink" title="创建 HashMap"></a>创建 HashMap</h3><ul>
<li>创建空 HashMap：<code>new()</code> 函数</li>
<li>添加数据：<code>insert()</code> 方法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 使用 HashMap::new() 来创建 HashMap 时，需要使用限定 K V类型</span></span><br><span class="line">    <span class="comment">// 不限定，可以使用 insert 插入时，编译器会自动推导</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> scores: HashMap&lt;<span class="built_in">String</span>, <span class="built_in">i32</span>&gt; = HashMap::new();</span><br><span class="line">    scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="collect-方法创建-HashMap"><a href="#collect-方法创建-HashMap" class="headerlink" title="collect 方法创建 HashMap"></a>collect 方法创建 HashMap</h3><ul>
<li>在元素类型为 Tuple 的 Vector 上使用 collect 方法，可以组建一个 HashMap<ul>
<li>要求 Tuple 有两个值：一个作为 K，一个作为 V</li>
<li>collect 方法可以把数据整合成很多种集合类型，包括 HashMap<ul>
<li>返回值需要显式指定类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> teams = <span class="built_in">vec!</span>[<span class="built_in">String</span>.from(<span class="string">&quot;Blue&quot;</span>), <span class="built_in">String</span>::from(<span class="string">&quot;yellow&quot;</span>)];</span><br><span class="line">    <span class="keyword">let</span> intial_scores = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="comment">// teams 作为 k，intial_scores 作为 V</span></span><br><span class="line">    <span class="keyword">let</span> scores: HashMap&lt;_, _&gt; = teams.iter(intial_scores.iter()).collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap-和所有权"><a href="#HashMap-和所有权" class="headerlink" title="HashMap 和所有权"></a>HashMap 和所有权</h3><ul>
<li><p>对于实现了 Copy trait 的类型（例如 i32），值会被复制到 HashMap 中</p>
</li>
<li><p>对于拥有所有权的值（例如 String），值会被移动，所有权会转移给 HashMap</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> field_name = <span class="built_in">String</span>::from(<span class="string">&quot;Favorite color&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> field_value = <span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">    map.insert(field_name, field_value);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 会报错，因为 field_name 与 field_value 所有权交给了 HashMap</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, field_name, field_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果将值的引用插入到 HashMap ，值本身不会移动</p>
<ul>
<li>在 HashMap 有效的期间，被引用的值必须保持有效</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> field_name = <span class="built_in">String</span>::from(<span class="string">&quot;Favorite color&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> field_value = <span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">    map.insert(&amp;field_name, &amp;field_value);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, field_name, field_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="访问-HashMap-中的值"><a href="#访问-HashMap-中的值" class="headerlink" title="访问 HashMap 中的值"></a>访问 HashMap 中的值</h3><ul>
<li>get 方法<ul>
<li>参数：K</li>
<li>返回：Option&lt;&amp;V&gt;</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">    </span><br><span class="line">    scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> team_name = <span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> score = scores.get(&amp;team_name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">match</span> score &#123;</span><br><span class="line">        <span class="literal">Some</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s),</span><br><span class="line">        <span class="literal">None</span> =&gt; prtinln!(<span class="string">&quot;team not exist&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历-HashMap"><a href="#遍历-HashMap" class="headerlink" title="遍历 HashMap"></a>遍历 HashMap</h3><ul>
<li>for 循环</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">    </span><br><span class="line">    scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (k, v) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新-HashMap"><a href="#更新-HashMap" class="headerlink" title="更新 HashMap"></a>更新 HashMap</h3><ul>
<li>HashMap 大小可变</li>
<li>每个 K 同时只能对应一个 V</li>
<li>更新 HashMap 中的数据<ul>
<li>K 已经存在，对应一个 V<ul>
<li>替换现有的 V</li>
<li>保留现有的 V，忽略新的 V</li>
<li>合并现有的 V 和新的 V</li>
</ul>
</li>
<li>K 不存在<ul>
<li>添加一对新的 KV</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="替换现有的-V"><a href="#替换现有的-V" class="headerlink" title="替换现有的 V"></a>替换现有的 V</h4><p>如果向 HashMap 插入一对 KV，然后再插入同样的 K，但是不同的 V，那么原来的 V 会被替换掉</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">    </span><br><span class="line">    scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">25</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="K不对应任何值，才插入-V"><a href="#K不对应任何值，才插入-V" class="headerlink" title="K不对应任何值，才插入 V"></a>K不对应任何值，才插入 V</h4><ul>
<li>entry 方法：检查指定的 K 是否对应一个 V<ul>
<li>参数为 K</li>
<li>返回 enum Entry：代表值是否存在</li>
</ul>
</li>
<li>Entry 的 or_insert() 方法<ul>
<li>result：<ul>
<li>如果 K 存在，返回对应 V 的一个可变引用</li>
<li>如果 K 不存在，将方法参数作为 K 的新值插进去，返回这个值的可变引用</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">    </span><br><span class="line">    scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    scores.entry(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line">    scores.entry(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于现有V来更新V"><a href="#基于现有V来更新V" class="headerlink" title="基于现有V来更新V"></a>基于现有V来更新V</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> text = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">        Let count = map. entry(word).or_insert(<span class="number">0</span>);</span><br><span class="line">        * count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h3><ul>
<li>默认情况下，HashMap 使用加密功能强大的 Hash 函数，可以抵抗拒绝服务（Dos）攻击<ul>
<li>不是可用的最快的 Hash 算法</li>
<li>但具有更好安全性</li>
</ul>
</li>
<li>可以指定不同的 hasher 来切换成另一个函数<ul>
<li>hasher 是实现 BuildHasher trait 的类型</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 学习笔记：第7章 Package、Crate、Module</title>
    <url>/2021/06/10/Rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC7%E7%AB%A0-Package%E3%80%81Crate%E3%80%81Module/</url>
    <content><![CDATA[<h2 id="Package、Crate、定义-Module"><a href="#Package、Crate、定义-Module" class="headerlink" title="Package、Crate、定义 Module"></a>Package、Crate、定义 Module</h2><h3 id="Rust-的代码组织"><a href="#Rust-的代码组织" class="headerlink" title="Rust 的代码组织"></a>Rust 的代码组织</h3><ul>
<li>代码组织主要包括<ul>
<li>那些细节可以暴露，那些细节是私有的</li>
<li>作用域内那些名称有效<a id="more"></a></li>
<li>……</li>
</ul>
</li>
<li>模块系统<ul>
<li>Package（包）：Cargo 的特性，让你构建、测试、共享 crate</li>
<li>Crate（单元包）：一个模块树、它可产生一个 libary 或可执行文件</li>
<li>Module（模块）、use：让你控制代码的组织、作用域、私有路径</li>
<li>Path（路径）：为 struct、function 或 module 等项命名的方式</li>
</ul>
</li>
</ul>
<h3 id="Package-和-Crate"><a href="#Package-和-Crate" class="headerlink" title="Package 和 Crate"></a>Package 和 Crate</h3><ul>
<li>Crate 类型<ul>
<li>binary</li>
<li>libary</li>
</ul>
</li>
<li>Crate Root<ul>
<li>是源代码文件</li>
<li>Rust 编译器从这里开始，组成你的 Crate 的根 Module</li>
</ul>
</li>
<li>一个 Package<ul>
<li>包含一个 Cargo.toml，它描述了如何构建这些 Crates</li>
<li>只能包含 0-1 个 libary crate</li>
<li>可以包含任意数量的 binary crate</li>
<li>但必须至少包含一个 crate（libary 或 binary）</li>
</ul>
</li>
</ul>
<h3 id="Cargo-的惯例"><a href="#Cargo-的惯例" class="headerlink" title="Cargo 的惯例"></a>Cargo 的惯例</h3><ul>
<li>使用 <code>cargo new project-name</code> 创建 Rust 项目</li>
<li><code>src/main.rs</code><ul>
<li>binary crate 的 crate root</li>
<li>crate 名与 package 名相同</li>
</ul>
</li>
<li><code>src/lib.rs</code><ul>
<li>package 包含一个 libary crate</li>
<li>libary crate 的 crate root</li>
<li>crate 名与 package 名相同</li>
</ul>
</li>
<li>Cargo 把 crate root 文件交给 rustc 来构建 libary 或 binary</li>
<li>一个 Package 可以同时包含 src/main.rs 和 src/lib.rs<ul>
<li>一个 binary crate，一个 libary crate</li>
</ul>
</li>
</ul>
<h3 id="Crate-的作用"><a href="#Crate-的作用" class="headerlink" title="Crate 的作用"></a>Crate 的作用</h3><ul>
<li>将相关功能组合到一个作用域内，便于在项目间进行共享<ul>
<li>防止命名冲突</li>
</ul>
</li>
<li>例如 rand crate，访问它的功能需要通过它的名字：rand</li>
</ul>
<h3 id="定义-Module-来控制作用域和私有性"><a href="#定义-Module-来控制作用域和私有性" class="headerlink" title="定义 Module 来控制作用域和私有性"></a>定义 Module 来控制作用域和私有性</h3><ul>
<li>Module<ul>
<li>在一个 crate 内，将代码进行分组</li>
<li>增加可读性，易于复用</li>
<li>控制项目（item）的私有性，public、private</li>
</ul>
</li>
<li>建立 Module<ul>
<li>mod 关键字</li>
<li>可嵌套</li>
<li>可包含其它项（struct、enum、常量、trait、函数等）的定义</li>
</ul>
</li>
</ul>
<blockquote>
<p>src/lib.rs 文件内容</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">task_order</span></span>() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">serve_order</span></span>() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><ul>
<li><code>src/main.rs</code> 和 <code>src/lib.rs</code> 叫做 crate roots<br> * 这两个文件（任意一个）的内容形成了名为 crate 的模块，位于整个模块树的根部</li>
</ul>
<p><img src="images/Snipaste_2021-06-10_23-34-57.png" alt="Snipaste_2021-06-10_23-34-57"></p>
<h2 id="路径（Path）"><a href="#路径（Path）" class="headerlink" title="路径（Path）"></a>路径（Path）</h2><ul>
<li>为了在 Rust 的模块中找到某个条目，需要使用路径</li>
<li>路径的两种形式<ul>
<li>绝对路径：从 crate root 开始，使用 crate 名或字面值 crate</li>
<li>相对路径：从当前模块开始，使用 self，super 或当前模块标识符</li>
</ul>
</li>
<li>路径至少由一个标识符组成，标识符之间使用 <code>::</code></li>
</ul>
<p>在 <code>src/lib.rs</code> 文件中有如下的内容，我们创建了一个 front_of_hours 模块，在该模块中有一个 hosting 子模块并包含了 add_to_waitlist 函数，之后我们使用绝对路径与相对路径来进行调用。在项目中使用绝对路径还是相对路径取决于代码的条目。</p>
<blockquote>
<p>下面代码会报错，因为 mod 是私有的</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_hours &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径调用</span></span><br><span class="line">    crate::front_of_hours::hosting::add_to_waitlist();</span><br><span class="line">    <span class="comment">// 相对路径调用</span></span><br><span class="line">    front_of_hours::hosting::add_to_waitlist(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="私有边界（privacy-boundary）"><a href="#私有边界（privacy-boundary）" class="headerlink" title="私有边界（privacy boundary）"></a>私有边界（privacy boundary）</h3><ul>
<li>模块不仅可以组织代码，还可以定义私有边界</li>
<li>如果想把函数或 struct 等设为私有，可以将它放在某个模块中</li>
<li>Rust 中所有的条目（函数、方法、struct、enum、模块、常量）默认是私有的</li>
<li>父级模块无法访问子模块中的私有条目</li>
<li>子模块里可以使用所有祖先模块中的条目</li>
</ul>
<h3 id="pub-关键字"><a href="#pub-关键字" class="headerlink" title="pub 关键字"></a>pub 关键字</h3><ul>
<li>使用 pub 关键字来来将某些条目标记为公共的</li>
</ul>
<p>下面代码将 hosting 模块与 add_to_waitlist 函数定义为 pub，代码就可以正常的执行了，这会产生一个疑问，为什么 front_of_hours 是私有的，而 hosting 是公有的，它们还可以正常调用呢？因为调用方都是该文件里面的根级，如果都是文件根级，那么它们之间就可以互相调用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_hours &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径调用</span></span><br><span class="line">    crate::front_of_hours::hosting::add_to_waitlist();</span><br><span class="line">    <span class="comment">// 相对路径调用</span></span><br><span class="line">    front_of_hours::hosting::add_to_waitlist(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><ul>
<li>super：用来访问父级模块路径中的内容，类似文件系统的 <code>..</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">serve_order</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fix_incrrect_order</span></span>() &#123;</span><br><span class="line">        cook_order();</span><br><span class="line">        super::serve_order();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cook_order</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pub-struct"><a href="#pub-struct" class="headerlink" title="pub struct"></a>pub struct</h3><ul>
<li>pub 放在 struct 前<ul>
<li>struct 是公共的</li>
<li>struct 的字段默认是私有的</li>
</ul>
</li>
<li>struct 的字段需要单独设置 pub 来变成共有</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Breakfast</span></span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="built_in">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="built_in">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">impl</span> Breakfast &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">summer</span></span>(toast: &amp;<span class="built_in">str</span>) -&gt; Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="built_in">String</span>::from(toast),</span><br><span class="line">                seasonal_fruit: <span class="built_in">String</span>::from(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> meal = back_of_house::Breakfast::summer(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    meal.toast = <span class="built_in">String</span>::from(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;d like &#123;&#125; toast please&quot;</span>, meal.toast);</span><br><span class="line">    <span class="comment">// 因为 seasonal_fruit 不是 pub，所以无法访问该字段</span></span><br><span class="line">    <span class="comment">// meal.seasonal_fruit = String::from(&quot;blueberries&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pub-enum"><a href="#pub-enum" class="headerlink" title="pub enum"></a>pub enum</h3><ul>
<li>pub 放在 enum  前<ul>
<li>enum 是公共的</li>
<li>enum 的变体也都是公共的</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Appetizer</span></span> &#123;</span><br><span class="line">        Soup,</span><br><span class="line">        Salad,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="use-关键字"><a href="#use-关键字" class="headerlink" title="use 关键字"></a>use 关键字</h2><ul>
<li><p>可以使用 use 关键字将路径导入到作用域内</p>
<ul>
<li>仍遵循私有性规则，不可以调用私有函数</li>
</ul>
</li>
<li><p>使用 use 来指定相对路径</p>
<blockquote>
<p>把 crate 去掉就可以了；<code>use front_of_hours::hosting;</code></p>
</blockquote>
</li>
</ul>
<p>使用 use 关键字引入一个模块时，我们一样无法调用该模块中的私有函数。</p>
<p>当然我们也可以引入函数，比如 <code>use crate::front_of_hours::hosting::add_to_waitlist;</code> 之后通过 <code>add_to_waitlist</code> 直接调用即可，但是这种做法是有弊的，如果我们引入的函数很多，那么分不清该函数处于那个模块中，一般情况下都是来引入函数父模块。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_hours &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 hosting 模块引入到了当前作用域</span></span><br><span class="line"><span class="comment">// hosting 在当前作用域内就可以使用了</span></span><br><span class="line"><span class="keyword">use</span> crate::front_of_hours::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="use-的习惯用法"><a href="#use-的习惯用法" class="headerlink" title="use 的习惯用法"></a>use 的习惯用法</h3><ul>
<li><p>函数：将函数的父级模块引入作用域（指定到父级）</p>
</li>
<li><p>struct、enum、其它：指定完整路径（指定到本身）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">    map.insert(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同名条目：指定到父级</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f1</span></span>() -&gt; fmt::<span class="built_in">Result</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f2</span></span>() -&gt; io::<span class="built_in">Result</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="as-关键字"><a href="#as-关键字" class="headerlink" title="as 关键字"></a>as 关键字</h3><ul>
<li>as 关键字可以为引入的路径指定本地的别名</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f1</span></span>() -&gt; <span class="built_in">Result</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f2</span></span>() -&gt; IoResult &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pub-use"><a href="#pub-use" class="headerlink" title="pub use"></a>pub use</h3><ul>
<li>使用 use 将路径（名称）导入到作用域内后，该名称在此作用域内是私有的</li>
<li>pub use：重导出<ul>
<li>将条目引入作用域</li>
<li>该条目可以被外部代码引入到它们的作用域</li>
</ul>
</li>
</ul>
<p>下面我们将 hosting 模块引入，hosting 在此作用域中是可用的，外部代码是看不见的，对于函数我们可以加上 pub 关键字来实现，而 use 也能通过加上 pub 关键字，这样外部代码就可以访问到了 hosting 模块（引入了 hosting ，然后又把它给导出了），当我们相对外暴露代码的时候，就可以使用 <code>pub use</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_hours &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_hours::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用外部包"><a href="#使用外部包" class="headerlink" title="使用外部包"></a>使用外部包</h3><ul>
<li>Cargo.toml 添加依赖包（package）<ul>
<li>cargo 会从 <a href="https://crates.io/">https://crates.io</a> 下载可用的 package</li>
</ul>
</li>
<li>use 将特定条目引入作用域</li>
<li>标准库（std）也被当做外部包<ul>
<li>不需要修改 Cargo.toml 来包含 std</li>
<li>需要使用 use 将 std 中特定条目引入到当前作用域</li>
</ul>
</li>
</ul>
<blockquote>
<p>Cargo.toml</p>
</blockquote>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.5.5&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rang;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>


<h3 id="修改-cargo-镜像源"><a href="#修改-cargo-镜像源" class="headerlink" title="修改 cargo 镜像源"></a>修改 cargo 镜像源</h3><ol>
<li>linux 使用 <code>which cargo</code> 命令找到  cargo 位置</li>
<li>windows 使用 <code>where cargo</code> 命令找到 cargo 位置</li>
<li>进入到对应的 <code>.cargo</code> 目录下</li>
<li>新建/修改config 文件，添加如下内容</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;crates.io-index&quot;</span><br><span class="line"># 指定镜像</span><br><span class="line">replace-with &#x3D; &#39;tuna&#39;</span><br><span class="line"></span><br><span class="line"># 清华大学</span><br><span class="line">[source.tuna]</span><br><span class="line">registry &#x3D; &quot;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;crates.io-index.git&quot;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套路径"><a href="#嵌套路径" class="headerlink" title="嵌套路径"></a>嵌套路径</h3><blockquote>
<p>使用嵌套路径清理大量的 use 语句</p>
</blockquote>
<ul>
<li>如果使用同一个包或模块下的多个条目</li>
<li>可使用嵌套路径在同一行内将上述条目进行引入<ul>
<li><strong>路径相同的部分::{路径差异的部分}</strong></li>
</ul>
</li>
<li>如果两个 use 路径之一是另一个子路径<ul>
<li>使用 self </li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们需要使用 std::io 与 std::io::Write 包，那么需要这样使用</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io&#123;<span class="keyword">self</span>, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通配符（-）"><a href="#通配符（-）" class="headerlink" title="通配符（*）"></a>通配符（*）</h3><ul>
<li>使用 <code>*</code> 可以把路径中所有的公共条目都引入到作用域</li>
<li>这种方式需要谨慎使用</li>
<li>应用场景：<ul>
<li>测试，将所有被测试代码引入到 tests 模块</li>
<li>有时被用于预导入（prelude）模块</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将模块拆分为不同文件"><a href="#将模块拆分为不同文件" class="headerlink" title="将模块拆分为不同文件"></a>将模块拆分为不同文件</h2><blockquote>
<p>在 rust 中可以将模块内容移动到其他文件</p>
</blockquote>
<ul>
<li>模块定义时，如果模块名后边是 <code>;</code> ，而不是代码块<ul>
<li>Rust 会从与模块同名的文件中加载内容</li>
<li>模块树的结构不会发生变化</li>
</ul>
</li>
<li>随着模块逐渐变大，该技术让你可以把模块的内容移动到其它文件中</li>
</ul>
<p>使用了 <code>;</code> 那么就会在 src 目录下找到对应名称的 rs 文件，也就是说 使用<code>mod front_of_hours;</code> 后会在 src 目录下找到 <code>front_of_hours.rs</code> 文件。</p>
<blockquote>
<p>src/lib.rs</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_hours;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_hours::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>src/front_of_hours.rs</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们需要将 hosting 模块分离出来话，那么需要在 src 下创建 front_of_hours 文件夹，之后创建 <code>hosting.rs</code></p>
<blockquote>
<p>src/lib.rs</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_hours;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_hours::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>src/front_of_hours.rs</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>src/front_of_hours/hosting.rs</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 学习笔记：第6章 枚举与模式匹配</title>
    <url>/2021/06/10/Rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC6%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h3><ul>
<li>枚举允许我们列举所有可能的值来定义一个类型</li>
</ul>
<blockquote>
<p>定义一个 IP 地址（IPv4、IPv6）的枚举</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="创建枚举值"><a href="#创建枚举值" class="headerlink" title="创建枚举值"></a>创建枚举值</h3><blockquote>
<p>枚举名加上<code>::</code>再加上值就可以创建枚举值</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> four = IpAddrKind::V4;</span><br><span class="line"><span class="keyword">let</span> six = IpAddrKind::V6;</span><br></pre></td></tr></table></figure>
<h3 id="枚举作为函数参数"><a href="#枚举作为函数参数" class="headerlink" title="枚举作为函数参数"></a>枚举作为函数参数</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> four = IpAddrKind::V4;</span><br><span class="line">    <span class="keyword">let</span> six = IpAddrKind::V6;</span><br><span class="line">    </span><br><span class="line">    route(four);</span><br><span class="line">    route(six);</span><br><span class="line">    route(IpAddrKind::V6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">route</span></span>(ip_kind: IpAddrKind) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据附加到枚举的变体中"><a href="#数据附加到枚举的变体中" class="headerlink" title="数据附加到枚举的变体中"></a>数据附加到枚举的变体中</h3><ul>
<li>不需要额外使用 struct</li>
<li>每个变体可以拥有不同的类型以及关联的数据量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> home = IpAddrKind::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> loopback = IpAddrKind::V6(<span class="built_in">String</span>::from(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123;x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>&#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> q = Message::Quit;</span><br><span class="line">    <span class="keyword">let</span> m = Message::Move &#123;x: <span class="number">12</span>, y: <span class="number">24</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> w = Message::write(<span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> c = Message::ChangeColor(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为枚举定义方法"><a href="#为枚举定义方法" class="headerlink" title="为枚举定义方法"></a>为枚举定义方法</h3><ul>
<li>使用 <code>impl</code> 关键字</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">	Quit,</span><br><span class="line">	Move &#123;x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>&#125;,</span><br><span class="line">	Write(<span class="built_in">String</span>),</span><br><span class="line">	ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Message &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> q = Message::Quit;</span><br><span class="line">	<span class="keyword">let</span> m = Message::Move &#123;x: <span class="number">12</span>, y: <span class="number">24</span>&#125;;</span><br><span class="line">	<span class="keyword">let</span> w = Message::write(<span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">	<span class="keyword">let</span> c = Message::ChangeColor(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">	m.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Option-枚举"><a href="#Option-枚举" class="headerlink" title="Option 枚举"></a>Option 枚举</h2><ul>
<li>定义于标准库中</li>
<li>在 Prelude（预导入模块）中</li>
<li>描述了：某个值可能存在（某种类型）或不存在的情况</li>
</ul>
<p>在 Rust 中没有 Null，在其他语言中，Null 是一个值，它表示“没有值”，一个变量可以处于两种状态：空值（null）、非空。Null 的问题在于：当你尝试像使用非 Null 值那种使用 Null 值的时候，就会引起某种错误；但是 Null 的概念还是有用的，描述了某种原因而变为无效或缺失的值。Rust 中提供了类似 Null 概念的枚举：<code>Option&lt;T&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>Option</code> 枚举直接包含在 Prelude（预导入模块）中，所以可以直接使用</p>
<ul>
<li><code>Option&lt;T&gt;</code></li>
<li><code>Some(T)</code></li>
<li><code>None</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> some_string = <span class="literal">Some</span>(<span class="string">&quot;A String&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为使用 None 时，编译器无法推导 Option 里面的 T 是什么类型类型的，所以需要显式的声明</span></span><br><span class="line">    <span class="keyword">let</span> absent_number: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Option-lt-T-gt-VS-Null"><a href="#Option-lt-T-gt-VS-Null" class="headerlink" title="Option&lt;T&gt; VS  Null"></a><code>Option&lt;T&gt;</code> VS  Null</h3><ul>
<li><code>Option&lt;T&gt;</code> 和 T 是不同的类型，不可以把 <code>Option&lt;T&gt;</code> 直接当成 T </li>
<li>若想使用 <code>Option&lt;T&gt;</code> 中的 T，必须将它转换为 T</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i8</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y: <span class="built_in">Option</span>&lt;<span class="built_in">i8</span>&gt; = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不能相加，需要将 y 转为 i8 才可以</span></span><br><span class="line">    <span class="keyword">let</span> sum = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><blockquote>
<p>强大的控制流运算符 - match</p>
</blockquote>
<ul>
<li>允许一个值与一系列模式进行匹配，并执行匹配的模式对应的代码</li>
<li>模式可以是字面值、变量名、通配符…</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绑定值的模式"><a href="#绑定值的模式" class="headerlink" title="绑定值的模式"></a>绑定值的模式</h3><ul>
<li>匹配分支可以绑定到被匹配对象的部分值<ul>
<li>因此，可以从 <code>enum</code> 变体中提取值</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabma,</span><br><span class="line">    Alaska,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;state quarter from: &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = Coin::Quarter(UsState::Alaska);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, value_in_cents(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配-Option-lt-T-gt"><a href="#匹配-Option-lt-T-gt" class="headerlink" title="匹配 Option&lt;T&gt;"></a>匹配 <code>Option&lt;T&gt;</code></h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> six = plus_one(five);</span><br><span class="line">    <span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>match 匹配的时候必须穷举所有的可能，在上述的例子中，如果在 match 中少写了 None 条件，那么代码就会报错（<code>non-exhaustive patterns: &#39;Nong&#39; not covered</code>），所以 match 必须穷举所有可能，才能确保代码的有效。</p>
<p>我们可以使用 <code>_</code> 通配符，来代替其余没有列出的值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="number">0u8</span>;</span><br><span class="line">    <span class="keyword">match</span> v &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;five&quot;</span>),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;seven&quot;</span>),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a>if let</h2><ul>
<li>处理只关心一种匹配而忽略其它匹配的情况</li>
<li>更少的代码、更少的缩进、更少的模版代码</li>
<li>放弃了穷举的可能</li>
<li>可以把 if let 看作是 match 的语法糖</li>
<li>if let 也可以搭配 else 来进行使用</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="literal">Some</span>(<span class="number">0u8</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;others&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码等价于下列的代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="literal">Some</span>(<span class="number">0u8</span>);</span><br><span class="line">    <span class="keyword">match</span> v &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;others&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 学习笔记：第5章 struct</title>
    <url>/2021/06/09/Rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC5%E7%AB%A0-struct/</url>
    <content><![CDATA[<h2 id="定义并实例化-struct"><a href="#定义并实例化-struct" class="headerlink" title="定义并实例化 struct"></a>定义并实例化 struct</h2><p>struct 中文名称是 结构体，可以自定义数据类型，为相关联的值命名，并打包成有意义的组合</p>
<h3 id="定义-struct"><a href="#定义-struct" class="headerlink" title="定义 struct"></a>定义 struct</h3><ul>
<li>使用 <code>struct</code> 关键字，并为整个 struct 命名</li>
<li>在花括号内，为所有字段（Field）定义名称与类型<a id="more"></a>

</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例化-struct"><a href="#实例化-struct" class="headerlink" title="实例化 struct"></a>实例化 struct</h3><ul>
<li>想要使用 struct，需要创建 struct 的实例<ul>
<li>为每个字段指定具体值</li>
<li>无需按声明的顺序进行指定</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = User&#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">&quot;some@example.com&quot;</span>),</span><br><span class="line">    usernmae: <span class="built_in">String</span>::from(<span class="string">&quot;someusernmae123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="取得-struct-里面某个值"><a href="#取得-struct-里面某个值" class="headerlink" title="取得 struct 里面某个值"></a>取得 struct 里面某个值</h3><ul>
<li>使用点标记法</li>
</ul>
<p>为 user 的某个字段赋予新值，需要在实例化时为 user 加上 <code>mut</code> 关键字，然后使用点标记就可以赋值</p>
<blockquote>
<p>一旦 struct 的实例是可变的，那么实例中所有的字段都是可变的</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> user1 = User&#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">&quot;some@example.com&quot;</span>),</span><br><span class="line">    usernmae: <span class="built_in">String</span>::from(<span class="string">&quot;someusernmae123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user1.email = <span class="built_in">String</span>::from(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="struct-作为函数的返回值"><a href="#struct-作为函数的返回值" class="headerlink" title="struct 作为函数的返回值"></a>struct 作为函数的返回值</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User&#123;</span><br><span class="line">        email: email,</span><br><span class="line">        usernmae: username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字段初始化简写"><a href="#字段初始化简写" class="headerlink" title="字段初始化简写"></a>字段初始化简写</h3><ul>
<li>当字段名与字段值对应变量相同时，就可以使用该字段初始化简写方式</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, usernmae: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User&#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="struct-更新语法"><a href="#struct-更新语法" class="headerlink" title="struct 更新语法"></a>struct 更新语法</h3><ul>
<li>当你基于某个 struct 实例来创建一个新实例的时候，可以使用 struct 更新语法</li>
</ul>
<blockquote>
<p>不使用更新语法</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = User&#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">&quot;another@axmple.com&quot;</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">&quot;anotherusername567&quot;</span>),</span><br><span class="line">    active: user1.active,</span><br><span class="line">    sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用更新语法</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">&quot;another@axmple.com&quot;</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">&quot;anotherusername567&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Tuple-struct"><a href="#Tuple-struct" class="headerlink" title="Tuple struct"></a>Tuple struct</h3><ul>
<li>可定义类似 tuple 的 struct，叫做 tuple struct<ul>
<li>tuple struct 整体有个名，但里面的元素没有名</li>
<li>适用：想给整个 tuple 起名，并让它不同于其它 tuple，而且又不需要给每个元素起名</li>
</ul>
</li>
<li>定义 tuple struct： 使用 struct 关键字，后面是名字，以及里面元素的类型</li>
</ul>
<blockquote>
<p>black 和 origin 是不同的类型，是不同 tuple struct 的实例</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> orign = Ponit(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Unit-Like-Struct（没有任何字段）"><a href="#Unit-Like-Struct（没有任何字段）" class="headerlink" title="Unit-Like Struct（没有任何字段）"></a>Unit-Like Struct（没有任何字段）</h3><ul>
<li>可以定义没有任何字段的 struct，叫做 Unit-Like struct（因为与()， 单元类型类似）</li>
<li>适用于需要在某个类型上实现某个 trait，但是在里面又没有想要存储的数据</li>
</ul>
<h3 id="struct-数据的所有权"><a href="#struct-数据的所有权" class="headerlink" title="struct 数据的所有权"></a>struct 数据的所有权</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这里的字段使用了 String 而不是 &amp;str</p>
<ul>
<li>该 struct 实例拥有其所有的数据</li>
<li>只要 struct 实例是有效的，那么里面的字段数据也是有效的</li>
</ul>
</li>
<li><p>struct 里也可以存放引用，但这需要使用生命周期</p>
<ul>
<li>生命周期保证只要 struct 实例是有效的，那么里面的引用也是有效的</li>
<li>如果 struct 里面存储引用，而不使用生命周期，就会报错<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    username: &amp;<span class="built_in">str</span>,</span><br><span class="line">    email: &amp;<span class="built_in">str</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">        email: <span class="string">&quot;fdas&quot;</span>,</span><br><span class="line">        usernmae: <span class="string">&quot;fda&quot;</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">556</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h2 id="struct-例子"><a href="#struct-例子" class="headerlink" title="struct 例子"></a>struct 例子</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    length: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        length: <span class="number">50</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, area(&amp;rect));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, rect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(rect: &amp;Rectangle) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    rect.width * rect.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="struct-方法"><a href="#struct-方法" class="headerlink" title="struct 方法"></a>struct 方法</h2><ul>
<li>方法和函数类似：<code>fn</code> 关键字、名称、参数、返回值</li>
<li>方法与函数不同之处<ul>
<li>方法是在struct（或<code>enum</code>、trait对象）的上下文中定义</li>
<li>第一个参数是 self，表示方法被调用的 struct 实例</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    length: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        length: <span class="number">50</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rect.area());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, rect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>impl</code> 块里定义方法</li>
<li>方法的第一个参数可以是 &amp;self，也可以获得其所有权或可变借用（<code>&amp;mut self</code>），和其他参数一样</li>
</ul>
<h3 id="方法调用的运算符"><a href="#方法调用的运算符" class="headerlink" title="方法调用的运算符"></a>方法调用的运算符</h3><ul>
<li>C/C++：object-&gt;something() 和 (*object).something() 一样</li>
<li>Rust 没有 <code>-&gt;</code> 运算符</li>
<li>Rust 会自动引用和解引用<ul>
<li>在调用方法时就会发生这种行为</li>
</ul>
</li>
<li>在调用方法时，Rust 根据情况自动添加 &amp;、<code>&amp;mut</code> 或 *，以便 object 可以匹配方法的签名</li>
<li>下面两行代码效果相同<ul>
<li><code>p1.distance(&amp;2);</code></li>
<li><code>(&amp;p1).distance(&amp;p2)</code></li>
</ul>
</li>
</ul>
<h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><ul>
<li>方法可以有多个参数</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    length: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.length &gt; other.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        length: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> rect2 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        length: <span class="number">40</span>,</span><br><span class="line">    &#125;;    </span><br><span class="line">    <span class="keyword">let</span> rect3 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">35</span>,</span><br><span class="line">        length: <span class="number">55</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rect1.can_hold(&amp;rect2));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rect1.can_hold(&amp;rect3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h3><ul>
<li>可以在 <code>impl</code> 快里定义不把 self 作为第一个参数的函数，他们叫关联函数（并不是方法）<ul>
<li>例如：<code>String::from()</code></li>
</ul>
</li>
<li>关联函数通常用于构造器</li>
<li><code>::</code>符号<ul>
<li>关联函数</li>
<li>模块创建的命名空间</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    length: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.length &gt; other.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            length: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = Rectangle::square(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多个-impl-块"><a href="#多个-impl-块" class="headerlink" title="多个 impl 块"></a>多个 <code>impl</code> 块</h3><ul>
<li>每个 struct 允许拥有多个 <code>impl</code> 块</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    length: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.length &gt; other.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            length: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = Rectangle::square(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 学习笔记：第4章 所有权</title>
    <url>/2021/06/09/Rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC4%E7%AB%A0-%E6%89%80%E6%9C%89%E6%9D%83/</url>
    <content><![CDATA[<p>所有权是 Rust 最独特的特性，它让 Rust 无需 GC 就要可以保证内存安全</p>
<h2 id="什么是所有权"><a href="#什么是所有权" class="headerlink" title="什么是所有权"></a>什么是所有权</h2><ul>
<li>Rust 的核心特性就是所有权</li>
<li>所有程序在运行时都必须管理它们使用计算机内存的方式<ul>
<li>有些语言有垃圾收集机制，在程序运行时，它们会不断地寻找不再使用内存</li>
<li>在其它语言中，程序员必须显式地分配和释放内存<a id="more"></a></li>
</ul>
</li>
<li>Rust 采用第三种方式<ul>
<li>Rust 内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则</li>
<li>当程序运行时，所有权特性不会减慢程序的运行速度</li>
</ul>
</li>
</ul>
<h2 id="Stack-vs-Heap"><a href="#Stack-vs-Heap" class="headerlink" title="Stack vs Heap"></a>Stack vs Heap</h2><ul>
<li>在像 Rust 这样的系统编程语言里，一个值是在 stack 上还是在 heap 上对语言的行为和你为什么要做某些决定是有更大的影响的</li>
<li>在你的代码运行的时候，Stack 和 Heap 都是你可用的内存，但他们的结构很不相同</li>
</ul>
<h3 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h3><ul>
<li>Stack 按值的接收顺序来存储，按相反的顺序将他们移除（后进后出 LIFO）<ul>
<li>添加数据叫做压入栈</li>
<li>移除数据叫做弹出栈</li>
</ul>
</li>
<li>所有存储在 Stack 上的数据必须拥有已知固定的大小<ul>
<li>编译时大小未知的数据或运行时大小可用发生变化的数据必须存储在 heap 上</li>
</ul>
</li>
<li>Heap 内存组织性差一些<ul>
<li>当你把数据放入 heap 时，你会请求一定数量的空间</li>
<li>操作系统在 heap 里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址</li>
</ul>
</li>
<li>把值压到 Stack 上不叫分配</li>
<li>因为指针是已知固定大小的，可以把指针存放在 stack 上<ul>
<li>但如果想要实际数据，你必须使用指针来定位</li>
</ul>
</li>
<li>把数据压到 stack 上要比在 heap 上分配快得多<ul>
<li>因为操作系统不需要寻找存储新数据的空间，那个位置永远都在 stack 的顶端</li>
</ul>
</li>
<li>在 heap 上分配空间需要做更多的工作<ul>
<li>操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配</li>
</ul>
</li>
</ul>
<h3 id="访问数据"><a href="#访问数据" class="headerlink" title="访问数据"></a>访问数据</h3><ul>
<li><p>访问 heap 中的数据要比访问 stack 中的数据慢，因为需要通过指针才能找到 heap 中的数据</p>
<ul>
<li><strong>对于现在处理的来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快</strong></li>
</ul>
</li>
<li><p>如果数据存放的距离比较近，那么处理器的处理速度就会更快一些（stack上）</p>
</li>
<li><p>如果数据之间的举例比较远，那么处理速度就会慢一些（heap上）</p>
<blockquote>
<p>在 heap 存储的数据可能在分散在不同的地址上，通过指针来定位heap数据，那么要进行一个寻址的操作；如果数据存放在 stack 连续的内存上，那么直接通过一个偏移量就能拿到数据</p>
</blockquote>
</li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><ul>
<li>当你的代码调用函数时，值被传入到函数（也包括指向 heap 的指针）。函数本地的变量被压到 stack 上。当函数结束时，这些值会从 stack 上弹出</li>
</ul>
<h3 id="所有权存在的原因"><a href="#所有权存在的原因" class="headerlink" title="所有权存在的原因"></a>所有权存在的原因</h3><ul>
<li>所有权解决的问题<ul>
<li>跟踪代码的那些部分正在使用 heap 的那些数据</li>
<li>最小化 heap 上的重复数据量</li>
<li>清理 heap 上未使用的数据以避免不足</li>
</ul>
</li>
<li>一旦懂了所有权，那么就不需要经常去想 stack 或 heap 了</li>
<li>但是知道管理 heap 数据是所有权存在的原因，这有助于解释它为什么这样工作</li>
</ul>
<h2 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h2><ul>
<li>每个值都有一个变量，这个变量是该值的所有者</li>
<li>每个值同时只能有一个所有者</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// s 不可用</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span>;	<span class="comment">// s 可用</span></span><br><span class="line">    					<span class="comment">// 可以对 s 进行相关操作</span></span><br><span class="line">&#125;<span class="comment">// s 作用域到此结束，s 不再可用</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当前 s 存放在栈上</p>
</blockquote>
<h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><ul>
<li>String 比那些基础标量数据类型更复杂</li>
<li>字符串字面值：程序里手写的那些字符串值，它们是不可变的</li>
<li>Rust 还有第二种字符串类型：String</li>
</ul>
<h4 id="创建-String-类型的值"><a href="#创建-String-类型的值" class="headerlink" title="创建 String 类型的值"></a>创建 String 类型的值</h4><ul>
<li><p>可以使用 from 函数从字符串字面值创建出 String 类型</p>
</li>
<li><p><code>let s = String::from(&quot;hello&quot;);</code></p>
<ul>
<li><code>::</code> 表示 from 是 String 类型下的函数</li>
</ul>
</li>
<li><p>这类字符串是可以被修改的</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s.push_str(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>为什么 String 类型的值可以修改，而字符串字面值去而不能修改</p>
<ul>
<li>因为它们处理内存的方式不同</li>
</ul>
</li>
</ul>
<h3 id="内存和分配"><a href="#内存和分配" class="headerlink" title="内存和分配"></a>内存和分配</h3><ul>
<li><p>字符串字面值，在编译时就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里</p>
<ul>
<li>速度快、高效、是因为其不可变性</li>
</ul>
</li>
<li><p>String 类型，为了支持可变性，需要在 heap 上分配内存来保存编译时未知的文本内容</p>
<ul>
<li><p>操作系统必须在运行时来请求内存</p>
<blockquote>
<p>这步通过调用 String::from 来实现</p>
</blockquote>
</li>
<li><p>当用完 String 之后，需要使用某种方式将内存返回给操作系统</p>
<ul>
<li>这步，在拥有 GC 的语言中，GC 会跟踪并清理不再使用的内存</li>
<li>没有 GC，就需要我们去是被内存何时不再使用，并调用代码将它返回<ul>
<li>如果忘了，那就浪费内存</li>
<li>如果提前做了，变量就会非法</li>
<li>如果释放两次，也是 BUG，必须一次分配对应一次释放</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Rust 采用不同的方式；对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的交还给操作系统</p>
</li>
<li><p>drop 函数</p>
</li>
</ul>
<h3 id="变量和数据交互的方式：移动（move）"><a href="#变量和数据交互的方式：移动（move）" class="headerlink" title="变量和数据交互的方式：移动（move）"></a>变量和数据交互的方式：移动（move）</h3><ul>
<li><p>多个变量可以与同一数据使用一种独特的方式来交互</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br></pre></td></tr></table></figure>
<p>line2 将 x 赋值给了 y，此时这里创建了一个 x 的副本把值赋值给了 y  </p>
</li>
<li><p>整数是已知且固定大小的简单的值，这两个5被压到了 stack 中</p>
</li>
</ul>
<p>  <strong>移动：String 版本</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br></pre></td></tr></table></figure>
<p>一个 String 由 3 部分组成</p>
<ol>
<li>指向存放字符串内容的内存指针</li>
<li>一个长度</li>
<li>一个容量</li>
</ol>
<p>上面这些东西放在 stack 上，存放字符串内容的部分在 heap 上；长度 len，就是存放字符串内容所需的字节数；容量 capacity 是指 String 从操作系统总共获得内存的总字节数。</p>
<p>当把 s1 赋给 s2，String 的数据被复制了一份，在 stack 上复制了一份指针、长度、容量；并没有复制指针所指向的 heap 上的数据</p>
<p><img src="images/Snipaste_2021-06-06_22-51-29.png" alt="Snipaste_2021-06-06_22-51-29"></p>
<p>当变量离开作用域时，Rust 会自动调用 drop 函数，并将变量使用的 heap 内存释放。</p>
<p>当 s1、s2 离开作用域时，它们都会尝试释放相同的内存，此时就会导致二次释放的（double free）Bug，可能会导致正在使用的数据损坏（第一次释放后，系统将释放后的内存分配给其它数据，如果在进行二次释放就会导致数据被擦除了），从而导致安全隐患。</p>
<p>Rust 为了保证内存安全，并没有尝试复制被分配的内存，而是 Rust 让 s1 失效，当 s1 离开作用域的时候，Rust 不需要释放任何东西。当 s2 创建之后，再去使用 s1 就会出现 <code>borrow of moved value</code> 错误</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of s1 is: &#123;&#125;&quot;</span>, s1);</span><br></pre></td></tr></table></figure>
<p>你也许会将赋值指针、长度、容量视为浅拷贝，但是由于 Rust 让 s1 失效了，所以我们用一个新的术语：移动（move）。当s1赋值给s2时，s1就失效了，离开作用域时，就会将 s2 给释放，从而避免了二次释放。这里隐含了一个设计原则：Rust 不会自动创建数据的深拷贝。也就是说，就运行时性能而言，任何自动赋值的操作都是廉价的。</p>
<p><img src="images/Snipaste_2021-06-06_23-01-00.png" alt="Snipaste_2021-06-06_23-01-00"></p>
<h3 id="变量和数据交互的方式：克隆（Clone）"><a href="#变量和数据交互的方式：克隆（Clone）" class="headerlink" title="变量和数据交互的方式：克隆（Clone）"></a>变量和数据交互的方式：克隆（Clone）</h3><p>如果真想对 heap 上面的 String 数据进行深度拷贝，而不仅仅是 stack 上的数据，可以使用 clone 方法</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> s2 = s1.clone();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clone 方法相当于把 s1 的 stack 还是 heap 上的数据都完整的复制了一份，但是 clone 操作时比较消耗资源的。</p>
<p><img src="images/Snipaste_2021-06-06_23-12-27.png" alt="Snipaste_2021-06-06_23-12-27"></p>
<p>而这种 clone 主要针对 heap 上的数据，针对 stack 上的数据则不需要 clone，直接<strong>复制</strong>就可以了。如下面例子所示，把 x 复制给  y 之后，x 与 y 都是有效的，这是因为 x 是整数类型，而整数类型在编译时就确定了自己的大小，也能将自己的数据完整的存储在 stack 中，对于这些值的复制操作永远都是非常快速的，这也同样意味着创建变量 y 之后，我们没有任何理由去阻止变量 x 继续保持有效。换句话说，对于这些类型而言深拷贝与浅拷贝并没有任何区别，调用 clone 方法并不会与直接的浅拷贝有任何的行为区别，因此我们不需要在类似的场景中考虑上述的问题。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust 提供了一个 Copy trait ，可以用于像整数这样完全存放在 stack 上面的类型，如果一个类型实现了 Copy 这个 trait，那么旧的变量在赋值后仍然可用；如果一个类型或者该类型的一部分实现了 Drop trait，那么 Rust 不允许让它再去实现 Copy trait 了，否则编译时就会报错。</p>
<p><strong>拥有 Copy trait 的类型</strong></p>
<ol>
<li><p>任何简单标量的组合类型都是可以实现 Copy 的</p>
</li>
<li><p>任何需要分配内存或某种资源都不是 Copy 的</p>
</li>
<li><p>拥有 Copy trait 类型</p>
<ol>
<li><p>所有的整数类型，例如 u32</p>
</li>
<li><p>bool</p>
</li>
<li><p>char</p>
</li>
<li><p>所有的浮点类型，例如 f64</p>
</li>
<li><p>Tuple（元组），如果 Tuple 所有的字段都是可以 copy 的，那么这个 tuple 也是拥有 copy trait 类型</p>
<blockquote>
<p>[i32, i32] 是、[i32, String] 不是</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h2><ul>
<li>在语义上，将值传递给函数和把值赋给变量是类似的<ul>
<li>将值传递给函数将发生移动或复制</li>
</ul>
</li>
</ul>
<p>下面例子 s 传递给了 take_ownership 函数，该 s 的所有权发生改变，此后在 main 方法中 s 处于不可用。之后将x的值传递给了 makes_copy 函数，因为 x 是一个整数类型，所以这里进行了复制的操作（传给该函数是一个 x 副本），所以 x 还是有效的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    take_ownership(s);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    makes_copy(x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">take_owership</span></span>(some_string: <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">makes_copy</span></span>(some_number: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a>返回值与作用域</h3><ul>
<li><p><strong>函数在返回值的过程中同样也会发生所有权的转移</strong></p>
<p>第2行调用了 gives_owership 函数，在该函数里面创建了一个 String，之后将 String 返回，当函数返回时，会将 some_string 作用域交由 main 函数。</p>
<p>第3行创建了一个 String，之后调用 takes_and_gives_back 函数将该 String 传递过去，所以 s2 的所有权发生了变化，之后在 takes_and_gives_back 函数中又将 String 返回回来，这时候就把 some_string 所有权交到 main 函数中，也就是归于 s3 进行管理，最后 main 函数执行之后就将 s1、s3 销毁（因为s2所有权已经发生变化，销毁时不需要进行任何操作）</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = gives_owership();</span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> s3 = takes_and_gives_back(s2);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gives_owership</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> some_string = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    some_string </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(a_string: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    a_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个变量的所有权总是遵循同样的模式</p>
<ul>
<li>把一个值赋给其它变量时就会发生移动</li>
<li>当一个包含 heap 数据的变量离开作用域时，它的值就会被 drop 函数清理，除非数据的所有权移动到另一个变量上了</li>
</ul>
</li>
</ul>
<p><strong>如何让函数使用某个值，但不获得其所有权？</strong></p>
<p>第2行创建了一个 String，之后调用 calculate_length 函数将 s1 传入，在该函数中获取 s1 的 length ，函数返回了一个元组存放者 s1 的长度与String，因为 length 是一个整数类型所以返回的是一个副本，而 s 是一个对象，这里返回的是所以权，最后到达了main函数，此时的 s2与len都是可用的，这种实现方式有一定的复杂性，可以通过传递引用方式来实现。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> (s2, len) = calculate_length(s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回一个元组 tuple</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: <span class="built_in">String</span>) -&gt; (<span class="built_in">String</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> length = s.len();</span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> len = calculate_length(&amp;<span class="keyword">mut</span> s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h2><ul>
<li>参数的类型是 &amp;String 而不是 String</li>
<li>&amp; 符号就表示引用：允许你引用某些值而不取得其所有权</li>
</ul>
<p><img src="images/Snipaste_2021-06-07_08-31-59.png" alt="Snipaste_2021-06-07_08-31-59"></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为该函数并不拥有s1的所有权，所以函数执行后不需要去释放s1</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123; </span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="借用"><a href="#借用" class="headerlink" title="借用"></a>借用</h3><ul>
<li>我们把引用作为函数这个行为叫做借用</li>
<li>不可以修改借用的东西</li>
<li>和变量一样，引用默认也是不可变的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123; </span><br><span class="line">    s.push_str(<span class="string">&quot;, world&quot;</span>); <span class="comment">// 会报错</span></span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h3><ul>
<li><p>可变引用有一个重要的限制：在特定作用域内，对某一块数据，只能有一个可变的引用</p>
<blockquote>
<p>这样做的好处可以在编译时防止数据竞争</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 main 函数中存在多个 s 的可变引用，所以报错</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> s1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="keyword">let</span> s2 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以下三种行为同时满足可能会发生数据竞争</p>
<blockquote>
<p>数据竞争在运行时很难发现，所以 Rust 在编译期间就解决了这个问题，如果满足了这三种情况，那么就编译期间就会报错</p>
</blockquote>
<ul>
<li>两个或多个指针同时访问同一个数据</li>
<li>至少有一个指针用于写入数据</li>
<li>没有使用任何机制来同步对数据的访问</li>
</ul>
</li>
<li><p>可以通过创建新的作用域，来允许非同时的创建多个可变引用</p>
<blockquote>
<p>通过不同的作用域来创建多个可变引用；s1与s2不在同一个作用域中，s1当第5行执行完后就被销毁了</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> s1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> s2 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不可以同时拥有一个可变引用和一个不变引用</p>
<blockquote>
<p>因为可变引用是可以改变值的，而不变引用意味着这个值是不可变的，所以一旦允许这两个引用同时存在，可变引用把这个值改变之后，那么不变引用的作用完全失效了；如果只存在多个不变引用是可以的</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译期间会报错</span></span><br><span class="line"><span class="comment">// cannot borrow &#x27;s&#x27; as mutable because it is also borrowed as immutable</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> s1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, r1, r2, s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="悬空引用-Dangling-References"><a href="#悬空引用-Dangling-References" class="headerlink" title="悬空引用 Dangling References"></a>悬空引用 Dangling References</h3><ul>
<li>悬空指针（Dangling Pointer）：一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其他人使用了</li>
<li>在 Rust 里，编译器可保证应用永远都不是悬空引用<ul>
<li>如果你引用了某些数据，编译器将保证在引用离开作用域之前不会离开作用域</li>
</ul>
</li>
</ul>
<p>下面的例子，dangle 函数返回了 String 引用，因为 Rust 执行 dangle 函数之后，s 的作用域就被销毁了，之后在返回一个 s 的引用，就会导致悬空引用发生，而 Rust 在编译期间就防止了这种情况。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> r = dangle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a>引用的规则</h3><ul>
<li>在任何给定的时刻，只能满足下列条件之一<ul>
<li>一个可变的引用</li>
<li>任意数量不可变的引用</li>
</ul>
</li>
<li>引用必须一直有效</li>
</ul>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><ul>
<li>Rust 的另外一种不持有所有权的数据类型：切片（slice）</li>
</ul>
<h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><ul>
<li>字符串切片是指向字符串中一部分的引用</li>
<li>形式：[开始索引..结束索引]<ul>
<li>开始索引就是切片起始位置的索引值</li>
<li>结束索引是切片终止位置的下一个索引值</li>
</ul>
</li>
</ul>
<p><img src="images/Snipaste_2021-06-08_10-30-39.png" alt="Snipaste_2021-06-08_10-30-39"></p>
<blockquote>
<p><code>[..]</code>指向整个字符串的切片</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> hello = &amp;s[<span class="number">0</span>..<span class="number">5</span>];  <span class="comment">// ..5</span></span><br><span class="line">    <span class="keyword">let</span> world = &amp;s[<span class="number">6</span>..<span class="number">11</span>]; <span class="comment">//6..   6..s.len()</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, hello, world);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>字符串字面值是切片，字符串字面值被直接存储在二进制程序中</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将字符串切片作为参数传递，有经验的 Rust 开发者会采用 &amp;str 作为参数类型，因为这样就可以同时接收 String 和 &amp;str 类型的参数</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; &amp;<span class="built_in">str</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用字符串切片，直接调用该函数</li>
<li>使用 String，可以创建一个完整的 String 切片来调用该函数</li>
</ul>
<p>定义函数时，使用字符串切片来代替字符串引用会使我们的 API 更加通用，且不会损失任何功能</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> my_string = <span class="built_in">String</span>::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> wordIndex = first_word(&amp;my_string[..]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> my_string_literal = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> wordIndex = first_word(my_string_literal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="其他类型切片"><a href="#其他类型切片" class="headerlink" title="其他类型切片"></a>其他类型切片</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> slice = &amp;a[<span class="number">1</span>..<span class="number">3</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 学习笔记：第3章 通用的编程概念</title>
    <url>/2021/06/09/Rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC3%E7%AB%A0-%E9%80%9A%E7%94%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h2><ul>
<li><p>声明变量使用 let 关键字</p>
</li>
<li><p>默认情况下，变量是不可变的（Immutable）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x =<span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>声明变量时，在变量前面加上 <code>mut</code> 关键字，就可以使变量可变</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

</li>
</ul>
<h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><ul>
<li>常量（constant），常量在绑定值以后也是不可变的，但是它与不可变的变量有很多区别<ul>
<li>不可以使用 <code>mut</code>，常量永远都是不可变的</li>
<li>声明常量使用 <code>const</code> 关键字，它的类型必须被标注</li>
<li>常量可以在任何作用域内进行声明，包括全局作用域</li>
<li>常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值</li>
</ul>
</li>
<li>在程序运行期间，常量在其声明的作用域内一直有效</li>
<li>命名规范：Rust 里常量使用全大写字母，每个单词之间用下划线分开</li>
</ul>
<h2 id="Shadowing（隐藏）"><a href="#Shadowing（隐藏）" class="headerlink" title="Shadowing（隐藏）"></a>Shadowing（隐藏）</h2><ul>
<li><p>可以使用相同的名字声明新的变量，新的变量就会 shadow（隐藏）之前声明的同名变量</p>
<ul>
<li>在后续代码中这个变量名代表的就是新的变量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> guess = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> guess = <span class="number">888</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>shadow 和把变量标记为 <code>mut</code> 是不一样的</p>
<ul>
<li>如果不使用 let 关键字，那么重新给非 <code>mut</code> 的变量赋值会导致编译时错误</li>
<li>而使用 let 声明的同名新变量，也是不可变的</li>
<li>使用 let 声明的同名新变量，它的类型可以与之前不同</li>
</ul>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>标量和复合类型</p>
</li>
<li><p>Rust 是静态编译语言，在编译时必须知道所有变量的类型</p>
<ul>
<li><p>基于使用的值，编译器通常能够推断它的具体类型</p>
</li>
<li><p>但如果可能的类型比较多（例如把String转为整数的parse方法），就必须添加类型的标注，否则编译会报错</p>
<blockquote>
<p>下面例子要是不添加 u32 那么程序就会报错，因为编译器不知道把 42 字符串解析成那种整数类型</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> guess: <span class="built_in">u32</span> = <span class="string">&quot;42&quot;</span>.parse().expect(<span class="string">&quot;not a number&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3></li>
</ul>
</li>
<li><p>一个标量类型代表一个单个的值</p>
</li>
<li><p>Rust 有四个主要的标量类型</p>
<ul>
<li>整数类型</li>
<li>浮点类型</li>
<li>布尔类型</li>
<li>字符类型</li>
</ul>
</li>
</ul>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><ul>
<li><p>整数类型没有小数部分</p>
</li>
<li><p>例如 u32 就是一个无符号的整数类型，占据 32 位的空间</p>
</li>
<li><p>无符号整数类型以 <code>u</code> 开头</p>
</li>
<li><p>有符号整数类型以 <code>i</code> 开头</p>
</li>
<li><p>Rust 的整数类型如图所示</p>
<p><img src="images/Snipaste_2021-06-06_10-57-20.png" alt="Snipaste_2021-06-06_10-57-20"></p>
<ul>
<li>每种都分 <code>i</code> 和 <code>u</code>，以及固定的位数</li>
</ul>
<p><img src="images/Snipaste_2021-06-06_10-59-55.png" alt="Snipaste_2021-06-06_10-59-55"></p>
</li>
</ul>
<h4 id="isize-与-usize-类型"><a href="#isize-与-usize-类型" class="headerlink" title="isize 与 usize 类型"></a><code>isize</code> 与 <code>usize</code> 类型</h4><ul>
<li><code>isize</code> 和 <code>usize</code> 类型的位数由程序运行的计算机的架构所决定<ul>
<li>如果是 64 位计算机，那就是 64 位</li>
<li>如果是 32 位计算机，那就是 32 位</li>
</ul>
</li>
<li>使用 <code>isize</code> 或 <code>usize</code>的主要场景是对某种集合进行索引操作</li>
</ul>
<h4 id="整数字类型"><a href="#整数字类型" class="headerlink" title="整数字类型"></a>整数字类型</h4><table>
<thead>
<tr>
<th>Number literals</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>Decimal</td>
<td>98_222</td>
</tr>
<tr>
<td>Hex</td>
<td>0xff</td>
</tr>
<tr>
<td>Octal</td>
<td>0o77</td>
</tr>
<tr>
<td>Binary</td>
<td>0b1111_0000</td>
</tr>
<tr>
<td>Byte（u8 only）</td>
<td><code>b&#39;A&#39;</code></td>
</tr>
</tbody></table>
<ul>
<li>除了 byte 类型外，所有的数值字面值都允许使用类型后缀<ul>
<li>例如 57u8（57代表u8类型的数）</li>
</ul>
</li>
<li>如果你不太清楚应该使用哪种类型，可以使用 Rust 相应的默认类型</li>
<li>整数的默认类型就是 i32<ul>
<li>总体上来说速度很快，即使在 64 位系统中</li>
</ul>
</li>
</ul>
<h4 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h4><ul>
<li><p>例如：u8 的范围是 0-255，如果你把一个 u8 变量的值设为 256，那么</p>
<ul>
<li><p>调试模式下编译：Rust 会检查整数溢出，如果发生溢出，程序在运行时就会 panic（恐慌）</p>
</li>
<li><p>发布模式下（–release）编译：Rust 不会检查可能导致 panic 的整数溢出</p>
<blockquote>
<p>如果溢出发生，Rust 会执行 “环绕操作”：将256变成0,257变成1（所以并不会导致程序 panic）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><ul>
<li>Rust 有两种基础的浮点类型，也就是含有小数部分的类型<ul>
<li>f32，32位，单精度</li>
<li>f64，64位，双精度</li>
</ul>
</li>
<li>Rust 的浮点类型使用 IEEE-754 标准来表述</li>
<li>f64 是默认类型，因为在现代 CPU 上 f64 和 f32 的速度差不多，而且精度更高</li>
</ul>
<h4 id="数值操作"><a href="#数值操作" class="headerlink" title="数值操作"></a>数值操作</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">5</span> + <span class="number">10</span>; <span class="comment">// i32</span></span><br><span class="line">    <span class="keyword">let</span> difference = <span class="number">95.5</span> - <span class="number">4.3</span>; <span class="comment">//f64</span></span><br><span class="line">    <span class="keyword">let</span> producet = <span class="number">4</span> * <span class="number">30</span>; <span class="comment">//i32</span></span><br><span class="line">    <span class="keyword">let</span> quotient = <span class="number">56.7</span> / <span class="number">32.2</span>; <span class="comment">//f64</span></span><br><span class="line">    <span class="keyword">let</span> reminder = <span class="number">54</span> % <span class="number">5</span>; <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><ul>
<li>Rust 的布尔类型也有两个值：true 和 false</li>
<li>布尔类型占用1个字节空间</li>
<li>符号是 bool</li>
</ul>
<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><ul>
<li><p>Rust 语言中 char 类型被用来描述语言中最基础的单个字符</p>
</li>
<li><p>字符类型的字面值使用单引号</p>
</li>
<li><p>占用4个字节大小</p>
</li>
<li><p>是 Unicode 标量值，可以表示比 ASCII 多得多的字符内容：拼音、中日韩文、零长度空白字符、emoji 表情等</p>
<blockquote>
<p>范围：U+0000 到 U+D7FF、U+E000 到 U+10FFFF</p>
</blockquote>
</li>
<li><p>但 Unicode 中并没有 “字符”的概念，所以直接上认识的字符也许与 Rust 中的概念并不相符</p>
</li>
</ul>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ul>
<li>复合类型可以将多个值放在一个类型里</li>
<li>Rust 提供了两种基础的符合类型：元组（Tuple）、数组</li>
</ul>
<h4 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h4><ul>
<li>Tuple 可以将多个类型的多个值放在一个类型里</li>
<li>Tuple 的长度是固定的：一旦声明就无法改变</li>
</ul>
<h5 id="创建-Tuple"><a href="#创建-Tuple" class="headerlink" title="创建 Tuple"></a>创建 Tuple</h5><ul>
<li>在小括号里，将值用逗号分开</li>
<li>Tuple 中的每个位置都对应一个类型，Tuple 中各元素的类型不必相同</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h5 id="获取-Tuple-元素值"><a href="#获取-Tuple-元素值" class="headerlink" title="获取 Tuple 元素值"></a>获取 Tuple 元素值</h5><blockquote>
<p>可以使用模式匹配来解构（<code>destructure</code>）一个 Tuple 来获取元素的值</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, x, y, z);</span><br></pre></td></tr></table></figure>
<h5 id="访问-Tuple-的元素"><a href="#访问-Tuple-的元素" class="headerlink" title="访问 Tuple 的元素"></a>访问 Tuple 的元素</h5><blockquote>
<p>在 tuple 变量使用点标记法，后接元素的索引号</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>);</span><br></pre></td></tr></table></figure>


<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li>数组也可以将多个值放在一个类型里</li>
<li>数组中每个元素的类型必须相同</li>
<li>数组的长度也是固定的</li>
</ul>
<h5 id="数组的用处"><a href="#数组的用处" class="headerlink" title="数组的用处"></a>数组的用处</h5><ul>
<li>如果想让你的数据存放在 stack（栈）上而不是 heap（堆）上，或者想保证有固定数量的元素，这是使用数组更有好处</li>
<li>数组没有 Vector 灵活<ul>
<li>Vector 和数组类似，它是由标准库提供</li>
<li>Vector 的长度可以改变</li>
<li>如果你不确定应该用数组还是 Vector，那么估计你应该用 Vector</li>
</ul>
</li>
</ul>
<h5 id="声明一个数组"><a href="#声明一个数组" class="headerlink" title="声明一个数组"></a>声明一个数组</h5><ul>
<li><p>在中括号里，各值用逗号分开</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure></li>
<li><p>如果数组的每个元素值都相同，那么可以在：</p>
<ol>
<li>在中括号指定初始值</li>
<li>然后是一个 <code>;</code></li>
<li>最后是数组的长度</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>; <span class="number">5</span>]; 相当于 <span class="keyword">let</span> a = [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h5 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h5></li>
<li><p>数组的类型以这种形式表示：[类型；长度]</p>
<ul>
<li>例如：<code>let a:[i32; 5] = [1, 2, 3, 4, 5];</code></li>
</ul>
</li>
</ul>
<h5 id="访问数组的元素"><a href="#访问数组的元素" class="headerlink" title="访问数组的元素"></a>访问数组的元素</h5><ul>
<li><p>数组是 Stack 上分配的单个块的内存</p>
</li>
<li><p>可以使用索引来访问数组的元素</p>
</li>
<li><p>如果访问的索引超出了数组的范围，那么：</p>
<ul>
<li><p>编译会通过</p>
<blockquote>
<p>编译会通过不是绝对的，Rust 还是会对索引进行一个简单的检查</p>
</blockquote>
</li>
<li><p>运行会报错（runtime 时会 panic）</p>
<blockquote>
<p>rust 不会允许其继续访问相应地址的内存；但是在 C/C++ 中是可以访问的，但是不知道里面是什么东西</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>声明函数使用 <code>fn</code> 关键字</li>
<li>依照惯例，针对函数和变量名，Rust 使用 snake case 命令规范<ul>
<li>所有的字母都是小写的，单词之间使用下划线分开</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    another_function();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">another_function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Annother function&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><ul>
<li>parameters、arguments</li>
<li>在函数签名里，必须声明每个参数的类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    another_function(<span class="number">5</span>); <span class="comment">//argument</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">another_function</span></span>(x: <span class="built_in">i32</span>) &#123; <span class="comment">//parameter</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数体中的语句与表达式"><a href="#函数体中的语句与表达式" class="headerlink" title="函数体中的语句与表达式"></a>函数体中的语句与表达式</h3><ul>
<li>函数体由一系列语句组成，可选的由一个表达式结束</li>
<li>Rust 是一个基于表达式的语言</li>
<li>语句是执行一些动作的指令</li>
<li>表达式会计算产生一个值</li>
<li>函数的定义也是语句</li>
<li>语句不返回，所以不可以使用 let 将一个语句赋给一个变量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">        x + <span class="number">3</span> <span class="comment">//加上;就是一个语句，就不能返回数值了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><ul>
<li>在 <code>-&gt;</code> 符号后边声明函数返回值的类型，但是不可以为返回值命名</li>
<li>在 Rust 里面，返回值就是函数体里面最后一个表达式的值</li>
<li>若想提前返回，需使用 return 关键字，并指定一个值<ul>
<li>大多数函数都是默认使用最后一个表达式作为返回值</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_five</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x + <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = plus_five(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is：&#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li><p>单行注释</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is a function</span></span><br></pre></td></tr></table></figure></li>
<li><p>多行注释</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This is a function</span></span><br><span class="line"><span class="comment">This is a function</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>文档注释</p>
</li>
</ul>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h3><ul>
<li>if 表达式允许你根据条件来执行不同的代码分支<ul>
<li>这个条件必须是 bool 类型</li>
</ul>
</li>
<li>if 表达式中，与条件相关联的代码块就叫分支（arm）</li>
<li>可选的，在后面可以加上一个 else 表达式</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was true&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 else if 处理多重条件，但如果使用多个 else if，那么最好使用 match 来重构代码。</p>
<p>在 let 语句中使用 if，因为 if 是一个表达式，所以可以将它放在 let 语句中等号的右边。</p>
<blockquote>
<p>Rust 是一个强类型的语言，同时也是一个特别安全的语言，所以在编译期间就要知道变量的类型是什么；</p>
<p>如果将下面的 6 改成字符串 <code>6</code> 就会报错，那么无法在编译期间推导变量的类型</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> condition = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> number  = <span class="keyword">if</span> condition &#123;<span class="number">5</span>&#125; <span class="keyword">else</span> &#123;<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li>Rust 提供了 3 循环：loop、while、for</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">let</span> <span class="title">mut</span> <span class="title">counter</span> = 0;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">let</span> <span class="title">result</span> = <span class="title">loop</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">counter</span> += 1;</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="title">counter</span> == 10 &#123;</span></span><br><span class="line"><span class="function">            <span class="title">break</span> <span class="title">counter</span> * 2;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">println</span>!</span>(<span class="string">&quot;The result is: &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> number = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span>  &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">        </span><br><span class="line">        number = number - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    prinltn!(<span class="string">&quot;LIFIOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>使用 for 循环遍历集合</strong></p>
<ul>
<li><p>可以使用 while 或 loop 来遍历集合，但是易错且低效</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value is: &#123;&#125;&quot;</span>, a[index]);</span><br><span class="line">        index = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 for 循环更简洁紧凑，它可以针对集合中的每个元素来执行一些代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>由于 for 循环的安全、简洁性、所以它在 Rust 里用的最多</p>
</li>
</ul>
<p><strong>Range</strong></p>
<ul>
<li>标准库提供</li>
<li>指定一个开始数字和一个结束数字，range 可以生成它们之间的数字</li>
<li>rev 方法可以反转 Range</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).rev() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIF&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 学习笔记：第1章 Rust 简介</title>
    <url>/2021/06/09/Rust%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC1%E7%AB%A0-Rust-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="为什么要用-Rust"><a href="#为什么要用-Rust" class="headerlink" title="为什么要用 Rust"></a>为什么要用 Rust</h2><ul>
<li>Rust 是一种令人兴奋的新编程语言，它可以让每个人编写可靠的且高效的软件</li>
<li>它可以用来替换 C/C++，Rust 和它们具有同样的性能，但是很多常见的 bug 在编译时就可以被消灭</li>
<li>Rust 是一种通用的编程语言，但是它更善于以下场景<ul>
<li>需要运行时的速度</li>
<li>需要内存安全</li>
<li>更好的利用多处理器（多线程）<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h2 id="与其它语言比较"><a href="#与其它语言比较" class="headerlink" title="与其它语言比较"></a>与其它语言比较</h2><ul>
<li>C/C++ 性能非常好，但类型系统和内存都不太安全</li>
<li>Java/C++：拥有GC，能保证内存安全，也有很多优秀的特性，但是性能不行</li>
<li>Rust<ul>
<li>安全</li>
<li>无需GC</li>
<li>易于维护、调试、代码安全高效</li>
</ul>
</li>
</ul>
<h2 id="Rust-特别擅长的领域"><a href="#Rust-特别擅长的领域" class="headerlink" title="Rust 特别擅长的领域"></a>Rust 特别擅长的领域</h2><ul>
<li>高性能 Web Service</li>
<li><code>WebAssembly</code></li>
<li>命令行工具</li>
<li>网络编程</li>
<li>嵌入式设备</li>
<li>系统编程</li>
</ul>
<h2 id="Rust-与-Firefox"><a href="#Rust-与-Firefox" class="headerlink" title="Rust 与 Firefox"></a>Rust 与 Firefox</h2><ul>
<li>Rust 最初是 Mozilla 公司的一个研究性项目，Firefox 是 Rust 产品应用的一个重要的例子</li>
<li>Mozilla 一直以来都在用 Rust 创建一个名为 Servo 的实验性浏览器引擎，其中所有的内容都是并行执行<ul>
<li>目前 Servo 的部分功能已经被集成到 Firefox 里面了</li>
</ul>
</li>
<li>Firefox 原来是量子版就包含了 Servo 的 CSS 渲染引擎<ul>
<li>Rust 使得  Firefox 在这方面得到了巨大的性能改进</li>
</ul>
</li>
</ul>
<h2 id="Rust-的用户和案例"><a href="#Rust-的用户和案例" class="headerlink" title="Rust 的用户和案例"></a>Rust 的用户和案例</h2><ul>
<li>Google：新操作系统 <code>Fuschia</code>，其中 Rust 代码量大约占 30%</li>
<li>Amazon：基于 Linux 开发的直接可以在裸机、虚拟机上运行容器的操作系统</li>
<li>System76：纯 Rust 开发了下一代安全操作系统 Redox</li>
<li>蚂蚁金服：库操作系统 <code>Occlum</code></li>
<li>斯坦福和密歇根大学：嵌入式实时操作系统，应用于 Google 的加密产品</li>
<li>微软：正使用 Rust 重写 windows 系统中的一些低级组件</li>
<li>微软：WinRT/Rust 项目</li>
</ul>
<h2 id="Rust-的优点"><a href="#Rust-的优点" class="headerlink" title="Rust 的优点"></a>Rust 的优点</h2><ul>
<li>性能</li>
<li>安全性</li>
<li>无所畏惧的并发</li>
</ul>
<h2 id="Rust-的缺点"><a href="#Rust-的缺点" class="headerlink" title="Rust 的缺点"></a>Rust 的缺点</h2><ul>
<li>“难学”</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>Rust 有很多独有的概念，它们和现在大多数主流语言都不同</p>
<blockquote>
<p>所以学习 Rust 必须从基础概念一步步学，否则会懵</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>mariadb-connector-r2dbc 设计与实现</title>
    <url>/2021/03/10/mariadb-connector-r2dbc-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>随着响应式（Reactor）编程日益火热，响应式配套组件也在渐渐的完善。将响应式引入到了数据库，其响应式的背压机制与资源调度等特性可以带来巨大的性能。相比传统编程而言，当 Web 服务中入站流量大起来，如果都是一些数据库的操作的话，此时流量会一股脑的冲向数据库，就很容易将数据库压垮（数据库流量一大，可能会导致数据库宕机）。面对这种情况可以使用消息队列来进行削峰填谷，但是维护消息队列也是需要成本的，倘若项目要求的并发不高，可以使用响应式的背压机制，在客户端与服务端之间建立一层缓冲，之后对数据库的操作都会先经过背压这层缓冲，然后发送给数据库。<a id="more"></a>响应式对数据库操作是完全非阻塞的，Reactor 提供 Mono 和 Flux 两个核心 API，它们的 <code>subscribeOn</code> 与 <code>publishOn</code> 方法可以对资源进行细粒度的调度，前者用于改变订阅与下发元素处理线程，而后者用于改变下发元素处理线程，在进行响应式开发中，我们只需根据任务类型（计算型任务或IO型任务）来选择合适调度器即可。</p>
<blockquote>
<p>背压并不是银弹，当流量大起来还是需要使用消息队列和Redis的，背压只是在一定程度上减轻数据库的压力。</p>
</blockquote>
<h2 id="什么是-R2DBC-SPI"><a href="#什么是-R2DBC-SPI" class="headerlink" title="什么是 R2DBC-SPI"></a>什么是 R2DBC-SPI</h2><blockquote>
<p><code>r2dbc-spi</code> github：<a href="https://github.com/r2dbc/r2dbc-spi">https://github.com/r2dbc/r2dbc-spi</a></p>
</blockquote>
<p>R2DBC 全称是响应式关系型数据库连接（Reactive Relational Database Connectivity），R2DBC 作为响应式基础组件，此时就需要一套规范用于在响应式中规范数据库操作，随之 R2DBC-SPI 就应景而生了。R2DBC-SPI 与 JDBC 本质上相同，都是为了给数据库操作提供一层通用抽象，只是两者的侧重点不同，前者是完全非阻塞的，而后者则是阻塞的，因为 JDBC 在底层 API 设计上就不支持非阻塞。</p>
<h2 id="mariadb-connector-r2dbc-简介"><a href="#mariadb-connector-r2dbc-简介" class="headerlink" title="mariadb-connector-r2dbc 简介"></a><code>mariadb-connector-r2dbc</code> 简介</h2><blockquote>
<p><code>mariadb-connector-r2dbc</code> github：<a href="https://github.com/mariadb-corporation/mariadb-connector-r2dbc">https://github.com/mariadb-corporation/mariadb-connector-r2dbc</a></p>
<p><code>r2dbc-mysql</code> github：<a href="https://github.com/mirromutth/r2dbc-mysql">https://github.com/mirromutth/r2dbc-mysql</a></p>
</blockquote>
<p>目前市面上有  <a href="https://github.com/mariadb-corporation/mariadb-connector-r2dbc">mariadb-connector-r2dbc </a> 与 <a href="https://github.com/mirromutth/r2dbc-mysql">r2dbc-mysql</a> 两款 MySQL R2DBC 驱动，在进行项目开发时比较推荐使用 <code>mariadb-connector-r2dbc</code> 作为 MySQL R2DBC 驱动。前者的作者拥有二十余年的 Java 开发经验，同时我也看过这两者的源码，在设计上  <code>mariadb-connector-r2dbc</code> 要比 <code>r2dbc-mysql</code> 更优秀，并且 <code>mariadb-connector-r2dbc</code> 支持 MySQL 和 MariaDB 数据库， 个人觉得前者的潜力是要优于后者。</p>
<h2 id="客户端与服务端消息协议"><a href="#客户端与服务端消息协议" class="headerlink" title="客户端与服务端消息协议"></a>客户端与服务端消息协议</h2><p>客户端向服务端发送数据称为请求（request），而服务端返回给客户端的数据称为响应（response），在 <code>mariadb-connector-r2dbc</code> 中通过<code>ClientMessage</code>和 <code>ServerMessage</code> 接口来区分客户端与服务端消息。</p>
<h3 id="ClientMessage"><a href="#ClientMessage" class="headerlink" title="ClientMessage"></a><code>ClientMessage</code></h3><p>如果客户端需要向数据库发送一条查询 SQL 语句，就需要将 SQL 编码成指定的二进制数据，然后发送给数据库处理。对应在 ClientMessage 接口设计上，该接口中提供了一个 encode 方法，看到方法的签名，该方法接收Context 与 ByteBufAllocator 对象作为方法参数，方法返回类型是一个 ByteBuf 对象，因为 <code>mariadb-connector-r2dbc</code> 使用 reactor-netty 作为数据的传输层，而 reactor-netty 底层又是基于 netty，所以采用 ByteBuf 作为返回类型来对接 netty。</p>
<p> ClientMessage 实现不同对消息编码操作也是不同的，通过 encode 方法可以将具体的编码操作交于对应的实现类，这样起到了一个解耦的作用。我们还可以根据运行时上下文数据 <code>Context</code> 来对消息进行编码操作。Context 在 Reactor 用于持久化一些运行时数据，而在传统编程中使用 ThreadLocal 来进行存储，其实 ThreadLocal 并不合适在 Reactor 场景下使用，因为 Reactor 代码执行时会不断地切换线程，倘若使用了 ThreadLocal 来持久化运行时数据，不但增加了实现复杂度，还可能导致内存泄露。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.mariadb.r2dbc.message.client.ClientMessage</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClientMessage</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">default</span> Sequencer <span class="title">getSequencer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Sequencer((<span class="keyword">byte</span>) <span class="number">0xff</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ByteBuf <span class="title">encode</span><span class="params">(Context context, ByteBufAllocator byteBufAllocator)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="ServerMessage"><a href="#ServerMessage" class="headerlink" title="ServerMessage"></a><code>ServerMessage</code></h3><p>ServerMessage 接口并未有 decode 操作，对于服务端消息来说，解码操作不应该放到该接口里面。只需根据消息的类型来选择对应的解码操作即可，那么可以将这些操作封装在一些特定的解码器中（参考 <code>org.mariadb.r2dbc.client.DecoderState</code>），解析之后将消息下发给对应的 Flux 处理即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.mariadb.r2dbc.message.server.ServerMessage</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServerMessage</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">default</span> Sequencer <span class="title">getSequencer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">ending</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">resultSetEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MariadbConnectionFactory-源码解读"><a href="#MariadbConnectionFactory-源码解读" class="headerlink" title="MariadbConnectionFactory 源码解读"></a>MariadbConnectionFactory 源码解读</h2><p>MariadbConnectionFactory  实现了 <code>r2dbc-spi</code> 中的 ConnectionFactory 接口，该接口设计的也很简单，可以通过 create() 方法来获取数据库链接，另外还提供一个 getMetadata() 方法用于获取工厂的元信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConnectionFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Publisher&lt;? extends Connection&gt; create();</span><br><span class="line">    </span><br><span class="line">    <span class="function">ConnectionFactoryMetadata <span class="title">getMetadata</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后看到 MariadbConnectionFactory 构造器，接收一个 MariadbConnectionConfiguration 对象来作为构造器参数，通过该对象来实例化  MariadbConnectionFactory ，那么这个参数必然有数据库配置的信息，因为 ConnectionFactory 接口定义了一个无参的 create() 方法来获取链接，那么数据库配置信息来源就能排除从 create() 方法传入，此时只能通过构造器参数或者通过特定的方法来设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   org.mariadb.r2dbc.MariadbConnectionFactory#MariadbConnectionFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MariadbConnectionFactory</span><span class="params">(MariadbConnectionConfiguration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = Assert.requireNonNull(configuration, <span class="string">&quot;configuration must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.endpoint = createSocketAddress(configuration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了工厂实例后，就可以调用该工厂的 create() 方法来创建数据库链接。进入 create() 方法，在该方法中调用了类中的 doCreateConnection 方法，之后得到一个 <code>Mono&lt;MariadbConnection&gt;</code> 再将结果强转成 MariadbConnection 对象。不妨有读者会产生疑问，既然都是同一个对象为什么还要进行转换呢？因为这两个 MariadbConnection 是在不同的包下，转换之后的<code>org.mariadb.r2dbc.api.MariadbConnection</code> 是一个接口，该接口继承了 <code>r2dbc-spi</code> 中的 Connection 接口。而<code>Mono&lt;MariadbConnection &gt;</code> 中的 MariadbConnection 是 <code>org.mariadb.r2dbc.api.MariadbConnection</code> 实现类，倘若不进行转换那么就会出现返回值与返回类型不兼容问题。它们两者的关系有点复杂，对于具体的细节，还请读者自行打开源码进行阅读。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.mariadb.r2dbc.MariadbConnectionFactory#create</span></span><br><span class="line">  <span class="keyword">public</span> Mono&lt;org.mariadb.r2dbc.api.MariadbConnection&gt; create() &#123;</span><br><span class="line">    <span class="keyword">return</span> doCreateConnection().cast(org.mariadb.r2dbc.api.MariadbConnection.class);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>进入 <code>doCreateConnection()</code> 方法，会根据 <code>configuration.allowPipelining()</code> 来判断是否采用异步的 Client，默认情况下会使用异步的 Client，对于 ClientPipelineImpl和ClientImpl 两种客户端实现的不同，会在下文进行讲解，此时我们要知道这里客户端采用 ClientPipelineImpl 就好了。看到 14 行，此时并未与服务端建立起 Socket 链接，Reactor 不同于传统编程，只有当下游产生订阅时数据库链接操作才会开始，这也是懒加载的实现。在 15 行，Socket 链接建立之后我们会通过 <code>AuthenticationFlow#exchange</code> 来对客户端身份进行校验，也就是从 configuration 中拿到用户名和密码封装成一个 packet 之后发送给服务端，服务端校验成功之后，此时我们的链接才算真正建立了。</p>
<p>客户端身份校验成功之后，会通过 <code>getIsolationLevel(Client)</code> 来获取数据库隔离等级。在 <code>getIsolationLevel(Client)</code> 方法中，来选择对应的数据库版本查询隔离等级的语句。之后将查询语句发送的服务端，得到服务端消息解析之后返回数据库的隔离等级。</p>
<p>最后通过一个 map 操作将数据的隔离等级作为参数封装成 MariadbConnection 对象返回，获取数据库链接的操作已经分析完了，此时并没有与数据建立起链接，我们只是定义了链接的行为而已，当调用 <code>MariadbConnectionFactory#create</code> 得到一个 <code>Mono&lt;Connection&gt; </code> 对象，只有调用该 Mono 的 subscribe 方法之后才会进行数据库链接操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.mariadb.r2dbc.MariadbConnectionFactory#doCreateConnection</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Mono&lt;MariadbConnection&gt; <span class="title">doCreateConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Mono&lt;Client&gt; clientMono;</span><br><span class="line">    <span class="keyword">if</span> (configuration.allowPipelining()) &#123;</span><br><span class="line">        clientMono =</span><br><span class="line">            ClientPipelineImpl.connect(</span><br><span class="line">            ConnectionProvider.newConnection(), <span class="keyword">this</span>.endpoint, configuration);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clientMono =</span><br><span class="line">            ClientImpl.connect(ConnectionProvider.newConnection(), <span class="keyword">this</span>.endpoint, configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clientMono</span><br><span class="line">        .delayUntil(client -&gt; AuthenticationFlow.exchange(client, <span class="keyword">this</span>.configuration)) <span class="comment">// 身份校验</span></span><br><span class="line">        .cast(Client.class)</span><br><span class="line">        .flatMap(</span><br><span class="line">        client -&gt; &#123;</span><br><span class="line">            Mono&lt;Void&gt; waiting = Mono.empty();</span><br><span class="line">            <span class="keyword">if</span> (configuration.getSessionVariables() != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; configuration.getSessionVariables().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                waiting = setSessionVariables(client);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (configuration.getIsolationLevel() == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取数据库的隔离等级</span></span><br><span class="line">                Mono&lt;IsolationLevel&gt; isolationLevelMono = waiting.then(getIsolationLevel(client));</span><br><span class="line">                <span class="keyword">return</span> isolationLevelMono</span><br><span class="line">                    .map(it -&gt; <span class="keyword">new</span> MariadbConnection(client, it, configuration))</span><br><span class="line">                    .onErrorResume(throwable -&gt; <span class="keyword">this</span>.closeWithError(client, throwable));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> waiting</span><br><span class="line">                    .then(</span><br><span class="line">                    Mono.just(</span><br><span class="line">                        <span class="keyword">new</span> MariadbConnection(</span><br><span class="line">                            client, configuration.getIsolationLevel(), configuration)))</span><br><span class="line">                    .onErrorResume(throwable -&gt; <span class="keyword">this</span>.closeWithError(client, throwable));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .onErrorMap(<span class="keyword">this</span>::cannotConnect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Mono&lt;IsolationLevel&gt; <span class="title">getIsolationLevel</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;SELECT @@tx_isolation&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!client.getVersion().isMariaDBServer()</span><br><span class="line">        &amp;&amp; (client.getVersion().versionGreaterOrEqual(<span class="number">8</span>, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">            || (client.getVersion().getMajorVersion() &lt; <span class="number">8</span></span><br><span class="line">                &amp;&amp; client.getVersion().versionGreaterOrEqual(<span class="number">5</span>, <span class="number">7</span>, <span class="number">20</span>)))) &#123;</span><br><span class="line">        sql = <span class="string">&quot;SELECT @@transaction_isolation&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MariadbSimpleQueryStatement(client, sql)</span><br><span class="line">        .execute()</span><br><span class="line">        .flatMap(</span><br><span class="line">        it -&gt;</span><br><span class="line">        it.map(</span><br><span class="line">            (row, rowMetadata) -&gt; &#123;</span><br><span class="line">                String level = row.get(<span class="number">0</span>, String.class);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;REPEATABLE-READ&quot;</span>:</span><br><span class="line">                        <span class="keyword">return</span> IsolationLevel.REPEATABLE_READ;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;READ-UNCOMMITTED&quot;</span>:</span><br><span class="line">                        <span class="keyword">return</span> IsolationLevel.READ_UNCOMMITTED;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;READ-COMMITTED&quot;</span>:</span><br><span class="line">                        <span class="keyword">return</span> IsolationLevel.READ_COMMITTED;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;SERIALIZABLE&quot;</span>:</span><br><span class="line">                        <span class="keyword">return</span> IsolationLevel.SERIALIZABLE;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> IsolationLevel.READ_COMMITTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">        .defaultIfEmpty(IsolationLevel.READ_COMMITTED)</span><br><span class="line">        .last();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两种-Client-实现"><a href="#两种-Client-实现" class="headerlink" title="两种 Client 实现"></a>两种 Client 实现</h2><p><code>R2DBC-SPI</code> 使用 <code>io.r2dbc.spi.Connection</code> 接口来抽象出数据库链接，而在 <code>mariadb-connector-r2dbc</code> 中通过 <code>org.mariadb.r2dbc.client.Client</code> 接口定义了客户端与数据库交互的行为。Client 作为 <code>mariadb-connector-r2dbc</code> 中的核心接口，屏蔽了与数据库交互的细节。该项目存在有两种 Clinet 实现，一种是同步的 Client （ClientImpl），另外一种是异步的 Client（ClientPipelineImpl），对于这两种 Clinet 实现，它们一些通用方法可以抽到一个抽象类（ClientBase）中，但具体的链接数据库、发送命令以及其它细节需要在具体的 ClientBase 实现类中进行实现。</p>
<p>ClientBase 提供一个含参构造函数，该构造器接收一个 Connection 和 MariadbConnectionConfiguration 对象，这里的 Connection 并不是 R2DBC-SPI 中的 Connection，而是 reactor-netty 中的 Connection，可以理解为是一个 Socket 链接，只不过 reactor-netty 对该 Socket 进行增强了，之后与数据库进行交互也是通过该 Connection 来进行。在第 9 行创建了一个 netty 解码器，MariadbPacketDecoder 继承了 ByteToMessageDecoder，在服务端消息的入站时可以对消息进行解码操作。11与12行添加对应的编解码器到该 Connection 中，从而对客户端与服务端消息进行编解码操作。在 20 行，通过 <code>connection.inbound().receive()</code> 来接收服务端消息，之后并未对服务端消息进行任何处理，难道说并不需要对服务端消息进行处理吗？当然不是这样的，这也是 <code>mariadb-connector-r2dbc</code> 设计的精妙之处，它是通过 MariadbPacketDecoder 对服务端消息解码之后，在通过 FluxSink 来进行数据下发，具体的细节这里先不进行展开，此时只需了解 ClientBase 大致的功能即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.mariadb.r2dbc.client.ClientBase#ClientBase</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClientBase</span><span class="params">(Connection connection, MariadbConnectionConfiguration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.connection = connection;</span><br><span class="line">    <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    <span class="keyword">this</span>.prepareCache =</span><br><span class="line">        <span class="keyword">this</span>.configuration.useServerPrepStmts()</span><br><span class="line">        ? <span class="keyword">new</span> PrepareCache(<span class="keyword">this</span>.configuration.getPrepareCacheSize(), <span class="keyword">this</span>)</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.mariadbPacketDecoder = <span class="keyword">new</span> MariadbPacketDecoder(responseReceivers, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    connection.addHandler(mariadbPacketDecoder);</span><br><span class="line">    connection.addHandler(mariadbPacketEncoder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        connection.addHandlerFirst(</span><br><span class="line">            LoggingHandler.class.getSimpleName(),</span><br><span class="line">            <span class="keyword">new</span> LoggingHandler(ClientBase.class, LogLevel.TRACE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    connection</span><br><span class="line">        .inbound()</span><br><span class="line">        .receive()</span><br><span class="line">        .doOnError(<span class="keyword">this</span>::handleConnectionError)</span><br><span class="line">        .doOnComplete(<span class="keyword">this</span>::closedServlet)</span><br><span class="line">        .then()</span><br><span class="line">        .subscribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Client 接口提供一个 <code>sendCommand(ClientMessage)</code> 用于发送消息给服务端，并且接收一个 <code>Flux&lt;ServerMessage&gt;</code>，既然有两种不同的 Client 实现，那么 ClientBase 就可以直接实现该方法，然后具体的发送细节交由对应的实现类进行实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.mariadb.r2dbc.client.Client#sendCommand(org.mariadb.r2dbc.message.client.ClientMessage)</span></span><br><span class="line"><span class="function">Flux&lt;ServerMessage&gt; <span class="title">sendCommand</span><span class="params">(ClientMessage requests)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>Client#sendCommand(ClientMessage)</code> 方法中调用了 <code>sendCommand</code> 重载方法并传入一个解码状态（DecoderState），最后在调用了 <code>sendCommand(ClientMessage message, DecoderState initialState, String sql)</code> 抽象方法，该抽象方法由对应的继承类来进行实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.mariadb.r2dbc.client.ClientBase#sendCommand(org.mariadb.r2dbc.message.client.ClientMessage)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;ServerMessage&gt; <span class="title">sendCommand</span><span class="params">(ClientMessage message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendCommand(message, DecoderState.QUERY_RESPONSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;ServerMessage&gt; <span class="title">sendCommand</span><span class="params">(ClientMessage message, DecoderState initialState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendCommand(message, initialState, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Flux&lt;ServerMessage&gt; <span class="title">sendCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ClientMessage message, DecoderState initialState, String sql)</span></span>;</span><br></pre></td></tr></table></figure>


<h3 id="ClientImpl"><a href="#ClientImpl" class="headerlink" title="ClientImpl"></a>ClientImpl</h3><p>既然 ClientImpl 是一个同步的 Client，那么我们思考一下“同步”的有什么特征，客户端给服务端消息时，服务端接收到消息需要执行对应的 SQL 语句，那么这个操作时同步进行的，也就是说那个线程处理该链接，语句的执行也就由该线程进行的。针对该特征，那么在 ClientImpl 设计方面可以这样做，当前的语句执行完之后，服务端返回了处理结果，下一条语句才会发送给服务端。此时肯定需要一个容器来存储 SQL 语句，果然与我们猜想一样，在 ClientImpl 中提供了一个 <code>sendingQueue</code> 无界队列用于存储发送的 ClientMessage。</p>
<p>之后我们深入到具体的发送细节，在 36 行实现了 ClientBase 中那个 sendCommand 抽象方法，41-46 对链接（Connection）状态进行校验，要是该链接关闭了后续的代码就没有必要继续执行了，直接向下游发送一个 R2dbcNonTransientResourceException 元素即可。47 行通过 <code>atomicBoolean.compareAndSet(false, true)</code> 来将  atomicBoolean 设置为 true，目的是为了防止该 Flux 被二次订阅，如果没有该保护措施，该 Flux 不小心被下游二次订阅了那么会重复的将该 SQL 语句发送给服务端执行，从而导致客户端与数据库资源的浪费。设置成功之后加上一把重入锁，用于保证操作的安全性。在 59 行会判断 responseReceivers 队列中是否有元素，如果满足，那么将 sink, initialState, sql 封装成一个 CmdElement 对象添加到 responseReceivers 队列中，之后将 ClientMessage 发送到 服务端（向 Connection 中写入 ClientMessage）。我们前面也说到 ClientImpl 是一个同步的操作，同一时间段只能处理一条语句，而 responseReceivers 队列是用于存储服务端消息处理操作的，如果 responseReceivers  中没有元素那么说明当前数据库链接并未处理 SQL 语句，此时客户端可以将 ClientMessage 发送给数据库执行。要是 responseReceivers  队列中没有元素，看到 53-56 行，同样先将 sink, initialState, sql 封装成一个 CmdElement 添加到 responseReceivers 中，接下来的操作与之前不同，而是将 ClientMessage 添加到发送队列中（sendingQueue）等待当前语句处理完成之后在发送给服务端。</p>
<p>那么存放在 sendingQueue 队列中 的 ClientMessage ，会在何时发送呢？现在来看到 <code>ClientImpl#sendNext()</code> 方法，在该方法中同样是先加上一把锁，然后从 sendingQueue 队列中取出一条 ClientMessage，要是不为 null，那么写入到 Connection （发送给服务端）中。我们先不要管 sendNext() 会在何时调用，现在只需要对 ClientImpl 特性有个大概的认识即可。</p>
<blockquote>
<p><code>sendNext()</code> 是 Client 接口定义的一个方法，具体的细节会在 MariadbPacketDecoder 设计解读中提到</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.mariadb.r2dbc.client.ClientImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientImpl</span> <span class="keyword">extends</span> <span class="title">ClientBase</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClientImpl</span><span class="params">(Connection connection, MariadbConnectionConfiguration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(connection, configuration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Queue&lt;ClientMessage&gt; sendingQueue = Queues.&lt;ClientMessage&gt;unbounded().get();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mono&lt;Client&gt; <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ConnectionProvider connectionProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">      SocketAddress socketAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">      MariadbConnectionConfiguration configuration)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TcpClient tcpClient = TcpClient.create(connectionProvider).remoteAddress(() -&gt; socketAddress);</span><br><span class="line">    tcpClient = setSocketOption(configuration, tcpClient);</span><br><span class="line">    <span class="keyword">return</span> tcpClient.connect().flatMap(it -&gt; Mono.just(<span class="keyword">new</span> ClientImpl(it, configuration)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCommandWithoutResult</span><span class="params">(ClientMessage message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.responseReceivers.isEmpty()) &#123;</span><br><span class="line">        connection.channel().writeAndFlush(message);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sendingQueue.add(message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Flux&lt;ServerMessage&gt; <span class="title">sendCommand</span><span class="params">(PreparePacket preparePacket, ExecutePacket executePacket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Flux.error(<span class="keyword">new</span> R2dbcNonTransientResourceException(<span class="string">&quot;Cannot pipeline&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Flux&lt;ServerMessage&gt; <span class="title">sendCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ClientMessage message, DecoderState initialState, String sql)</span> </span>&#123;</span><br><span class="line">    AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">    <span class="keyword">return</span> Flux.create(</span><br><span class="line">        sink -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isConnected()) &#123;</span><br><span class="line">            sink.error(</span><br><span class="line">                <span class="keyword">new</span> R2dbcNonTransientResourceException(</span><br><span class="line">                    <span class="string">&quot;Connection is close. Cannot send anything&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (atomicBoolean.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              lock.lock();</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.responseReceivers.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.responseReceivers.add(<span class="keyword">new</span> CmdElement(sink, initialState, sql));</span><br><span class="line">                connection.channel().writeAndFlush(message);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.responseReceivers.add(<span class="keyword">new</span> CmdElement(sink, initialState, sql));</span><br><span class="line">                sendingQueue.add(message);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ClientMessage next = sendingQueue.poll();</span><br><span class="line">      <span class="keyword">if</span> (next != <span class="keyword">null</span>) connection.channel().writeAndFlush(next);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="ClientPipelineImpl"><a href="#ClientPipelineImpl" class="headerlink" title="ClientPipelineImpl"></a>ClientPipelineImpl</h3><p>ClientPipelineImpl 做为一个异步的 Client，此时我们在思考一下异步的特征。数据库接收到客户端消息时，会将该查询语句交由其它线程进行（线程池某个线程）处理，此时处理链接的线程就可以去接收该客户端发送的其它消息了，之后只需将处理结果按照客户端发送顺序返回给客户端就行了。</p>
<p>废话不多说，我们先来看到 <code>ClientPipelineImpl#sendCommand(ClientMessage message, DecoderState initialState, String sql)</code> 方法，该方法一些操作上与 <code>ClientImpl#sendCommand</code> 相同，在39-44行这里有点不同，此时先封装 CmdElement 添加到 responseReceivers 中，由于 Client 是一个异步处理的客户端，之后直接将 ClientMessage 发送给服务端。在 ClientPipelineImpl 并未向 ClientImpl 一样使用 sendingQueue 存储 ClientMessage（客户端消息），而且该 sendNext 方法也未有任何操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.mariadb.r2dbc.client.ClientPipelineImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientPipelineImpl</span> <span class="keyword">extends</span> <span class="title">ClientBase</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClientPipelineImpl</span><span class="params">(Connection connection, MariadbConnectionConfiguration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(connection, configuration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mono&lt;Client&gt; <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ConnectionProvider connectionProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">      SocketAddress socketAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">      MariadbConnectionConfiguration configuration)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TcpClient tcpClient = TcpClient.create(connectionProvider).remoteAddress(() -&gt; socketAddress);</span><br><span class="line">    tcpClient = setSocketOption(configuration, tcpClient);</span><br><span class="line">    <span class="keyword">return</span> tcpClient.connect().flatMap(it -&gt; Mono.just(<span class="keyword">new</span> ClientPipelineImpl(it, configuration)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCommandWithoutResult</span><span class="params">(ClientMessage message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      connection.channel().writeAndFlush(message);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Flux&lt;ServerMessage&gt; <span class="title">sendCommand</span><span class="params">(PreparePacket preparePacket, ExecutePacket executePacket)</span> </span>&#123;</span><br><span class="line">    AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">    <span class="keyword">return</span> Flux.create(</span><br><span class="line">        sink -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isConnected()) &#123;</span><br><span class="line">            sink.error(</span><br><span class="line">                <span class="keyword">new</span> R2dbcNonTransientResourceException(</span><br><span class="line">                    <span class="string">&quot;Connection is close. Cannot send anything&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (atomicBoolean.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              lock.lock();</span><br><span class="line">              <span class="keyword">this</span>.responseReceivers.add(</span><br><span class="line">                  <span class="keyword">new</span> CmdElement(</span><br><span class="line">                      sink, DecoderState.PREPARE_AND_EXECUTE_RESPONSE, preparePacket.getSql()));</span><br><span class="line">              connection.channel().writeAndFlush(preparePacket);</span><br><span class="line">              connection.channel().writeAndFlush(executePacket);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Flux&lt;ServerMessage&gt; <span class="title">sendCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ClientMessage message, DecoderState initialState, String sql)</span> </span>&#123;</span><br><span class="line">    AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">    <span class="keyword">return</span> Flux.create(</span><br><span class="line">        sink -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isConnected()) &#123;</span><br><span class="line">            sink.error(</span><br><span class="line">                <span class="keyword">new</span> R2dbcNonTransientResourceException(</span><br><span class="line">                    <span class="string">&quot;Connection is close. Cannot send anything&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (atomicBoolean.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              lock.lock();</span><br><span class="line">              <span class="keyword">this</span>.responseReceivers.add(<span class="keyword">new</span> CmdElement(sink, initialState, sql));</span><br><span class="line">              connection.channel().writeAndFlush(message);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNext</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="编解码器解读"><a href="#编解码器解读" class="headerlink" title="编解码器解读"></a>编解码器解读</h2><p>在 netty 中，需要对消息进行一个编解码操作，对于入站消息会进行解码操作，而出站消息会进行编码操作。这些操作都要通过特定的编解码 API 来进行实现，我们在上层都是通过一个对象来充当一个特定的消息，比如说通过 <code>connection.channel().writeAndFlush(ClientMessage)</code> 方法来将 ClientMessage 发送给服务端，因为 Netty 底层都是通过二进制来进行传输的，所以需要一个编码器（MariadbPacketEncoder）来将 ClientMessage 编码成一个 ByteBuf，之后 netty 在转换成 Java NIO 中的 ByteBuffer 发送给服务端。对于入站消息也是一样的，前面我们也提到使用 ServerMessage 来作为服务端消息，那么从一个二进制数据（ByteBuf）转换成 ServerMessage 需要通过一个解码器（MariadbPacketDecoder ）来进行实现。</p>
<h3 id="MariadbPacketEncoder"><a href="#MariadbPacketEncoder" class="headerlink" title="MariadbPacketEncoder"></a>MariadbPacketEncoder</h3><p>MariadbPacketEncoder 实现也很简单，我们来看到它的 encode 方法，该方法接收三个参数，分别是 ChannelHandlerContext、ClientMessage、ByteBuf，我们通过对 ClientMessage 进行编码操作之后将编码结果写入到 out （ByteBuf out）中。在 11 行中通过一个 ClientMessage#encode 方法先对消息进行一个编码操作，不同的 ClientMessage 它的编码操作是不同的，具体的细节需要看 ClientMessage#encode 方法实现。编码完成之后，得到一个 ByteBuf 对象，然后对单个与多个 mysql packet 进行处理，对于多个 mysql packet 会进行分割。</p>
<p>大概流程就是这样，最后还有一个小细节，在 40 行会对 buf 进行一个释放的操作，因为我们的 buf 已经写入到了 out 中，那么就不需要该 buf 了。不少人在编写代码时都会忘记释放不需要的 ByteBuf，这并不是一个好的习惯，及时释放不需要资源的可以提高系统资源的利用率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.mariadb.r2dbc.client.MariadbPacketEncoder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MariadbPacketEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">ClientMessage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Context context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, ClientMessage msg, ByteBuf out)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      buf = msg.encode(<span class="keyword">this</span>.context, ctx.alloc());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// single mysql packet</span></span><br><span class="line">      <span class="keyword">if</span> (buf.writerIndex() - buf.readerIndex() &lt; <span class="number">0xffffff</span>) &#123;</span><br><span class="line">        out.writeMediumLE(buf.writerIndex() - buf.readerIndex());</span><br><span class="line">        out.writeByte(msg.getSequencer().next());</span><br><span class="line">        out.writeBytes(buf);</span><br><span class="line">        <span class="comment">//        buf.release();</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// multiple mysql packet - split in 16mb packet</span></span><br><span class="line">      <span class="keyword">int</span> readerIndex = buf.readerIndex();</span><br><span class="line">      <span class="keyword">int</span> packetLength = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (readerIndex &lt; buf.writerIndex()) &#123;</span><br><span class="line">        packetLength = Math.min(<span class="number">0xffffff</span>, buf.writerIndex() - readerIndex);</span><br><span class="line">        out.writeMediumLE(packetLength);</span><br><span class="line">        out.writeByte(msg.getSequencer().next());</span><br><span class="line">        out.writeBytes(buf.slice(readerIndex, packetLength));</span><br><span class="line">        readerIndex += packetLength;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (packetLength == <span class="number">0xffffff</span>) &#123;</span><br><span class="line">        <span class="comment">// in case last packet is full, sending an empty packet to indicate that command is complete</span></span><br><span class="line">        out.writeMediumLE(packetLength);</span><br><span class="line">        out.writeByte(msg.getSequencer().next());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (buf != <span class="keyword">null</span>) buf.release();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="MariadbPacketDecoder"><a href="#MariadbPacketDecoder" class="headerlink" title="MariadbPacketDecoder"></a>MariadbPacketDecoder</h3><p>MariadbPacketDecoder  作为 netty 入站消息解码器和 <code>mariadb-connector-r2dbc</code> 服务端消息的处理器，同时这也是该项目中最核心的组件之一。先来看到 MariadbPacketDecoder  构造器，接收一个 <code>Queue&lt;CmdElement&gt;</code> 和 <code>Client</code> 作为构造器参数，前者是用于处理服务端消息（通过 CmdElement 中的 Flinksink 下发消息到对应的 Flux 中），后者只是用来将 MariadbPacketDecoder  和Client 进行一个绑定。</p>
<p>既然该对象是 netty 入站消息解码器，那么我们重点关注它的 decode 方法，在该方法中首先对服务端的二进制数据进行解析，解析的过程我们不必过多的关注，我们重点放在 <code>handleBuffer(ByteBuf packet, Sequencer sequencer)</code> 方法中，方法的参数 packet 是解析好后的服务端消息包。既然是服务端消息，那么肯定需要根据它的消息类型来选择对应的解码器进行解码操作，在 69 行获取该服务端消息类型的解码器，之后调用它的解码器得到一个 ServerMessage 对象，最后通过 CmdElement 中的 FluxSink 来将 ServerMessage 进行下发。如果当前的 ServerMessage 是一个结束的标志（76行），那就认为我们当前的 SQL 语句处理完成了，之后就需要加载下一个 CmdElement 对象。如80行所示，会调用 loadNextResponse() 来从 responseReceivers 队列中加载下一个 CmdElement，之后再把原来的 CmdElement 中的 FluxSink 设置成下发元素完毕（FluxSink#complete()），使得下游停止接收元素（意味着这个操作已经完成了）。最后重点来了，我们前面也在 ClientImpl 与 ClientPipelineImpl 章节提到 sendNext() 方法，此时在 83 行会调用该 sendNext() 方法，该方法作为一个扩展点目的是为了兼容不同Client实现的特性 ，倘若当前的 Client 是  ClientImpl，那么就会发送下一条消息给服务端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.mariadb.r2dbc.client.MariadbPacketDecoder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MariadbPacketDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;CmdElement&gt; responseReceivers;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Client client;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Context context = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isMultipart = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">private</span> DecoderState state = DecoderState.INIT_HANDSHAKE;</span><br><span class="line">  <span class="keyword">private</span> CmdElement cmdElement;</span><br><span class="line">  <span class="keyword">private</span> CompositeByteBuf multipart;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> serverCapabilities;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> stateCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MariadbPacketDecoder</span><span class="params">(Queue&lt;CmdElement&gt; responseReceivers, Client client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.responseReceivers = responseReceivers;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf buf, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (buf.readableBytes() &gt; <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> length = buf.getUnsignedMediumLE(buf.readerIndex());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// packet not complete</span></span><br><span class="line">      <span class="keyword">if</span> (buf.readableBytes() &lt; length + <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// extract packet</span></span><br><span class="line">      <span class="keyword">if</span> (length == <span class="number">0xffffff</span>) &#123;</span><br><span class="line">        <span class="comment">// multipart packet</span></span><br><span class="line">        <span class="keyword">if</span> (!isMultipart) &#123;</span><br><span class="line">          isMultipart = <span class="keyword">true</span>;</span><br><span class="line">          multipart = buf.alloc().compositeBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">        buf.skipBytes(<span class="number">4</span>); <span class="comment">// skip length + header</span></span><br><span class="line">        multipart.addComponent(<span class="keyword">true</span>, buf.readRetainedSlice(length));</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// wait for complete packet</span></span><br><span class="line">      <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">        <span class="comment">// last part of multipart packet</span></span><br><span class="line">        buf.skipBytes(<span class="number">3</span>); <span class="comment">// skip length</span></span><br><span class="line">        Sequencer sequencer = <span class="keyword">new</span> Sequencer(buf.readByte());</span><br><span class="line">        multipart.addComponent(<span class="keyword">true</span>, buf.readRetainedSlice(length));</span><br><span class="line"></span><br><span class="line">        handleBuffer(multipart, sequencer);</span><br><span class="line"></span><br><span class="line">        multipart.release();</span><br><span class="line">        isMultipart = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// create Object from packet</span></span><br><span class="line">      ByteBuf packet = buf.readRetainedSlice(<span class="number">4</span> + length);</span><br><span class="line">      packet.skipBytes(<span class="number">3</span>); <span class="comment">// skip length</span></span><br><span class="line">      Sequencer sequencer = <span class="keyword">new</span> Sequencer(packet.readByte());</span><br><span class="line">      handleBuffer(packet, sequencer);</span><br><span class="line">      packet.release();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBuffer</span><span class="params">(ByteBuf packet, Sequencer sequencer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cmdElement == <span class="keyword">null</span> &amp;&amp; !loadNextResponse()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> R2dbcNonTransientResourceException(</span><br><span class="line">          <span class="string">&quot;unexpected message received when no command was send&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state =</span><br><span class="line">        state.decoder(</span><br><span class="line">            packet.getUnsignedByte(packet.readerIndex()),</span><br><span class="line">            packet.readableBytes(),</span><br><span class="line">            serverCapabilities);</span><br><span class="line">    ServerMessage msg = state.decode(packet, sequencer, <span class="keyword">this</span>, cmdElement);</span><br><span class="line">    cmdElement.getSink().next(msg);</span><br><span class="line">    <span class="keyword">if</span> (msg.ending()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cmdElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// complete executed only after setting next element.</span></span><br><span class="line">        CmdElement element = cmdElement;</span><br><span class="line">        loadNextResponse();</span><br><span class="line">        element.getSink().complete();</span><br><span class="line">      &#125;</span><br><span class="line">      client.sendNext();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      state = state.next(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionError</span><span class="params">(Throwable err)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cmdElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cmdElement.getSink().error(err);</span><br><span class="line">      cmdElement = <span class="keyword">null</span>;</span><br><span class="line">      state = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Client <span class="title">getClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStateCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stateCounter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStateCounter</span><span class="params">(<span class="keyword">int</span> counter)</span> </span>&#123;</span><br><span class="line">    stateCounter = counter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrementStateCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateCounter--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getServerCapabilities</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> serverCapabilities;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">loadNextResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cmdElement = responseReceivers.poll();</span><br><span class="line">    <span class="keyword">if</span> (cmdElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">      state = cmdElement.getInitialState();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    state = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">    <span class="keyword">this</span>.serverCapabilities = <span class="keyword">this</span>.context.getServerCapabilities();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文并未对消息的编解码操作进行深入探究，只是对 <code>mariadb-connector-r2dbc</code> 设计进行一个大概的描述，对于具体的实现细节还请读者自行探究。通过这个项目我们可以学习到很多东西，如何将 reactor-netty 落地到项目中，响应式基础库该如何进行设计以及作者一些优秀的设计思路。</p>
]]></content>
      <categories>
        <category>R2DBC</category>
      </categories>
      <tags>
        <tag>Reactor</tag>
        <tag>MySQL</tag>
        <tag>MariaDB</tag>
        <tag>Reactor-Netty</tag>
        <tag>R2DBC</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库驱动如何对接到 JDBC</title>
    <url>/2021/03/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8%E5%A6%82%E4%BD%95%E5%AF%B9%E6%8E%A5%E5%88%B0-JDBC/</url>
    <content><![CDATA[<p>JDBC 作为数据库驱动的 SPI 接口，数据库驱动只需遵循与实现该接口，就可以通过 JDBC 使用该数据库。本文会对 MySQL 驱动进行分析，来探究 MySQL 驱动是如何与 JDBC 进行对接的。</p>
<a id="more"></a>

<h2 id="使用-JDBC-获取数据库链接"><a href="#使用-JDBC-获取数据库链接" class="headerlink" title="使用 JDBC 获取数据库链接"></a>使用 JDBC 获取数据库链接</h2><p>先来看到 JDBC  获取数据库链接的例子，如下所示我们先引入 MySQL 驱动依赖，然后通过 DriverManagement#getConnection 方法传入 url、用户名和密码来获取数据库链接，拿到 Connection 之后就可以对数据库进行一些操作。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(<span class="string">&quot;数据库url&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>相信以上操作大部分读者都已经熟练掌握了，可能会有读者产生疑问，获取数据库链接前不是要通过 <code>Class#fromName</code> 来加载驱动嘛？其实对于该操作是可有可无的，Java 提供了一个 SPI （Service Provider Interface、服务提供接口）机制，而 MySQL 驱动就是使用该机制（META-INF/services 目录声明驱动）来让 DriverManagement 自动加载 MySQL 驱动。</p>
<h2 id="Driver-接口"><a href="#Driver-接口" class="headerlink" title="Driver 接口"></a>Driver 接口</h2><p>Driver 接口作为 JDBC 一个核心接口，基于 JDBC 的数据库驱动都要去实现该接口。Driver 接口的行为也很明确，可以通过该接口来链接数据库，还可以获取数据库的版本号。我们想象一个场景，如果当前项目引入了多个数据库的驱动，这些驱动会通过 SPI 机制来进行注册，那么通过 <code>DriverManagement#getConnection</code> 获取数据库链接时，该如何通过 url 来从这些驱动中找到可以处理的驱动呢？针对这一点需求，Driver 接口该如何进行设计？Driver 接口提供一个 <code>acceptsURL</code> 方法用于判断该 url 是否由这个驱动进行处理，从这一点可以看出，对于接口的设计需要职责分明（该接口需要做什么事情，就赋予该接口什么行为），这也是面对对象编程带来的好处之一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function">Connection <span class="title">connect</span><span class="params">(String url, java.util.Properties info)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">acceptsURL</span><span class="params">(String url)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info)</span><br><span class="line">                         <span class="keyword">throws</span> SQLException;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMajorVersion</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinorVersion</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">jdbcCompliant</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Logger <span class="title">getParentLogger</span><span class="params">()</span> <span class="keyword">throws</span> SQLFeatureNotSupportedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="MySQL驱动如何通过SPI进行注册"><a href="#MySQL驱动如何通过SPI进行注册" class="headerlink" title="MySQL驱动如何通过SPI进行注册"></a><code>MySQL</code>驱动如何通过<code>SPI</code>进行注册</h2><p>MySQL 中 <code>com.mysql.cj.jdbc.Driver</code> 类继承了 <code>NonRegisteringDriver</code> 类并实现了 <code>java.sql.Driver</code> 接口，在该类中的 static 代码块中通过 <code>DriverManager#registerDriver(java.sql.Driver)</code> 方法来将驱动注册到  DriverManager 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             if a database error occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SPI 机制就是通过一个服务发现机制，来对具体的接口的实现类查找并进行初始化，该特性满足了我们驱动注册的需求，在初始化时会调用该 static 代码块从而来实现驱动的注册。</p>
<p>下列对 MySQL 的 SPI 机制进行分析，MySQL 驱动包下的 <code>META-INF/services</code> 目录下创建了一个 <code>java.sql.Driver</code> 文件，文件中内容是该文件名的实现类的全限定名称。也就是说如果使用 SPI 机制，那么需要在 <code>META-INF/services</code> 目录下创建一个 SPI 接口全限定名的文件，然后在文件中输入该接口实现类的全限定名称，如有该接口多个实现类那么换行输入即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.sql.Driver 文件内容</span><br><span class="line">com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>


<h2 id="DriverManagement-getConnection-方法解读"><a href="#DriverManagement-getConnection-方法解读" class="headerlink" title="DriverManagement#getConnection 方法解读"></a><code>DriverManagement#getConnection</code> 方法解读</h2><p>DriverManagement 翻译成中文是“驱动管理”，也就是用于管理驱动。加载驱动的来源有两种，一种是通过系统的 <code>jdbc.drivers</code>属性，另外一种通过 SPI 机制。我们思考一下，DriverManagement 会在何时加载驱动呢？首先可以通过类的初始化机制来进行实现，也就是在 static 静态代码块中进行加载，这种方式称为及时初始化。另外一种方式在获取链接时来通过某个操作加载，也就是按需加载，这种方式称为懒加载。两种方式各有各的优点，及时初始化是空间换时间，而懒加载是时间换空间，我们需要根据业务的需求来选择合适的初始化方式。对于 Web 容器它也采用了懒加载机制，只有在第一次访问时才对 DispatcherServlet 组件来进行初始化。如果提前进行初始化，倘若用户没有访问 web 服务，那么就会造成一个资源的浪费。如果用户肯定会访问 web 服务，我们也可以选择及时初始化，提前来将 DispatcherServlet 组件进行初始化，从而消除第一次访问初始化组件的时间。及时初始化或懒加载并不是万能的银弹，并不是说某种方式一定要优于对方，这两种方式只是为了解决特定场景的需求。</p>
<p>通过 <code>DriverManager#getConnection</code> 方法获取数据库链接时，传入数据库url、用户名与密码。在该方法中会将用户名与密码作为属性添加到 properties 中，添加之前会对用户名与密码来进行校验，这也是为了提高程序的健壮性。倘若此时不进行校验，将值null的属性进行添加，那么在后续的操作还是要进行校验的，这会导致方法的职责不清晰。之后调用该 <code>getConnection</code> 重载方法，我们看到该重载方法的参数，它最后一个参数接收一个类的字节码对象，而 <code>Reflection.getCallerClass()</code> 是用于获取调用该方法的字节码对象，也就是说我们需要拿到调用 <code>getConnection(String url, String user, String password)</code> 方法字节码对象然后传给该 <code>getConnection</code> 重载方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.sql.DriverManager#getConnection(java.lang.String, java.lang.String, java.lang.String)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String user, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    java.util.Properties info = <span class="keyword">new</span> java.util.Properties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">        info.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">        info.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 <code>getConnection</code> 重载方法，首先获取该字节码的 ClassLoader，该 ClassLoader 是为了校验数据库驱动。之后调用 <code>ensureDriversInitialized</code> 方法来加载驱动，正如我们前面所料，DriverManagement 也是使用懒加载机制进行加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When callerCl is null, we should check the application&#x27;s</span></span><br><span class="line"><span class="comment">         * (which is invoking this class indirectly)</span></span><br><span class="line"><span class="comment">         * classloader, so that the JDBC driver class outside rt.jar</span></span><br><span class="line"><span class="comment">         * can be loaded from here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    ClassLoader callerCL = caller != <span class="keyword">null</span> ? caller.getClassLoader() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (callerCL == <span class="keyword">null</span> || callerCL == ClassLoader.getPlatformClassLoader()) &#123;</span><br><span class="line">        callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;The url cannot be null&quot;</span>, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;DriverManager.getConnection(\&quot;&quot;</span> + url + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ensureDriversInitialized();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Walk through the loaded registeredDrivers attempting to make a connection.</span></span><br><span class="line">    <span class="comment">// Remember the first exception that gets raised so we can reraise it.</span></span><br><span class="line">    SQLException reason = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">        <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">        <span class="comment">// skip it.</span></span><br><span class="line">        <span class="keyword">if</span> (isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Success!</span></span><br><span class="line">                    println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="keyword">return</span> (con);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    reason = ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we got here nobody could connect.</span></span><br><span class="line">    <span class="keyword">if</span> (reason != <span class="keyword">null</span>)    &#123;</span><br><span class="line">        println(<span class="string">&quot;getConnection failed: &quot;</span> + reason);</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;getConnection: no suitable driver found for &quot;</span>+ url);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;No suitable driver found for &quot;</span>+ url, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后进入 <code>ensureDriversInitialized</code> 方法，该方法通过 <code>driversInitialized</code> 标志位来知道数据库驱动是否被加载了。前面我们知道 Drivermanagement 加载驱动的方式有两种，那么针对这两种方式，该方法肯定有具体的实现。看到 12 行，会获取系统的 <code>jdbc.drivers</code> 属性赋值给 <code>drivers</code> 变量，之后并不是先对该来源的驱动进行初始化，而是先对 SPI 机制进行初始化。28 行通过 <code>ServiceLoader.load(Driver.class)</code> 来加载所有的 <code>java.sql.Driver</code> SPI 接口的实现类，因为我们能拿到该实现类的对象，那么该对象字节码肯定被加载到 JVM 中，该字节码中的 static 代码块会被调用，从而将驱动注册到  DriverManagement 中。在 56 行会对系统属性来源的驱动进行加载，首先进行校验的操作，如果该值为 null 或为空，那么就没有必要进行加载了。之后根据 <code>:</code>分隔符来进行分割，拿到一个 String 数组，数组中的元素是 <code>java.sql.Driver</code> 接口实现类的全限定名，最后通过 <code>Class#forName(String)</code>  方法来加载相应的数据库驱动。等到全部的驱动都加载完毕之后，最后将 <code>driversInitialized</code> 标志位设置为 <code>true</code>，防止下次调用 <code>ensureDriversInitialized</code> 方法时再次加载驱动，从而导致资源的浪费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensureDriversInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (driversInitialized) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (lockForInitDrivers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (driversInitialized) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String drivers;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            drivers = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> System.getProperty(JDBC_DRIVERS_PROPERTY);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            drivers = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If the driver is packaged as a Service Provider, load it.</span></span><br><span class="line">        <span class="comment">// Get all the drivers through the classloader</span></span><br><span class="line">        <span class="comment">// exposed as a java.sql.Driver.class service.</span></span><br><span class="line">        <span class="comment">// ServiceLoader.load() replaces the sun.misc.Providers()</span></span><br><span class="line"></span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Load these drivers, so that they can be instantiated.</span></span><br><span class="line"><span class="comment">                     * It may be the case that the driver class may not be there</span></span><br><span class="line"><span class="comment">                     * i.e. there may be a packaged driver with the service class</span></span><br><span class="line"><span class="comment">                     * as implementation of java.sql.Driver but the actual class</span></span><br><span class="line"><span class="comment">                     * may be missing. In that case a java.util.ServiceConfigurationError</span></span><br><span class="line"><span class="comment">                     * will be thrown at runtime by the VM trying to locate</span></span><br><span class="line"><span class="comment">                     * and load the service.</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * Adding a try catch block to catch those runtime errors</span></span><br><span class="line"><span class="comment">                     * if driver not available in classpath but it&#x27;s</span></span><br><span class="line"><span class="comment">                     * packaged as service and that service is there in classpath.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (driversIterator.hasNext()) &#123;</span><br><span class="line">                        driversIterator.next();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="comment">// Do nothing</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drivers != <span class="keyword">null</span> &amp;&amp; !drivers.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            String[] driversList = drivers.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            println(<span class="string">&quot;number of Drivers:&quot;</span> + driversList.length);</span><br><span class="line">            <span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    println(<span class="string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);</span><br><span class="line">                    Class.forName(aDriver, <span class="keyword">true</span>,</span><br><span class="line">                                  ClassLoader.getSystemClassLoader());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    println(<span class="string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        driversInitialized = <span class="keyword">true</span>;</span><br><span class="line">        println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完 <code>ensureDriversInitialized</code>  方法，我们再次进入 <code>getConnection</code> 重载方法，看到该方法的 26 行，代码如下所示。首先会遍历 <code>registeredDrivers</code> （注册驱动就是往 <code>registeredDrivers</code> 添加 DriverInfo 对象 ），之后在第 4 行调用 <code>isDriverAllowed</code> 方法进行校验，上述我们提到该 <code>callerCL</code> 是调用 <code>DriverManagement#getConnection</code> 方法的对象的字节码的 ClassLoader ，在 <code>isDriverAllowed</code> 方法中（该方法第7行）使用 <code>callerCL</code>  ClassLoader 重新加载一遍驱动，如果加载后的字节码与驱动的字节码对象相符，那么说明该驱动校验通过了，倘若没有校验通过，那么就跳过这个驱动即可。</p>
<p>校验通过之后在下列代码的第 7 行，通过驱动的 <code>Driver#connect(String, Properties)</code> 方法来链接数据库，此时 JDBC 就与 MySQL 数据库驱动对接上了，具体的链接流程可以参考 MySQL 数据库驱动的实现。驱动的本质是客户端与数据库的通讯协议，将客户端查询的 sql 语句封装成一个packet包（二进制数据）并发送给数据库进行处理，客户端对数据库返回的消息进行解析得到一个查询结果。对于链接数据库流程是先与数据库建立一个 Socket 链接，之后通过用户名与密码封装成一个 packet 传输给数据库从而校验客户端的身份，身份校验成功之后，此时才算真正与数据库建立起了链接（connection），对于具体的实现细节还需读者自行探究。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">    <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">    <span class="comment">// skip it.</span></span><br><span class="line">    <span class="keyword">if</span> (isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">            Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">            <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Success!</span></span><br><span class="line">                println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                <span class="keyword">return</span> (con);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                reason = ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.sql.DriverManager#isDriverAllowed(java.sql.Driver, java.lang.ClassLoader)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDriverAllowed</span><span class="params">(Driver driver, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (driver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            aClass =  Class.forName(driver.getClass().getName(), <span class="keyword">true</span>, classLoader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = ( aClass == driver.getClass() ) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="尾语"><a href="#尾语" class="headerlink" title="尾语"></a>尾语</h2><p>本文对 MySQL 数据库驱动对接 JDBC 流程进行了一个大致的分析，在阅读源码过程中能学习到 JDK 中优秀的设计思路，并且我们可以将这些优秀的设计思路来落地到我们的项目中。阅读源码不光能学到优秀的设计思路，还能达到知其然知其所以然效果，懂得了具体的实现原理，对于编写代码也会事半功倍。</p>
]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>基于剪切板实现单词监控</title>
    <url>/2021/01/16/%E5%9F%BA%E4%BA%8E%E5%89%AA%E5%88%87%E6%9D%BF%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%AF%8D%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<blockquote>
<p>github 地址：<a href="https://github.com/killlowkey/olu-word">https://github.com/killlowkey/olu-word</a></p>
</blockquote>
<p>最近看英文文档比较多，因为在这过程中遇到的生词比较多嘛，所以需要将这些生词添加到生词本中，以便于复习。偶然在 <code>ipad</code> 上看到了欧路词典，使用下来各方面体验都还不错。然而在 pc 上，找了一圈没有找到欧路词典的浏览器插件，这就使得我很懵逼了。这时刚好看到了欧路词典的官网提供了 API 接口，于是萌发了自己写一个添加生词app想法。</p>
<a id="more"></a>

<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>我们要实现的功能很简单，就是通过将生词添加到欧路词典的生词本中。刚开始本来想用 spring shell 来实现，写一个基于命令行 app，最后还是放弃了，因为这种实现使用也比较麻烦，每次添加单词时还需要敲一个命令行这不是闲的蛋疼嘛。于是改用监控剪切板进行实现，我们只需要将生词进行复制，之后app监听到剪切板的内容，如果是一个单词那么就添加到生词本中。欧路词典提供 API 中需要在请求添加一个 <code>Authorization</code> 头来进行请求，这时 <code>Authorization</code> 值肯定不能写死在程序中，不然 <code>Authorization</code> 过期了还需要修改代码重新打包，所以需要从外部的配置文件来进行加载。</p>
<p>基于上述的需求，我们实现的功能大致分为以下三步</p>
<ol>
<li>应用启动时从外部配置文件加载 <code>Authorization</code> </li>
<li>监听剪切板</li>
<li>上传单词到欧路词典</li>
</ol>
<h2 id="配置加载"><a href="#配置加载" class="headerlink" title="配置加载"></a>配置加载</h2><p>应用打包之后时一个 jar 文件，配置要与 jar 文件存放同一目录。首先应用启动时需要获取 jar 文件存放路径，之后加载该路径下的  <code>config.properties</code>，最后从该配置文件中获取 <code>Authorization</code>。</p>
<p>获取 jar 文件存放路径这里有一个小坑，就是我们得到的路径是这个样子的 <code>/C:/xxx/xxx.jar</code> 的，所以需要对路径来进行处理，我们只需要 <code>/c:/xxx/</code> 。获取路径之后，需要找到路径中最后一个 <code>/</code> 位置，之后通过 <code>String#subString</code> 方法来对路径进行截取。</p>
<p>代码使用 reactor 来进行编写，所以这里解释一下代码的含义。在 static 代码块中，通过 <code>Mono#just</code> 来下发一个 <code>Properties</code> 实例元素，之后通过 <code>doOnNext</code> 来加载 <code>config.properties</code> ，最后下游进行订阅从 properties 中获取 authorization 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String authorization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Mono.just(<span class="keyword">new</span> Properties())</span><br><span class="line">            .doOnNext(properties -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    properties.load(<span class="keyword">new</span> FileInputStream(getPath() + <span class="string">&quot;config.properties&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribe(properties -&gt; authorization = properties.getProperty(<span class="string">&quot;authorization&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String path = OluWordApplication.class.getProtectionDomain().getCodeSource().getLocation().getPath();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] chars = path.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = chars[i];</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;/&#x27;</span> || c == <span class="string">&#x27;\\&#x27;</span>) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path.substring(<span class="number">0</span>, index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剪切板监听"><a href="#剪切板监听" class="headerlink" title="剪切板监听"></a>剪切板监听</h2><p>加载配置完成之后，需要做的就是监听剪切板。这里我们采用的是定时监听，每200ms就监听一次，在 Reactor 可以通过 <code>Flux#interval</code> 来进行实现，根据传入 Duration 实例然后定时下发元素。每次进行下发时，就从剪切板获取内容。获取之后我们通过正则进行判断（单词开头是小写或大写字母开头，其余都是小写字母，那么判定该文本是单词），如果该文本是单词的话那么就添加到生词本中。</p>
<p>监听剪切板有这里有一个小坑，假设我复制了一个单词，并且添加到生词本。之后进行监听时还会将这个单词添加到生词本中，这里我们通过 <code>currentWord</code> 来解决这个问题，每次添加单词时就更新 <code>currentWord</code>，如果当前剪切板内容是 <code>currentWord</code>，那么就不需要将该剪切板文本添加到单词本中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String currentWord = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Flux.interval(Duration.ofMillis(<span class="number">200</span>))</span><br><span class="line">        <span class="comment">// 获取剪切板内容</span></span><br><span class="line">        .map(seed -&gt; getSysClipboardText())</span><br><span class="line">        <span class="comment">// 判断该文本是否是单词并且word不等于currentWord</span></span><br><span class="line">        .filter(word -&gt; !word.equals(currentWord) &amp;&amp; word.matches(<span class="string">&quot;[a-zA-Z][a-z]+&quot;</span>))</span><br><span class="line">        <span class="comment">// 添加单词时是 IO 操作所以，采用调度器来进行处理</span></span><br><span class="line">        .publishOn(Schedulers.parallel())</span><br><span class="line">        <span class="comment">// 更新 currentWord</span></span><br><span class="line">        .doOnNext(word -&gt; currentWord = word)</span><br><span class="line">        .doOnSubscribe(subscription -&gt; System.out.println(<span class="string">&quot;欧路词典监控已启动...&quot;</span>))</span><br><span class="line">        .doOnComplete(countDownLatch::countDown)</span><br><span class="line">        <span class="comment">// 添加到生词本</span></span><br><span class="line">        .subscribe(OluWordApplication::submitWord);</span><br><span class="line"></span><br><span class="line">    countDownLatch.await();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getSysClipboardText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String clipboard = ClipboardUtil.getStr();</span><br><span class="line">    <span class="keyword">return</span> clipboard != <span class="keyword">null</span> ? clipboard.trim() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加生词"><a href="#添加生词" class="headerlink" title="添加生词"></a>添加生词</h2><p>添加生词这个步骤很简单，就是构建一个 post 请求，然后进行请求就好了。这里还是使用 <code>Mono#just</code> 来进行下发元素，通过 <code>hutool</code> 的 <code>HttpUtil</code> 来创建一个 post 请求，之后在 <code>doOnNext</code> 中添加请求头与请求体。然后在 <code>map</code> 中执行该请求并获取它的响应码，最后下游订阅时响应码是201 说明我们添加成功了，401说明Authorization过期了或者有误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">submitWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    Mono.just(HttpUtil.createPost(<span class="string">&quot;https://api.frdic.com/api/open/v1/studylist/words&quot;</span>))</span><br><span class="line">        .doOnNext(request -&gt; request</span><br><span class="line">                  .header(<span class="string">&quot;Authorization&quot;</span>, authorization)</span><br><span class="line">                  .body(String.format(<span class="string">&quot;&#123;\&quot;id\&quot;:\&quot;0\&quot;,\&quot;language\&quot;:\&quot;en\&quot;,\&quot;words\&quot;:[\&quot;%s\&quot;]&#125;&quot;</span>,</span><br><span class="line">                                      word.toLowerCase())))</span><br><span class="line">        .map(request -&gt; request.execute().getStatus())</span><br><span class="line">        .subscribe(status -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (status == <span class="number">201</span>) &#123;</span><br><span class="line">                System.out.println(word.toLowerCase() + <span class="string">&quot;：导入成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="number">401</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;授权过期，请更新Authorization，并重启应用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="打包与启动"><a href="#打包与启动" class="headerlink" title="打包与启动"></a>打包与启动</h2><p>之后在控制台输入<code>mvn clean package</code> 打包成功 jar 包，最后通过 <code>java -jar xxx.jar</code> 命令启动应用即可。</p>
]]></content>
      <categories>
        <category>Reactor</category>
      </categories>
      <tags>
        <tag>Reactor</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC 设计与实现</title>
    <url>/2021/01/16/Spring-MVC-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>本文会对 Spring MVC 设计进行大致的描述，比如 web 服务怎么进行启动、DispatcherServlet 注入 ServletContext 流程、DispatcherServlet 是怎么处理请求，但不会涉及具体的实现细节，更多细节还需读者自行探究。</p>
<a id="more"></a>

<h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2><p>下面是 HandlerMapping 接口的定义，HandlerMapping  提供一个 getHandler 方法，可以 根据请求来获取一个 HandlerExecutionChain 对象。在 HandlerExecutionChain 中包含两个重要行为，一个是请求的拦截器（HandlerInterceptor），另外一个是请求 Handler。因为我们在配置拦截器时可以指定某个路径来进行配置，将拦截器放在 HandlerExecutionChain  中可以进行解耦的作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123; </span><br><span class="line">	<span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看到一个基于注解的控制器，我们定义了一个路径为 <code>/hello</code> 路由，客户端通过 GET 请求进行访问时，就向客户端返回 <code>hello world</code>。</p>
<blockquote>
<p><code>hello()</code> 方法是请求的 Handler</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello wolrd&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HandlerMapping 则管理着请求的 Handler，在 HandlerMapping#getHandler 需要传入 request 就可以获取该请求的 HandlerExecutionChain。这里不妨思考一下，我们如何去找到与之对应的 Handler 呢？其实可以根据请求的条件来进行查找，在上述代码中，<code>@GetMapping</code> 代表着我们处理 GET 请求，而 <code>/hello</code> 则为请求的路径，如果请求符合这两个条件那么就返回该 Handler。</p>
<p>在 Web Mvc 中我们定义控制器方法有很多种，不同的方法代表着 HandlerMapping  实现不同。</p>
<ol>
<li>RequestMappingHandlerMapping：注解实现</li>
<li>RouterFunctionMapping： RouterFunction Bean 实现</li>
<li>SimpleUrlHandlerMapping</li>
<li>BeanNameUrlHandlerMapping</li>
</ol>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>DispatcherServlet 作为请求的入口点，用于将请求路由到对应的 Handler上。然而在项目中，我们定义控制器方式有很多种，也就意味着我们可能有多个 HandlerMapping 实现。DispatcherServlet 则管理这些 HandlerMapping ，用于帮助请求找到对应的 Handler 并进行调用。</p>
<h3 id="doDispatch"><a href="#doDispatch" class="headerlink" title="doDispatch"></a>doDispatch</h3><p>doDispatch 作为 DispatcherServlet  核心方法，有很多事情都是在该方法中进行完成。首先会根据请求来找到对应的 Handler，如果未找到那么就向客户端返回 404 （未发现）错误。找到则对 Handler 进行适配，得到一个 HandlerAdapter 对象（Handler 所处的 HandlerMapping 不同，HandlerAdapter 实现也不同），之后调用该 <code>HandlerAdapter#handle</code> 方法用于处理该请求，该方法返回 ModelAndView 对象。如果返回是空的 ModelAndView  对象，那么说明我们不需要对该页面进行渲染，反之需要拿到 <code>view</code> 名称交由渲染引擎进行渲染之后返回给客户端。</p>
<p>请求的拦截器操作也是在该方法中完成，分别在 <code>HandlerAdapter#handle</code> 方法调用前后来调用拦截器，如果该拦截器对请求进行处理（preHandler、postHandler 返回false），那么直接 return doDispatch 方法即可。</p>
<p>上述提到 HandlerAdapter  会对 Handler 进行适配（适配器模式），在 HandlerAdapter  中会对 request/response 进行一些增强的操作，比如对 request参数解析、response 消息转换等等，具体的细节还需读者自行探究，此处不在赘述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.web.servlet.DispatcherServlet#doDispatch</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);  <span class="comment">// 找到与之对应的 Handler</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response); <span class="comment">// 未找到 Handler 返回 404</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); <span class="comment">// 对 handler 进行适配</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;  <span class="comment">// 调用前置拦截器</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); <span class="comment">// 处理请求</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);  <span class="comment">// mv 不为null，则对页面进行渲染</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);  <span class="comment">// postHandler 拦截器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理收尾工作，调用拦截器的 afterCompletion 方法</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                               <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Web服务如何与Spring容器接轨"><a href="#Web服务如何与Spring容器接轨" class="headerlink" title="Web服务如何与Spring容器接轨"></a>Web服务如何与Spring容器接轨</h2><h3 id="容器-onRefresh-方法"><a href="#容器-onRefresh-方法" class="headerlink" title="容器 onRefresh 方法"></a>容器 onRefresh 方法</h3><p><code>AbstractApplicationContext#onRefresh</code> 方法给子类提供了一个扩展点，用于去初始化其他 Bean。web服务本质是一个 Spring 容器，所以会去继承 <code>AbstractApplicationContext</code>，并重写 <code>onRefresh</code> 方法，之后在该方法中来启动 web 服务。</p>
<h3 id="启动-web-Server"><a href="#启动-web-Server" class="headerlink" title="启动 web Server"></a>启动 web Server</h3><blockquote>
<p>AnnotationConfigServletWebServerApplicationContext 是基于注解实现的 Servlet web 容器</p>
</blockquote>
<p>之后我们一起去探究 Servlet Web 服务是如何进行启动的，首先来看到 <code>AnnotationConfigServletWebServerApplicationContext@onRefresh()</code> 方法，在该方法中会去调用 <code>createWebServer()</code> 来创建 Web 服务，我们这里只需关注该方法即可。</p>
<p>首先会去获取本地的 webServer，如果当前 Web 服务并未初始化，那么通过 ServletWebServerFactory 方法传递 ServletContextInitializer 来创建一个 web 服务。之后向 Spring 容器中注入 WebServerGracefulShutdownLifecycle（web容器销毁时收尾工作）、WebServerStartStopLifecycle （用于启动web Server），这两个 Bean 都是依赖 spring 生命周期来进行实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#createWebServer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">    ServletContext servletContext = getServletContext();</span><br><span class="line">    <span class="keyword">if</span> (webServer == <span class="keyword">null</span> &amp;&amp; servletContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ServletWebServerFactory factory = getWebServerFactory();</span><br><span class="line">        <span class="keyword">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">        getBeanFactory().registerSingleton(<span class="string">&quot;webServerGracefulShutdown&quot;</span>,</span><br><span class="line">                                           <span class="keyword">new</span> WebServerGracefulShutdownLifecycle(<span class="keyword">this</span>.webServer));</span><br><span class="line">        getBeanFactory().registerSingleton(<span class="string">&quot;webServerStartStop&quot;</span>,</span><br><span class="line">                                           <span class="keyword">new</span> WebServerStartStopLifecycle(<span class="keyword">this</span>, <span class="keyword">this</span>.webServer));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getSelfInitializer().onStartup(servletContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;Cannot initialize servlet context&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    initPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Web Server 创建细节我们不进行探究，主要是对 Web Server 启动来进行讲解，在 WebServerStartStopLifecycle 中，该对象实现了 SmartLifecycle 接口，该接口会在spring 容器启动之后进行回调，在这回调期间会将 Web Server 进行启动。Web Server 启动后通过一个标志位（running）标识该 Web Server 已经启动，然后广播一个 ServletWebServerInitializedEvent 事件用于在其它地方做一些额外工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.web.servlet.context.WebServerStartStopLifecycle#start</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.webServer.start();</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.applicationContext</span><br><span class="line">        .publishEvent(<span class="keyword">new</span> ServletWebServerInitializedEvent(<span class="keyword">this</span>.webServer, <span class="keyword">this</span>.applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将组件融合到ServletContext中"><a href="#将组件融合到ServletContext中" class="headerlink" title="将组件融合到ServletContext中"></a>将组件融合到ServletContext中</h2><blockquote>
<p><code>ServletContextInitializer#onStartup</code> 会在 <code>TomcatStarter#onStartup</code> 进行调用，对于具体实现细节请读者执行探究</p>
</blockquote>
<p>在 Web Server 启动时，Spring 还给我们留下了一个扩展点（<code>ServletContextInitializer</code>），该接口会在Web容器启动时进行回调，而我们声明的 Filter、Servlet 组件也是在此时注册到 ServletContext 中。</p>
<h3 id="Filter-、Servlet、Listener-原生组件注册"><a href="#Filter-、Servlet、Listener-原生组件注册" class="headerlink" title="Filter 、Servlet、Listener 原生组件注册"></a>Filter 、Servlet、Listener 原生组件注册</h3><p>Servlet 提供 <code>@WebFilter</code>、<code>@WebServlet</code>、<code>@WebListener</code> 三个注解，用于注册 Servlet 原生组件。通过注解来注册Servlet原生组件需要通过 <code>@ServletComponentScan</code> 注解来扫描指定包，在该注解中会引入一个 <code>ServletComponentScanRegistrar</code> 组件来向Spring 容器注册一个 <code>ServletComponentRegisteringPostProcessor</code> 实例用于，该实例是 BeanFactoryPostProcessor 接口的实现，之后对接口进行回调时，会扫描指定包下组件封装成 <code>*RegistrationBean</code> 注入到 Spring 容器中 。<code>*RegistrationBean </code>类型的接口可以在生命周期回调时进行组件的注册，如果我们需要基于组件来进行扩展，那么可以参考 *RegistrationBean 实现。</p>
<p>下面通过讲解 Filter 组件注册，来实现举一反三的目的。通过 <code>WebFilterHandler#doHandle</code> 方法将组件封装成一个 FilterRegistrationBean 对象，该对象 是 ServletContextInitializer 接口实现，会在 Web 容器进行初始化时回调该接口，之后通过 <code>ServletContext#addFilter</code> 来添加 Filter 组件。具体细节还请读者自行探究，此处不在赘述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//org.springframework.boot.web.servlet.ServletComponentRegisteringPostProcessor#scanPackage</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanPackage</span><span class="params">(ClassPathScanningCandidateComponentProvider componentProvider, String packageToScan)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition candidate : componentProvider.findCandidateComponents(packageToScan)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ServletComponentHandler handler : HANDLERS) &#123;</span><br><span class="line">                handler.handle(((AnnotatedBeanDefinition) candidate),</span><br><span class="line">                               (BeanDefinitionRegistry) <span class="keyword">this</span>.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.web.servlet.ServletComponentHandler#handle</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(AnnotatedBeanDefinition beanDefinition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; attributes = beanDefinition.getMetadata()</span><br><span class="line">        .getAnnotationAttributes(<span class="keyword">this</span>.annotationType.getName());</span><br><span class="line">    <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        doHandle(attributes, beanDefinition, registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.boot.web.servlet.WebFilterHandler#doHandle</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandle</span><span class="params">(Map&lt;String, Object&gt; attributes, AnnotatedBeanDefinition beanDefinition,</span></span></span><br><span class="line"><span class="function"><span class="params">                     BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(FilterRegistrationBean.class);</span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;asyncSupported&quot;</span>, attributes.get(<span class="string">&quot;asyncSupported&quot;</span>));</span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;dispatcherTypes&quot;</span>, extractDispatcherTypes(attributes));</span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;filter&quot;</span>, beanDefinition);</span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;initParameters&quot;</span>, extractInitParameters(attributes));</span><br><span class="line">    String name = determineName(attributes, beanDefinition);</span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;servletNames&quot;</span>, attributes.get(<span class="string">&quot;servletNames&quot;</span>));</span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;urlPatterns&quot;</span>, extractUrlPatterns(attributes));</span><br><span class="line">    registry.registerBeanDefinition(name, builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="DispatcherServlet-注册"><a href="#DispatcherServlet-注册" class="headerlink" title="DispatcherServlet 注册"></a>DispatcherServlet 注册</h3><p>上文描述了基于注解方式来注册 Servlet 原生组件，DispatcherServlet  作为所有请求入口点，那么也需要注册到 ServletContext中。DispatcherServlet 与基于注解注册实现类似，都是通过 *RegistrationBean 来进行的。</p>
<p>首先声明一个 DispatcherServlet  Bean，然后将该 Bean 封装成一个 DispatcherServletRegistrationBean Bean，最后依靠 ServletContextInitializer 回调将该 DispatcherServlet  注册到 ServletContext 中。</p>
<p>此时 MVC 就与 Tomcat 进行接轨了， Tomcat 接收到请求时，请求通过 Filter Chain ，之后通过 DispatchServlet 对请求进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration.DispatcherServletConfiguration#dispatcherServlet</span></span><br><span class="line"><span class="meta">@Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DispatcherServlet <span class="title">dispatcherServlet</span><span class="params">(WebMvcProperties webMvcProperties)</span> </span>&#123;</span><br><span class="line">    DispatcherServlet dispatcherServlet = <span class="keyword">new</span> DispatcherServlet();</span><br><span class="line">    dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());</span><br><span class="line">    dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest());</span><br><span class="line">    dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound());</span><br><span class="line">    dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents());</span><br><span class="line">    dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails());</span><br><span class="line">    <span class="keyword">return</span> dispatcherServlet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration.DispatcherServletRegistrationConfiguration#dispatcherServletRegistration</span></span><br><span class="line"><span class="meta">@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title">dispatcherServletRegistration</span><span class="params">(DispatcherServlet dispatcherServlet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                       WebMvcProperties webMvcProperties, ObjectProvider&lt;MultipartConfigElement&gt; multipartConfig)</span> </span>&#123;</span><br><span class="line">    DispatcherServletRegistrationBean registration = <span class="keyword">new</span> DispatcherServletRegistrationBean(dispatcherServlet,</span><br><span class="line">                                                                                           webMvcProperties.getServlet().getPath());</span><br><span class="line">    registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);</span><br><span class="line">    registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">    multipartConfig.ifAvailable(registration::setMultipartConfig);</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
</search>
